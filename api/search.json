[{"id":"a648e8bf5173782b69842a75bd58b03c","title":"JVM相关理解","content":"Java虚拟机整体架构祥图\n类加载器\n虚拟机自带的加载器\n\n启动类（根、BootStrap）加载器\n\n扩展类加载器\n\n应用程序（系统）加载器\n\n\npublic static void main(String[] args) &#123;\n    ClassLoader classLoader &#x3D; OtherTest.class.getClassLoader();\n    &#x2F;&#x2F;AppClassLoader，应用程序加载器   实现java.lang.abstract\n    System.out.println(classLoader);\n    &#x2F;&#x2F;ExtClassLoader，扩展加载器   jre&#x2F;lib&#x2F;ext目录\n    System.out.println(classLoader.getParent());\n    &#x2F;&#x2F;null，不存在或者java无法获取   rt.jar\n    System.out.println(classLoader.getParent().getParent());\n&#125;\n\n双亲委派机制\n类加载器收到加载类的请求\n\n将这个请求向上委托父类加载器去完成，一直向上委托到根加载器\n\n根加载器检查是否能够加载此类，能加载就加载并结束；不能加载则抛出异常，通知子加载器进行加载\n\n重复步骤3\n\n\n示例代码：\npackage java.lang;\n&#x2F;*\n * @Description\n * @Author Doubly\n * @Date 2021&#x2F;10&#x2F;8\n *&#x2F;\npublic class String &#123;\n    public String toString()&#123;\n        return &quot;Hello&quot;;\n    &#125;\n    public static void main(String[] args) &#123;\n        String s &#x3D; new String();\n        System.out.println(s.toString());\n    &#125;\n&#125;\n\n运行结果：\n错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:\n   public static void main(String[] args)\n否则 JavaFX 应用程序类必须扩展javafx.application.Application           \n\n\n\n\n\n\n\n\n\n\n为了保证程序的安全，首先在AppClassLoader中找String，虽然已经找到，但是会继续在ExtClassLoader中找，最后在BootStrapClassLoader中找，找到rt.jar下面的String。所以不会家在我们自己写的String，会报没有main方法的错误。\nAppClassLoader -&gt; ExtClassLoader -&gt; BootstrapClassLoader（最终执行）\nnative关键字凡是带了native关键字的，说明Java的作用范围达不到了。会进入本地方法栈，通过本地方法接口（JNI）调用本地方法库。比如Object中的hashcode()方法，就是调用的本地方法。\n方法区静态变量、常量、类信息（构造方法、接口定义）、运行时的常量池存在方法区中，但是实例变量存在堆内存，和方法区无关\n栈8大基本类型+对象引用+实例的方法\n堆一个jvm只有一个堆内存，堆内存大小是可以调节的。\n默认分配的总内存是电脑的1/4，初始化的内存是电脑的1/64.\n代码示例：\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;返回虚拟机试图使用的最大内存\n        long maxMemory &#x3D; Runtime.getRuntime().maxMemory();\n        &#x2F;&#x2F;返回虚拟机初始化使用的总内存\n        long totalMemory &#x3D; Runtime.getRuntime().totalMemory();\n\n        System.out.println(&quot;max:&quot;+maxMemory + &quot;字节 &quot; + (maxMemory&#x2F;(double)1024&#x2F;1024) + &quot;MB&quot;);\n        System.out.println(&quot;max:&quot;+totalMemory + &quot;字节 &quot; + (totalMemory&#x2F;(double)1024&#x2F;1024) + &quot;MB&quot;);\n    &#125;\n&#125;\n\n结果：\nmax:1908932608字节 1820.5MB \nmax:128974848字节 123.0MB  \n\n​            \n堆内存细分三个区域：\n\n新生区（伊甸园区+幸存区0区+幸存区1区）（幸存区也叫from区与to区）\n\n养老区\n\n永久区\n\n\n新生区伊甸园区所有的对象都是在伊甸园区new出来的，伊甸园区满了会出发轻gc\n幸存区（0区+1区）gc触发后，还存在引用指向对象，对象就不会被回收，会进入幸存区。伊甸园区和幸存区都满了以后会今进行重gc。\n养老区幸存区满了之后，会进入养老区。一般99%的对象都会被清除，默认当一个对象经历15次后可以进入养老区。养老区满了之后就出现了OOM（Out Of Memory）。\n\n\n\n\n\n\n\n\n\n查看JVM堆中每个区的情况，可使用如下参数\nJVM参数：\n-Xms1024m -Xmx2048m -XX:+PrintGCDetails   \n\n输出：\nHeap\n PSYoungGen      total 305664K, used 20971K [0x0000000795580000, 0x00000007aaa80000, 0x00000007c0000000)\n  eden space 262144K, 8% used [0x0000000795580000,0x00000007969fafb8,0x00000007a5580000)\n  from space 43520K, 0% used [0x00000007a8000000,0x00000007a8000000,0x00000007aaa80000)\n  to   space 43520K, 0% used [0x00000007a5580000,0x00000007a5580000,0x00000007a8000000)\n ParOldGen       total 699392K, used 0K [0x0000000740000000, 0x000000076ab00000, 0x0000000795580000)\n  object space 699392K, 0% used [0x0000000740000000,0x0000000740000000,0x000000076ab00000)\n Metaspace       used 3104K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 339K, capacity 388K, committed 512K, reserved 1048576K\n           \n\nOOM之后如何排查问题？\n\n尝试扩大堆内存看结果\n\n分析内存，看一下哪个地方出现了问题（专业工具）\n\n\n内存快照分析工具：MAT（Eclipse最早继承）,Jprofiler\nMAT、JProfiler作用：\n\n分析Dump内存文件，快速定位内存泄漏\n\n获得堆中的数据\n\n获得大的对象\n\n\n如何获取JVM的dump文件？\n-Xms1m -Xmx1m -XX:+HeapDumpOnOutOfMemoryError\n\npublic class Test &#123;\n    &#x2F;&#x2F;-Xms1m -Xmx1m -XX:+HeapDumpOnOutOfMemoryError\n    public static void main(String[] args) &#123;\n        String str &#x3D; &quot;MyString&quot;;\n        while (true)&#123;\n            System.out.println(str);\n            str +&#x3D; new Random(999999999);\n        &#125;\n    &#125;\n&#125;    \n\n永久区/元空间\n\n\n\n\n\n\n\n\n逻辑上存在，物理上不存在。新生区+老年区=jvm使用的堆内存\n这个区域常驻内存的，用来存放jdk自身携带的Class对象、Interface元数据，存储的是Java运行的一些环境或类信息。这个区域不存在垃圾回收。关闭虚拟机就会释放这个区域的内存。\n历史：\n\nJdk1.6之前：永久代，常量池在方法区重\n\nJDK1.7：永久代，但是慢慢的退化了。去永久代，常量池在堆中\n\nJDK1.8以后：无永久代，常量池在元空间\n\n\n垃圾回收垃圾回收主要是在伊甸园区和养老区\n垃圾回收可分为两种：\n\n轻量级垃圾回收（轻gc）\n​    回收新生区和偶尔幸存区\n\n重量级垃圾回收（重gc、full gc）\n​    养老区满了，回收养老区\n\n\nJVM如何判断对象需要回收？\n\n引用计数法：每个对象引用次数做计数，每次被引用则计数+1，失去引用则-1。当计数为0的就清除。\n可达性算法：从GC Roots开始查找引用，能够被找到的说明被引用可达，其余的则引用不可达，需要清除。\n\n什么是GC Roots？\n\n虚拟机栈（栈帧中的本地变量表）中引用的对象\n方法区中类静态属性引用的对象\n方法区中常量引用的对象\n本地方法栈中JNI（即一般说的native方法）中引用的对象\n\ngc算法标记清除法：扫描对象，对活着的对象进行标记；对没有标记的对象进行清除\n​        优点：不需要额外空间\n​        缺点：标记和清除两次扫描，严重浪费时间；会产生内存碎片\n标记压缩：再对标记清除算法进行压缩整理\n​        再次扫描，向一段移动存活对对象，防止内存碎片的产生\n复制算法：新生区以及from区的存活对象复制到to区，to区永远是空的\n​        优点：没有内存碎片\n​        缺点：浪费空间，to区永远是空的\n​        最佳使用场景：对象存活度较低，新生区\n总结内存效率：复制算法&gt;标记清除&gt;标记压缩（时间复杂度）\n内存整齐度：复制算法=标记压缩&gt;标记清除\n内存利用率：标记压缩=标记清除&gt;复制算法\n\n\n\n\n\n\n\n\n\n没有最优的算法，只有最合适的算法。\n所以GC使用分代收集算法\n新生区：存活率较低，使用复制算法\n老年区：存活率较高，使用标记清除+标记压缩算法\n","slug":"JVM相关理解","date":"2021-10-14T14:49:20.000Z","categories_index":"Java","tags_index":"JVM","author_index":"小益子"},{"id":"7c57be050b6f578d9f3dc30fc68278e1","title":"（已解决）IDEA Tomcat控制台中文乱码","content":"@TOC\n前言此篇博客记录自己解决win系统idea配置tomcat控制台输出乱码问题，所有的尝试我都会列举出来。有同样问题的朋友可以借鉴，我本人的解决方法为方法6，推荐优先尝试\n环境系统：windows 7IDEA：2020.1Tomcat：7.0.96\n问题描述：IDEA配置Tomcat后，启动在IDEA控制台的输出，中文为乱码\n尝试办法1.配置启动参数（未解决）-Dfile.encoding&#x3D;UTF-8\n\n\n2.修改IDEA配置，idea64.exe.vmoptions（未解决）安装目录\\JetBrains\\IntelliJ IDEA 2019.2.2\\bin\\idea64.exe.vmoptions与安装目录\\JetBrains\\IntelliJ IDEA 2019.2.2\\bin\\idea.exe.vmoptions增加一行\n-Dfile.encoding&#x3D;UTF-8\n\n\n同时也配置方法1\n3.修改Tomcat配置（未解决）Tomcat安装目录...\\apache-tomcat-8.5.57\\conf\\logging.properties，将所有的UTF-8修改为GBK，保存重启\n4.配置IDEA FileEncoding（未解决）从File-&gt;Setting ,设置File Encodings ,检查Default Encodings 是否是UTF-8\n5.配置JAVA_TOOL_OPTION（未解决）Name：JAVA_TOOL_OPTIONValue：-Dfile.encoding=UTF-8同时配置了方法1,2,4\n6.通过设置修改VmOption（解决）这个不同于方法2，这个是通过程序提供的方法修改参数，最终测试有效Help-&gt;Edit Custom VM Options...，添加一行-Dfile.encoding=UTF-8\n\n\n\n\n\n\n\n\n\n我这里同时配置了方法4，因为我认为统一编码格式挺好的，所以没有还原该配置，如果单独配置方法6不生效，可以尝试配置方法4\n\n总结先附上解决效果图（喜极而泣）\n通过最后成功的方法分析，修改的配置文件其实是在AppData目录下的配置文件\n","slug":"（已解决）IDEA-Tomcat控制台中文乱码","date":"2021-08-19T06:24:30.000Z","categories_index":"工具软件,Java","tags_index":"IDEA","author_index":"小益子"},{"id":"69ac20172609268de83162921aca655c","title":"如何申请免费顶级域名","content":"前言freenom.com是一个提供免费域名申请的网站。目前提供了TK，ML，CF，GA，GQ免费的顶级域名。需要注意的是如果长时间不用，域名会被自动回收。\n步骤\n注册账号（尽量完善个人信息，不完善可能导致下单失败），可以参考一下信息填写\n\n查询域名的可用性，选择要注册的域名，点击完成进入购物车\n\n更改购买时长，最长可以选到12个月免费时长（快到期自动续费即可）\n\n\n\n在购物车中进行付款\n\n在阿里云（其他DNS解析同理）提供的免费DNS解析中进行配置。首先添加域名提示未使用阿里云解析\n\n进行解析设置，添加如下设置。记录类型为NS，记录值为上图中的DNS服务器\n\n在freenom中配置nameserver。首先进入域名管理界面\n\n点击管理选项\n\n选择NameServer\n\n选择Use custom nameservers，填入阿里云的DNS服务器，点击Change Nameservers\n\n返回阿里云域名管理，可以看到DNS服务器状态为正常\n\n在解析管理中添加解析，如图添加了云服务器的配置\n\n由于服务器中还未搭建网站等，直接通过ping命令访问。可以看到成功ping通，并且IP地址为我们服务器的地址。\n\n\n","slug":"如何申请免费顶级域名","date":"2021-08-18T15:37:12.000Z","categories_index":"互联网","tags_index":"免费域名","author_index":"小益子"},{"id":"3ec33308e179bb2c1ac2ac241962ed4f","title":"SpringCloud Nacos","content":"简介为什么叫Nacos\nNacos:Dynamic Naming and Configuration Service前四个字母分别为naming和Configuration的前两个字母，最后的s为service\n是什么？\n一个更易于构建云原生应用的动态服务发现，配置管理和服务管理平台。Nacos就是注册中心+配置中心的组合\n下载&amp;安装&amp;运行\n\n\n\n\n\n\n\n\n环境：Java8 + Maven环境\n下载：https://github.com/alibaba/nacos\n安装：直接解压缩\n运行：运行startup.cmd\n运行成功后访问 http://localhost:8848/nacos，帐号密码默认都是nacos\n服务注册中心服务提供者坐标：\n&lt;!--SpringCloud alibaba Nacos--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n配置：\nserver:\n  port: 9001\n\nspring:\n  application:\n    name: nacos-payment-provider\n  cloud:\n    nacos:\n      discovery:\n        server-addr: 127.0.0.1:8848\n\n启动类：\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class Payment9001 &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Payment9001.class,args);\n    &#125;\n&#125;\n\n服务：\n@RestController\n@RequestMapping(&quot;&#x2F;payment&quot;)\npublic class PaymentController &#123;\n\n    @Value(&quot;$&#123;server.port&#125;&quot;)\n    private String port;\n\n    @GetMapping(&quot;&#x2F;nacos&#x2F;&#123;id&#125;&quot;)\n    public String getPayment(@PathVariable(&quot;id&quot;) Integer id)&#123;\n        return &quot;nacos port:&quot;+port+&quot; id:&quot;+id;\n    &#125;\n&#125;\n\n服务消费者坐标：\n&lt;!--SpringCloud alibaba Nacos--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n配置：\nserver:\n  port: 83\nspring:\n  application:\n    name: nacos-consumer-order\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848\n\n#消费者将要去访问的微服务名称（注册成功进nacos的微服务提供者）\nservice-url:\n  nacos-user-service: http:&#x2F;&#x2F;nacos-payment-provider\n\n启动类：\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class Payment9001 &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Payment9001.class,args);\n    &#125;\n&#125;\n\n配置：\n@Configuration\npublic class Config &#123;\n\n    @Bean\n    @LoadBalanced       &#x2F;&#x2F;负载均衡根据服务名查找报错，需要添加此注解\n    public RestTemplate getRestTemplate()&#123;\n        return new RestTemplate();\n    &#125;\n\n&#125;\n\n服务：\n@Slf4j@RestController@RequestMapping(&quot;&#x2F;consumer&quot;)public class OrderNacosController &#123;    @Resource    private RestTemplate restTemplate;    @Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;)    private String serviceUrl;    @GetMapping(&quot;&#x2F;get&#x2F;&#123;id&#125;&quot;)    public String get(@PathVariable(&quot;id&quot;) String id)&#123;        return restTemplate.getForObject(serviceUrl+&quot;&#x2F;payment&#x2F;nacos&#x2F;&quot;+id,String.class);    &#125;&#125;\n\nCAP切换CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）\nC是所有借点在同一时间看到的数据是一致的；而A的定义是所有的请求都会收到响应。\n如何选择模式\n一般来说，如果不需要存储服务级别的信息且服务实例都是通过nacos-client注册，并且能够保持心跳上报，那么就可以选择AP模式。当前主流的服务如Spring Cloud和Dubbo服务，都是用于AP模式，AP模式为了服务的可用性而减弱了一致性，因此AP模式下只支持注册临时实例。\n如果需要在服务级别编辑或者存储配置信息，那么CP是必须，K8S服务和DNS服务则适用于CP模式。CP模式下则支持注册持久化实力，此时则是Raft协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。\n服务配置中心基础配置坐标：\n&lt;!--SpringCloud alibaba Nacos--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;\n\n配置：\nbootstrap:\nserver:  port: 3377spring:  application:    name: nacos-config-client  cloud:    nacos:      discovery:        server-addr: 192.168.31.66:8848      config:        server-addr: 192.168.31.66:8848        file-extension: yaml #指定配置文件格式\n\napplication:\nspring:  profiles:    active: dev\n\n\n\n\n\n\n\n\n\n\n为什么两个配置？\nNacos同SpringCloud-config一样，在项目初始化时，要保证先从配置中心进行配置拉取。拉取配置之后，才能保证项目的正常启动。\nSpringBoot中配置文件的加载时存在有线级顺序的，bootstrap优先级高于application\n在 Nacos Spring Cloud 中，dataId 的完整格式如下：\n$&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;\n\n\n\n\n\n\n\n\n\nprefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix来配置。\nspring.profiles.active 即为当前环境对应的 profile，详情可以参考 Spring Boot文档。 注意：当 spring.profiles.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 $&#123;prefix&#125;.$&#123;file-extension&#125;\nfile-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。\n","slug":"SpringCloud-Nacos","date":"2021-08-19T06:23:05.000Z","categories_index":"Spring系列,Java","tags_index":"SpringCloud,Nacos","author_index":"小益子"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start创建一个新文章#以下命令功能相同，都在post下面创建了新文章\n$ hexo new &quot;My New Post&quot;\n$ hexo n &quot;My New Post&quot;\n$ hexo new post &quot;My New Post&quot;\n\nMore info: Writing\n启动服务#以下命令等价\n$ hexo server\n$ hexo s\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\n发布网站到远程$ hexo deploy\n$ hexo d\n\nMore info: Deployment\n","slug":"hello-world","date":"2020-08-18T15:37:12.000Z","categories_index":"博客搭建","tags_index":"Hexo","author_index":"小益子"}]