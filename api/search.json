[{"id":"b492804fd34ff483c1550eb5b474ddb6","title":"SpringCloud Sleuth","content":"概述为什么出现这个技术？解决什么问题？在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的服务节点调用来协同产生最后的请求结果，每一个前端请求都会形成一个复杂的分布式服务调用链路，链路中的任何一环出现高延迟或错误都会引起整个请求最后的失败。\n是什么SpringCloud Sleuth提供了一套完整的服务跟踪的解决方案，在分布式系统中提供追踪解决方案并且兼容支持了zipkin\n搭建链路监控步骤1. ZipKin下载SpringCloud从F版起已经不需要自己构建ZipKin Server了，只需要调用jar即可。可以从Maven仓库直接下载\n启动java -jar zipkin-server-2.12.9-exec.jar\n名词解释\nTrace: 类似于树结构的Span集合，表示一条调用链路，存在唯一标识Span: 表示调用链路来源，通俗的理解Span就是一次请求信息\n2. 微服务改造演示中由80consumer调用8001provider，两个微服务中都需要同样配置\n添加依赖坐标&lt;!--包含了sleuth和zipkin--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\nyml配置spring:\n  application:\n    name: cloud-order-server\n  zipkin:\n    base-url: http:&#x2F;&#x2F;localhost:9411\n  sleuth:\n    sampler:\n      #采样率值介于0到1之间，1则表示全部采集\n      probability: 1\n\n3. 结果\n\n","slug":"SpringCloud/SpringCloud Sleuth","date":"2021-10-20T15:55:00.000Z","categories_index":"Java,Spring系列","tags_index":"SpringCloud,Sleuth","author_index":"小益子"},{"id":"9a59448677a38ca58ea31f28d19c2b63","title":"9. Redis缓存穿透和雪崩","content":"","slug":"Redis/9. redis缓存穿透和雪崩","date":"2021-10-20T14:49:29.000Z","categories_index":"Redis","tags_index":"Redis","author_index":"小益子"},{"id":"a29736afc3281cd9df989ab2a6d0da6b","title":"8. Redis主从复制","content":"概念主从复制,是指将一台Redis服务器的数据,复制到其他的Redis服务器。前者称为主节点(masterleader) ,后者称为从节点(slavefolldwer) ;==数据的复制是单向的,只能由主节点到从节点==。Master以写为主, Slave以读为主\n==默认情况下,每台Redis服务器都是主节点==;且一个主节点可以有多个从节点(或没有从节点),但一个从节点只能有一个主节点。\n作用主从复制的作用主要包括:\n\n数据冗余:主从复制实现了数据的热备份,是持久化之外的一种数据冗余方式。\n故障恢复:当主节点出现问题时,可以由从节点提供服务,实现快速的故障恢复;实际上是一种服务的冗余。\n负载均衡:在主从复制的基础上,配合读写分离,可以由主节点提供写服务,由从节点提供读服务(即写Redis数据时应用连接主节点,读Redis数据时应用连接从节点) ,分担服务器负载;尤其是在写少读多的场景下,通过多个从节点分担读负载,可以大大提高Redis服务器的并发量。\n高可用基石:除了上述作用以外,主从复制还是哨兵和集群能够实施的基础,因此说主从复制是Redis高可用的基础。\n\n一般来说,要将Redis运用于工程项目中,只使用一台Redis是万万不能的(宕机) ,原因如下:\n\n从结构上,单个Redis服务器会发生单点故障,并且一台服务器需要处理所有的请求负载,压力较大;\n从容量上,单个Redis服务器内存容量有限,就算一台Redis服务器内存容量为256G,也不能将所有内存用作Redis存储内存一般来说,单台Redis最大使用内存不应该超过20G电商网站上的商品,一般都是一次上传,无数次浏览的,说专业点也就是”多读少写”。\n\n环境搭建主从信息查询\n127.0.0.1:6379&gt; info replication #查看主从信息\n# Replication\nrole:master # 角色，是主机还是从机\nconnected_slaves:0 # 从机个数\nmaster_failover_state:no-failover\nmaster_replid:95e7380696b57cef74de81d4673e127a7619fda0\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:0\nsecond_repl_offset:-1\nrepl_backlog_active:0\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:0\nrepl_backlog_histlen:0\n\n配置文件修改项（避免重复覆盖）\n\n端口号\nPID文件\nLog文件\nrdb文件\n\n第一种方式graph LR\n主机A--&gt;从机B\n主机A--&gt;从机C\n\n配置信息配置从机\n\n命令配置\n# 配置主机IP和端口\n127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379\nOK\n配置文件配置\n\n\nreplicaof 127.0.0.1 6379\n\n\n从机信息\n127.0.0.1:6380&gt; info replication\n# Replication\nrole:slave\nmaster_host:127.0.0.1\nmaster_port:6379\nmaster_link_status:up\nmaster_last_io_seconds_ago:1\nmaster_sync_in_progress:0\nslave_repl_offset:14\nslave_priority:100\nslave_read_only:1\nreplica_announced:1\nconnected_slaves:0\nmaster_failover_state:no-failover\nmaster_replid:cf02d21e7fd2d53056311c0c1550e0d08c02c789\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:14\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:14\n\n主机信息\n127.0.0.1:6379&gt; info replication\n# Replication\nrole:master\nconnected_slaves:2\nslave0:ip&#x3D;127.0.0.1,port&#x3D;6380,state&#x3D;online,offset&#x3D;224,lag&#x3D;1\nslave1:ip&#x3D;127.0.0.1,port&#x3D;6381,state&#x3D;online,offset&#x3D;224,lag&#x3D;1\nmaster_failover_state:no-failover\nmaster_replid:cf02d21e7fd2d53056311c0c1550e0d08c02c789\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:224\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:224\n\n功能测试从机自动同步\n#主机设置值\n127.0.0.1:6379&gt; set k3 v3\nOK\n#从机自动同步\n127.0.0.1:6380&gt; keys *\n1) &quot;k3&quot;\n2) &quot;k1&quot;\n3) &quot;k2&quot;\n\n从机只读\n127.0.0.1:6381&gt; set k4 v4\n(error) READONLY You can&#39;t write against a read only replica.\n\n主机断开\n#主机断开（宕机）\n127.0.0.1:6379&gt; shutdown\nnot connected&gt; \n\n#从机默认依旧作为从机连接主机\n127.0.0.1:6381&gt; info replication\n# Replication\nrole:slave\nmaster_host:127.0.0.1\nmaster_port:6379\nmaster_link_status:down\nmaster_last_io_seconds_ago:-1\nmaster_sync_in_progress:0\nslave_repl_offset:17062\nmaster_link_down_since_seconds:7\nslave_priority:100\nslave_read_only:1\nreplica_announced:1\nconnected_slaves:0\nmaster_failover_state:no-failover\nmaster_replid:cf02d21e7fd2d53056311c0c1550e0d08c02c789\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:17062\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:183\nrepl_backlog_histlen:16880\n\n\n\n\n\n\n\n\n\n\n主机断开后，从机依旧作为从机连接主机，集群就只有读功能，没有写操作。如果主机回来，从机依旧可以直接获取到主机信息。配置哨兵模式后，可以自动选举一个作为主机。\n如果使用命令行配置主从，是不持久的，如果重启了，就会变回主机。配置文件中配置主从是持久生效的。\n从机成功连接到主机后，会发送一个sync同步命令。主机接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，主机将传送整个数据文件到从机，并完成一次完全同步（==这个叫全量复制，后面主机新增值，依次将修改命令传给从机执行，叫做增量复制==）。\n第二种方式graph LR\n主机A--&gt;从机B\n从机B--&gt;从机C\n\n配置信息从机A\nslaveof 127.0.0.1 6379\n从机B\nslaveof 127.0.0.1 6380\n\n功能测试 主机断开，从机手动变为主机\n slaveof no one\n 从机B当选主机，从机C连接B  127.0.0.1:6380&gt; info replication\n# Replication\nrole:master\nconnected_slaves:1\nslave0:ip&#x3D;127.0.0.1,port&#x3D;6381,state&#x3D;online,offset&#x3D;1288,lag&#x3D;0\nmaster_failover_state:no-failover\nmaster_replid:a7131f2ad29e3d74b13249f34c96851590a3c988\nmaster_replid2:7fb1815699259ae0976825b8385930bddd79837f\nmaster_repl_offset:1288\nsecond_repl_offset:99\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:43\nrepl_backlog_histlen:1246\n 主机A重启后，B依然当主机\n  127.0.0.1:6379&gt; info replication\n# Replication\nrole:master\nconnected_slaves:0\nmaster_failover_state:no-failover\nmaster_replid:ccc698a2310cd9e474745d6943768e2c70d942c0\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:0\nsecond_repl_offset:-1\nrepl_backlog_active:0\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:0\nrepl_backlog_histlen:0\n \n\n第三种：哨兵模式（自动选举）graph LR\n哨兵--&gt;主机A\n主机A--&gt;从机B\n哨兵--&gt;从机B\n哨兵--&gt;从机C\n主机A--&gt;从机C\n\n\n配置vim sentinel.conf\n\nsentinel monitor myredis 127.0.0.1 6379 1\n\n启动doubly@xiaoyizideMacBook-Pro bin % redis-sentinel doublyConfig&#x2F;sentinel.conf \n66451:X 28 Jun 2021 13:39:32.117 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\n66451:X 28 Jun 2021 13:39:32.117 # Redis version&#x3D;6.2.4, bits&#x3D;64, commit&#x3D;00000000, modified&#x3D;0, pid&#x3D;66451, just started\n66451:X 28 Jun 2021 13:39:32.117 # Configuration loaded\n66451:X 28 Jun 2021 13:39:32.119 * Increased maximum number of open files to 10032 (it was originally set to 256).\n66451:X 28 Jun 2021 13:39:32.119 * monotonic clock: POSIX clock_gettime\n                _._                                                  \n           _.-&#96;&#96;__ &#39;&#39;-._                                             \n      _.-&#96;&#96;    &#96;.  &#96;_.  &#39;&#39;-._           Redis 6.2.4 (00000000&#x2F;0) 64 bit\n  .-&#96;&#96; .-&#96;&#96;&#96;.  &#96;&#96;&#96;\\&#x2F;    _.,_ &#39;&#39;-._                                  \n (    &#39;      ,       .-&#96;  | &#96;,    )     Running in sentinel mode\n |&#96;-._&#96;-...-&#96; __...-.&#96;&#96;-._|&#39;&#96; _.-&#39;|     Port: 26379\n |    &#96;-._   &#96;._    &#x2F;     _.-&#39;    |     PID: 66451\n  &#96;-._    &#96;-._  &#96;-.&#x2F;  _.-&#39;    _.-&#39;                                   \n |&#96;-._&#96;-._    &#96;-.__.-&#39;    _.-&#39;_.-&#39;|                                  \n |    &#96;-._&#96;-._        _.-&#39;_.-&#39;    |           https:&#x2F;&#x2F;redis.io       \n  &#96;-._    &#96;-._&#96;-.__.-&#39;_.-&#39;    _.-&#39;                                   \n |&#96;-._&#96;-._    &#96;-.__.-&#39;    _.-&#39;_.-&#39;|                                  \n |    &#96;-._&#96;-._        _.-&#39;_.-&#39;    |                                  \n  &#96;-._    &#96;-._&#96;-.__.-&#39;_.-&#39;    _.-&#39;                                   \n      &#96;-._    &#96;-.__.-&#39;    _.-&#39;                                       \n          &#96;-._        _.-&#39;                                           \n              &#96;-.__.-&#39;                                               \n\n66451:X 28 Jun 2021 13:39:32.124 # Sentinel ID is 8c6e1549c754881a4f65cc855dfb9569409762a1\n66451:X 28 Jun 2021 13:39:32.124 # +monitor master myredis 127.0.0.1 6379 quorum 1\n66451:X 28 Jun 2021 13:39:32.127 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:39:32.129 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379\n\n主机shutdown后的哨兵日志\n66451:X 28 Jun 2021 13:42:26.257 # +sdown master myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:26.257 # +odown master myredis 127.0.0.1 6379 #quorum 1&#x2F;1\n66451:X 28 Jun 2021 13:42:26.257 # +new-epoch 1\n66451:X 28 Jun 2021 13:42:26.257 # +try-failover master myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:26.261 # +vote-for-leader 8c6e1549c754881a4f65cc855dfb9569409762a1 1\n66451:X 28 Jun 2021 13:42:26.261 # +elected-leader master myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:26.261 # +failover-state-select-slave master myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:26.330 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:26.330 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:26.414 * +failover-state-wait-promotion slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:26.820 # +promoted-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:26.820 # +failover-state-reconf-slaves master myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:26.876 * +slave-reconf-sent slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:27.881 * +slave-reconf-inprog slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:27.881 * +slave-reconf-done slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:27.961 # +failover-end master myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:27.961 # +switch-master myredis 127.0.0.1 6379 127.0.0.1 6381\n66451:X 28 Jun 2021 13:42:27.962 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381\n66451:X 28 Jun 2021 13:42:27.962 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381\n66451:X 28 Jun 2021 13:42:58.037 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381\n\n6380自动指向6381\n127.0.0.1:6380&gt; info replication\n# Replication\nrole:slave\nmaster_host:127.0.0.1\nmaster_port:6381\nmaster_link_status:up\nmaster_last_io_seconds_ago:2\nmaster_sync_in_progress:0\nslave_repl_offset:34018\nslave_priority:100\nslave_read_only:1\nreplica_announced:1\nconnected_slaves:0\nmaster_failover_state:no-failover\nmaster_replid:9eccaf8f6170f964eab0efa6e894526fc243fda3\nmaster_replid2:d25e84c3694901fea82095385a55d5f487014a28\nmaster_repl_offset:34018\nsecond_repl_offset:9600\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:34018\n\n6381被选举为主机\n127.0.0.1:6381&gt; info replication\n# Replication\nrole:master\nconnected_slaves:1\nslave0:ip&#x3D;127.0.0.1,port&#x3D;6380,state&#x3D;online,offset&#x3D;38750,lag&#x3D;1\nmaster_failover_state:no-failover\nmaster_replid:9eccaf8f6170f964eab0efa6e894526fc243fda3\nmaster_replid2:d25e84c3694901fea82095385a55d5f487014a28\nmaster_repl_offset:38750\nsecond_repl_offset:9600\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:38750\n\n==重新连回来的主机被归并到6381做从机==\n127.0.0.1:6381&gt; info replication\n# Replication\nrole:master\nconnected_slaves:2\nslave0:ip&#x3D;127.0.0.1,port&#x3D;6380,state&#x3D;online,offset&#x3D;47931,lag&#x3D;1\nslave1:ip&#x3D;127.0.0.1,port&#x3D;6379,state&#x3D;online,offset&#x3D;47931,lag&#x3D;0\nmaster_failover_state:no-failover\nmaster_replid:9eccaf8f6170f964eab0efa6e894526fc243fda3\nmaster_replid2:d25e84c3694901fea82095385a55d5f487014a28\nmaster_repl_offset:48063\nsecond_repl_offset:9600\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:48063","slug":"Redis/8. Redis主从复制","date":"2021-10-20T14:49:28.000Z","categories_index":"Redis","tags_index":"Redis","author_index":"小益子"},{"id":"fbeb9b890e6ad27f2985f31986833c5a","title":"7. Redis消息订阅","content":"相关命令\npsubscribe 订阅一个或多个符合给定模式的频道\npubsub 查看订阅与发布系统状态\npublish 将信息发送到指定的频道\npunsubscribe 退订所有给定模式的频道\nsubscribe 订阅给定的一个或多个频道的信息\nunsubscribe 退订给定的频道\n\n测试订阅者\ndoubly@xiaoyizideMacBook-Pro bin % redis-cli\n127.0.0.1:6379&gt; SUBSCRIBE doubly\nReading messages... (press Ctrl-C to quit)\n1) &quot;subscribe&quot;\n2) &quot;doubly&quot;\n3) (integer) 1\n1) &quot;message&quot;\n2) &quot;doubly&quot;\n3) &quot;1234&quot;\n1) &quot;message&quot;\n2) &quot;doubly&quot;\n3) &quot;666&quot;\n\n发布者\ndoubly@xiaoyizideMacBook-Pro bin % redis-cli\n127.0.0.1:6379&gt; PUBLISH doubly 123\n(integer) 0\n127.0.0.1:6379&gt; PUBLISH doubly 123\n(integer) 2\n\n使用代码编写同理\n使用场景\n实时消息系统\n实时聊天\n订阅、关注系统\n\n稍微复杂的场景我们就会使用消息中间件MQ\n","slug":"Redis/7. redis消息订阅","date":"2021-10-20T14:49:27.000Z","categories_index":"Redis","tags_index":"Redis","author_index":"小益子"},{"id":"d75529aa97ccd14fd62310763631c690","title":"6. Redis持久化","content":"RDBRDB（Redis Database）\nRedis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件，待持久化过程都结束了，再用这个临时文件替换上次持久化的文件。整个过程中，主进程不进行IO操作，这就确保了极高的性能。\n如果需要大规模的数据恢复，且对于数据的完整度不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能会丢失（例如Redis突然宕机）\n触发规则\nsave的规则满足情况下，会自动触发rdb持久化\n执行fulshall命令，会自动触发rdb持久化\nRedis shutdown时，也会生成一个rdb文件\n\n如何恢复RDB文件只需要将RDB文件放到reids启动目录下即可，redis会自动读取rdb文件。有时候生产环境我们还会对rdb文件进行备份。\n优点\n适合大规模的数据恢复\n对数据的完整度要求不高\n\n缺点\n需要一定的时间间隔进行操作。如果Redis意外宕机了，最后一次持久化的数据就没有了\nfork进程的时候，会占用一定的内存空间\n\nAOFAOF （Append Only File）\n以日志的形式来记录每个操作，将Redis执行过的所有命令记录下来（读操作不记录），只许追加文件但不可以改文件，redis启动之初会读取该文件重新构建数据。换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。\n如果AOF文件有错误，redis将启动失败。redis同事提供了一个aof修复工具redis-check-aof，使用命令redis-check-aof --fix appendonly.aof就可以修复错误（删除错误的一条命令）\ndoubly@xiaoyizideMacBook-Pro bin % redis-check-aof --fix appendonly.aof\n0x              6a: Expected \\r\\n, got: 7364\nAOF analyzed: size&#x3D;128, ok_up_to&#x3D;81, ok_up_to_line&#x3D;26, diff&#x3D;47\nThis will shrink the AOF from 128 bytes, with 47 bytes, to 81 bytes\nContinue? [y&#x2F;N]: y\nSuccessfully truncated AOF\n\n配置#每次修改都会sync，消耗性能\nappendfsync always\n#每秒执行一次sync，可能会丢失这1s的数据\nappendfsync everysec\n#不执行sync，这个时候操作系统自己同步数据，速度最快\nappendfsync no\n\n重写规则auto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\n\n如果AOF文件大于64M，就会fork一个新的子进程将我们的文件来进行重写\n优点\n 每一次修改都同步，文件的完整会更加好。\n 每秒同步一次，可能会丢失一秒的数据\n 从不同步，效率最高\n\n缺点\n相对于数据文件来说，aof远远大于rdb，修复速度也比rdb慢\nAOF运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化\n\n","slug":"Redis/6. Redis持久化","date":"2021-10-20T14:49:26.000Z","categories_index":"Redis","tags_index":"Redis","author_index":"小益子"},{"id":"a0274a1990a09ab30c455a7b67d6d5c7","title":"5. Redis Conf详解","content":"\n\n\n\n\n\n\n\n\n单位\n单位大小写不敏感\n# Note on units: when memory size is needed, it is possible to specify\n# it in the usual form of 1k 5GB 4M and so forth:\n#\n# 1k &#x3D;&gt; 1000 bytes\n# 1kb &#x3D;&gt; 1024 bytes\n# 1m &#x3D;&gt; 1000000 bytes\n# 1mb &#x3D;&gt; 1024*1024 bytes\n# 1g &#x3D;&gt; 1000000000 bytes\n# 1gb &#x3D;&gt; 1024*1024*1024 bytes\n#\n# units are case insensitive so 1GB 1Gb 1gB are all the same.\n\n\n\n\n\n\n\n\n\n\nINCLUDES 引入配置文件\n可以引入多个配置文件组成一个Redis配置文件\n# include &#x2F;path&#x2F;to&#x2F;local.conf\n# include &#x2F;path&#x2F;to&#x2F;other.conf\n\n\n\n\n\n\n\n\n\n\nMODULES 模块加载\n# loadmodule &#x2F;path&#x2F;to&#x2F;my_module.so\n# loadmodule &#x2F;path&#x2F;to&#x2F;other_module.so\n\n\n\n\n\n\n\n\n\n\nNETWORK 网络\n#可以访问的IP，若要远程访问，需要配置*或者访问者IP\n\n# bind 192.168.1.100 10.0.0.1     # listens on two specific IPv4 addresses\n# bind 127.0.0.1 ::1              # listens on loopback IPv4 and IPv6\n# bind * -::*                     # like the default, all available interfaces\nbind 127.0.0.1 -::1\n#是否开启保护模式\nprotected-mode yes\n#访问端口\nport 6379\n\n\n\n\n\n\n\n\n\n\nGENERAL 通用配置\n#是否以守护进程启动\ndaemonize yes\n#如果以守护进程启动，需要配置一个守护进程Pid文件\npidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid\n\n#日志级别\n# debug (a lot of information, useful for development&#x2F;testing)\n# verbose (many rarely useful info, but not a mess like the debug level)\n# notice (moderately verbose, what you want in production probably)\n# warning (only very important &#x2F; critical messages are logged)\n#默认notice，生产环境使用\nloglevel notice\n#日志输出位置\nlogfile &quot;&quot;\n#数据库数量\ndatabases 16\n#是否展示logo\nalways-show-logo no\n\nset-proc-title yes\nproc-title-template &quot;&#123;title&#125; &#123;listen-addr&#125; &#123;server-mode&#125;&quot;\n\n\n\n\n\n\n\n\n\n\nSNAPSHOTTING 快照 RDB配置\n#每3600s修改1个数据，则更新快照\nsave 3600 1\n#每300s修改100个数据，则更新快照\nsave 300 100\n#每60s修改10000个数据，则更新快照\nsave 60 10000\n#持久化发生错误是否继续持久化\nstop-writes-on-bgsave-error yes\n#是否对rdb文件进行压缩，会消耗一定CPU资源\nrdbcompression yes\n#保存文件的时候是否进行检查校验\nrdbchecksum yes\n#持久化文件名\ndbfilename dump.rdb\n#文件存放路径\ndir .&#x2F;\n\n\n\n\n\n\n\n\n\n\nREPLICATION 主从配置\n\n\n\n\n\n\n\n\n\nSECURITY 安全\n设置密码\n# requirepass foobared\n\n\n\n\n\n\n\n\n\n\nCLIENTS 客户端限制\n# 最大客户端连接数量\n# maxclients 10000\n\n\n\n\n\n\n\n\n\n\nAPPEND ONLY MODE AppendOnly模式 AOF配置\n#默认是不开启AOF模式的，默认使用的是RDB，在大部分情况下，RDB足够\nappendonly no\n#持久化的文件名\nappendfilename &quot;appendonly.aof&quot;\n#每次修改都会同步\n# appendfsync always\n#每秒执行一次同步，可能丢失1s的数据\nappendfsync everysec\n# 不进行同步\n# appendfsync no","slug":"Redis/5. Redis Conf详解","date":"2021-10-20T14:49:25.000Z","categories_index":"Redis","tags_index":"Redis","author_index":"小益子"},{"id":"269d526417b005df367f7ce3a1296fbf","title":"4. Redis整合SpringBoot.md","content":"依赖\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\nSpringBoot操作数据：Spring-data jpa jdbc mongodb redis\nSpringData也是和SpringBoot齐名的项目\n\n\n\n\n\n\n\n\n\n说明：SpringBoot 2.x.x以后，原来使用的jedis被替换成了lettuce\n\njedis:采用的直连，多个线程操作的话，是不安全的。如果要避免不安全的，使用jedis连接池。像BIO模式\n\nlettuce:采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况。可以减少线程数据。像NIO模式\n\n\n自动配置源码分析\n@Configuration(\n    proxyBeanMethods &#x3D; false\n)\n@ConditionalOnClass(&#123;RedisOperations.class&#125;)\n&#x2F;&#x2F;所有的Redis配置在RedisProperties类里面就可以看到\n@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)\n@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)\npublic class RedisAutoConfiguration &#123;\n    public RedisAutoConfiguration() &#123;\n    &#125;\n\n    @Bean\n    &#x2F;&#x2F;如果没有则创建，我们可以自己创建一个覆盖这个Bean\n    @ConditionalOnMissingBean(\n        name &#x3D; &#123;&quot;redisTemplate&quot;&#125;\n    )\n    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)\n    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;\n        RedisTemplate&lt;Object, Object&gt; template &#x3D; new RedisTemplate();\n        template.setConnectionFactory(redisConnectionFactory);\n        return template;\n    &#125;\n\n    &#x2F;&#x2F;单独提供了一个操作String类型的Template，redis操作String比较常用\n    @Bean\n    @ConditionalOnMissingBean\n    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)\n    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;\n        StringRedisTemplate template &#x3D; new StringRedisTemplate();\n        template.setConnectionFactory(redisConnectionFactory);\n        return template;\n    &#125;\n&#125;\n配置\nspring.redis.host&#x3D;127.0.0.1\nspring.redis.port&#x3D;6379\n\n\n使用\n&#x2F;&#x2F;redisTemplate提供了对每种数据类型的操作，然后操作与命令基本相同\nredisTemplate.opsForSet();\nredisTemplate.opsForHash();\nredisTemplate.opsForList();\nredisTemplate.opsForZSet();\nredisTemplate.opsForValue();\nredisTemplate.opsForGeo();\nredisTemplate.opsForHyperLogLog();\n\n示例\n@SpringBootTest\nclass SpringbootApplicationTests &#123;\n\n    @Resource\n    private RedisTemplate redisTemplate;\n\n    @Test\n    void contextLoads() &#123;\n        redisTemplate.opsForValue().set(&quot;name&quot;,&quot;Doubly&quot;);\n        System.out.println(redisTemplate.opsForValue().get(&quot;name&quot;));\n    &#125;\n\n&#125;\n\n\n\n自定义RestTemplate模板\n@Configuration\npublic class RedisConfig &#123;\n\n    &#x2F;&#x2F;自己定义了一个RestTemplate\n    @Bean\n    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;\n\n        &#x2F;&#x2F;一般为了方便，直接使用&lt;String,Objcet&gt;\n        RedisTemplate&lt;String, Object&gt; template &#x3D; new RedisTemplate();\n        template.setConnectionFactory(redisConnectionFactory);\n\n        &#x2F;&#x2F;json序列化\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper objectMapper &#x3D; new ObjectMapper();\n        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);\n\n        &#x2F;&#x2F;String序列化\n        StringRedisSerializer stringRedisSerializer &#x3D; new StringRedisSerializer();\n\n        &#x2F;&#x2F;设置key使用String序列化\n        template.setKeySerializer(stringRedisSerializer);\n        &#x2F;&#x2F;设置hashkey使用String序列化\n        template.setHashKeySerializer(stringRedisSerializer);\n        &#x2F;&#x2F;设置value使用json序列化\n        template.setValueSerializer(jackson2JsonRedisSerializer);\n        &#x2F;&#x2F;设置HashValue使用json序列化\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\n\n        template.afterPropertiesSet();\n\n        return template;\n    &#125;\n\n&#125;\n\n\nSpringBoot RedisUtil工具类\npackage cn.doubly.utils;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.CollectionUtils;\n\nimport javax.annotation.Resource;\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\n\n@Component\npublic final class RedisUtil &#123;\n\n\n    @Resource\n    private RedisTemplate&lt;String, Object&gt; redisTemplate;\n\n    &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;common&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n    &#x2F;**\n     * 26\n     * 指定缓存失效时间\n     * 27\n     *\n     * @param key  键\n     *             28\n     * @param time 时间(秒)\n     *             29\n     * @return 30\n     *&#x2F;\n\n    public boolean expire(String key, long time) &#123;\n\n        try &#123;\n\n            if (time &gt; 0) &#123;\n\n                redisTemplate.expire(key, time, TimeUnit.SECONDS);\n\n            &#125;\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 44\n     * 根据key 获取过期时间\n     * 45\n     *\n     * @param key 键 不能为null\n     *            46\n     * @return 时间(秒) 返回0代表为永久有效\n     * 47\n     *&#x2F;\n\n    public long getExpire(String key) &#123;\n\n        return redisTemplate.getExpire(key, TimeUnit.SECONDS);\n\n    &#125;\n\n    &#x2F;**\n     * 53\n     * 判断key是否存在\n     * 54\n     *\n     * @param key 键\n     *            55\n     * @return true 存在 false不存在\n     * 56\n     *&#x2F;\n\n    public boolean hasKey(String key) &#123;\n\n        try &#123;\n\n            return redisTemplate.hasKey(key);\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 67\n     * 删除缓存\n     * 68\n     *\n     * @param key 可以传一个值 或多个\n     *            69\n     *&#x2F;\n\n    @SuppressWarnings(&quot;unchecked&quot;)\n\n    public void del(String... key) &#123;\n\n        if (key !&#x3D; null &amp;&amp; key.length &gt; 0) &#123;\n\n            if (key.length &#x3D;&#x3D; 1) &#123;\n\n                redisTemplate.delete(key[0]);\n\n            &#125; else &#123;\n\n\n                redisTemplate.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key));\n            &#125;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;String&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n    &#x2F;**\n     * 83\n     * 普通缓存获取\n     * 84\n     *\n     * @param key 键\n     *            85\n     * @return 值\n     * 86\n     *&#x2F;\n\n    public Object get(String key) &#123;\n\n        return key &#x3D;&#x3D; null ? null : redisTemplate.opsForValue().get(key);\n\n    &#125;\n\n    &#x2F;**\n     * 92\n     * 普通缓存放入\n     * 93\n     *\n     * @param key   键\n     *              94\n     * @param value 值\n     *              95\n     * @return true成功 false失败\n     * 96\n     *&#x2F;\n\n    public boolean set(String key, Object value) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForValue().set(key, value);\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 109\n     * 普通缓存放入并设置时间\n     * 110\n     *\n     * @param key   键\n     *              111\n     * @param value 值\n     *              112\n     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期\n     *              113\n     * @return true成功 false 失败\n     * 114\n     *&#x2F;\n\n    public boolean set(String key, Object value, long time) &#123;\n\n        try &#123;\n\n            if (time &gt; 0) &#123;\n\n                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);\n\n            &#125; else &#123;\n\n                set(key, value);\n\n            &#125;\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 130\n     * 递增\n     * 131\n     *\n     * @param key   键\n     *              132\n     * @param delta 要增加几(大于0)\n     *              133\n     * @return 134\n     *&#x2F;\n\n    public long incr(String key, long delta) &#123;\n\n        if (delta &lt; 0) &#123;\n\n            throw new RuntimeException(&quot;递增因子必须大于0&quot;);\n\n        &#125;\n\n        return redisTemplate.opsForValue().increment(key, delta);\n\n    &#125;\n\n    &#x2F;**\n     * 143\n     * 递减\n     * 144\n     *\n     * @param key   键\n     *              145\n     * @param delta 要减少几(小于0)\n     *              146\n     * @return 147\n     *&#x2F;\n\n    public long decr(String key, long delta) &#123;\n\n        if (delta &lt; 0) &#123;\n\n            throw new RuntimeException(&quot;递减因子必须大于0&quot;);\n\n        &#125;\n\n        return redisTemplate.opsForValue().increment(key, -delta);\n\n    &#125;\n\n    &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Map&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n    &#x2F;**\n     * 157\n     * HashGet\n     * 158\n     *\n     * @param key  键 不能为null\n     *             159\n     * @param item 项 不能为null\n     *             160\n     * @return 值\n     * 161\n     *&#x2F;\n\n    public Object hget(String key, String item) &#123;\n\n        return redisTemplate.opsForHash().get(key, item);\n\n    &#125;\n\n    &#x2F;**\n     * 167\n     * 获取hashKey对应的所有键值\n     * 168\n     *\n     * @param key 键\n     *            169\n     * @return 对应的多个键值\n     * 170\n     *&#x2F;\n\n    public Map&lt;Object, Object&gt; hmget(String key) &#123;\n\n        return redisTemplate.opsForHash().entries(key);\n\n    &#125;\n\n    &#x2F;**\n     * 176\n     * HashSet\n     * 177\n     *\n     * @param key 键\n     *            178\n     * @param map 对应多个键值\n     *            179\n     * @return true 成功 false 失败\n     * 180\n     *&#x2F;\n\n    public boolean hmset(String key, Map&lt;String, Object&gt; map) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForHash().putAll(key, map);\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 192\n     * HashSet 并设置时间\n     * 193\n     *\n     * @param key  键\n     *             194\n     * @param map  对应多个键值\n     *             195\n     * @param time 时间(秒)\n     *             196\n     * @return true成功 false失败\n     * 197\n     *&#x2F;\n\n    public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForHash().putAll(key, map);\n\n            if (time &gt; 0) &#123;\n\n                expire(key, time);\n\n            &#125;\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 212\n     * 向一张hash表中放入数据,如果不存在将创建\n     * 213\n     *\n     * @param key   键\n     *              214\n     * @param item  项\n     *              215\n     * @param value 值\n     *              216\n     * @return true 成功 false失败\n     * 217\n     *&#x2F;\n\n    public boolean hset(String key, String item, Object value) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForHash().put(key, item, value);\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 229\n     * 向一张hash表中放入数据,如果不存在将创建\n     * 230\n     *\n     * @param key   键\n     *              231\n     * @param item  项\n     *              232\n     * @param value 值\n     *              233\n     * @param time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间\n     *              234\n     * @return true 成功 false失败\n     * 235\n     *&#x2F;\n\n    public boolean hset(String key, String item, Object value, long time) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForHash().put(key, item, value);\n\n            if (time &gt; 0) &#123;\n\n                expire(key, time);\n\n            &#125;\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 250\n     * 删除hash表中的值\n     * 251\n     *\n     * @param key  键 不能为null\n     *             252\n     * @param item 项 可以使多个 不能为null\n     *             253\n     *&#x2F;\n\n    public void hdel(String key, Object... item) &#123;\n\n        redisTemplate.opsForHash().delete(key, item);\n\n    &#125;\n\n    &#x2F;**\n     * 259\n     * 判断hash表中是否有该项的值\n     * 260\n     *\n     * @param key  键 不能为null\n     *             261\n     * @param item 项 不能为null\n     *             262\n     * @return true 存在 false不存在\n     * 263\n     *&#x2F;\n\n    public boolean hHasKey(String key, String item) &#123;\n\n        return redisTemplate.opsForHash().hasKey(key, item);\n\n    &#125;\n\n    &#x2F;**\n     * 269\n     * hash递增 如果不存在,就会创建一个 并把新增后的值返回\n     * 270\n     *\n     * @param key  键\n     *             271\n     * @param item 项\n     *             272\n     * @param by   要增加几(大于0)\n     *             273\n     * @return 274\n     *&#x2F;\n\n    public double hincr(String key, String item, double by) &#123;\n\n        return redisTemplate.opsForHash().increment(key, item, by);\n\n    &#125;\n\n    &#x2F;**\n     * 280\n     * hash递减\n     * 281\n     *\n     * @param key  键\n     *             282\n     * @param item 项\n     *             283\n     * @param by   要减少记(小于0)\n     *             284\n     * @return 285\n     *&#x2F;\n\n    public double hdecr(String key, String item, double by) &#123;\n\n        return redisTemplate.opsForHash().increment(key, item, -by);\n\n    &#125;\n\n    &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;set&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n    &#x2F;**\n     * 292\n     * 根据key获取Set中的所有值\n     * 293\n     *\n     * @param key 键\n     *            294\n     * @return 295\n     *&#x2F;\n\n    public Set&lt;Object&gt; sGet(String key) &#123;\n\n        try &#123;\n\n            return redisTemplate.opsForSet().members(key);\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return null;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 306\n     * 根据value从一个set中查询,是否存在\n     * 307\n     *\n     * @param key   键\n     *              308\n     * @param value 值\n     *              309\n     * @return true 存在 false不存在\n     * 310\n     *&#x2F;\n\n    public boolean sHasKey(String key, Object value) &#123;\n\n        try &#123;\n\n            return redisTemplate.opsForSet().isMember(key, value);\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 321\n     * 将数据放入set缓存\n     * 322\n     *\n     * @param key    键\n     *               323\n     * @param values 值 可以是多个\n     *               324\n     * @return 成功个数\n     * 325\n     *&#x2F;\n\n    public long sSet(String key, Object... values) &#123;\n\n        try &#123;\n\n            return redisTemplate.opsForSet().add(key, values);\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return 0;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 336\n     * 将set数据放入缓存\n     * 337\n     *\n     * @param key    键\n     *               338\n     * @param time   时间(秒)\n     *               339\n     * @param values 值 可以是多个\n     *               340\n     * @return 成功个数\n     * 341\n     *&#x2F;\n\n    public long sSetAndTime(String key, long time, Object... values) &#123;\n\n        try &#123;\n\n            Long count &#x3D; redisTemplate.opsForSet().add(key, values);\n\n            if (time &gt; 0)\n\n                expire(key, time);\n\n            return count;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return 0;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 355\n     * 获取set缓存的长度\n     * 356\n     *\n     * @param key 键\n     *            357\n     * @return 358\n     *&#x2F;\n\n    public long sGetSetSize(String key) &#123;\n\n        try &#123;\n\n            return redisTemplate.opsForSet().size(key);\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return 0;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 369\n     * 移除值为value的\n     * 370\n     *\n     * @param key    键\n     *               371\n     * @param values 值 可以是多个\n     *               372\n     * @return 移除的个数\n     * 373\n     *&#x2F;\n\n    public long setRemove(String key, Object... values) &#123;\n\n        try &#123;\n\n            Long count &#x3D; redisTemplate.opsForSet().remove(key, values);\n\n            return count;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return 0;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;list&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n    &#x2F;**\n     * 386\n     * 获取list缓存的内容\n     * 387\n     *\n     * @param key   键\n     *              388\n     * @param start 开始\n     *              389\n     * @param end   结束 0 到 -1代表所有值\n     *              390\n     * @return 391\n     *&#x2F;\n\n    public List&lt;Object&gt; lGet(String key, long start, long end) &#123;\n\n        try &#123;\n\n            return redisTemplate.opsForList().range(key, start, end);\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return null;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 402\n     * 获取list缓存的长度\n     * 403\n     *\n     * @param key 键\n     *            404\n     * @return 405\n     *&#x2F;\n\n    public long lGetListSize(String key) &#123;\n\n        try &#123;\n\n            return redisTemplate.opsForList().size(key);\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return 0;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 416\n     * 通过索引 获取list中的值\n     * 417\n     *\n     * @param key   键\n     *              418\n     * @param index 索引 index&gt;&#x3D;0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推\n     *              419\n     * @return 420\n     *&#x2F;\n\n    public Object lGetIndex(String key, long index) &#123;\n\n        try &#123;\n\n            return redisTemplate.opsForList().index(key, index);\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return null;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 431\n     * 将list放入缓存\n     * 432\n     *\n     * @param key   键\n     *              433\n     * @param value 值\n     *              434\n     * @paramtime  时间(秒)\n     *              435\n     * @return 436\n     *&#x2F;\n\n    public boolean lSet(String key, Object value) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForList().rightPush(key, value);\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 将list放入缓存\n     *\n     * @param key   键\n     * @param value 值\n     * @param time  时间(秒)\n     * @return\n     *&#x2F;\n\n    public boolean lSet(String key, Object value, long time) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForList().rightPush(key, value);\n\n            if (time &gt; 0)\n\n                expire(key, time);\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 467\n     * 将list放入缓存\n     * 468\n     *\n     * @param key   键\n     *              469\n     * @param value 值\n     *              470\n     * @paramtime  时间(秒)\n     *              471\n     * @return 472\n     *&#x2F;\n\n    public boolean lSet(String key, List&lt;Object&gt; value) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForList().rightPushAll(key, value);\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 484\n     * 将list放入缓存\n     * 485\n     * &lt;p&gt;\n     * 486\n     *\n     * @param key   键\n     *              487\n     * @param value 值\n     *              488\n     * @param time  时间(秒)\n     *              489\n     * @return 490\n     *&#x2F;\n\n    public boolean lSet(String key, List&lt;Object&gt; value, long time) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForList().rightPushAll(key, value);\n\n            if (time &gt; 0)\n\n                expire(key, time);\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 504\n     * 根据索引修改list中的某条数据\n     * 505\n     *\n     * @param key   键\n     *              506\n     * @param index 索引\n     *              507\n     * @param value 值\n     *              508\n     * @return 509\n     *&#x2F;\n\n    public boolean lUpdateIndex(String key, long index, Object value) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForList().set(key, index, value);\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    &#x2F;**\n     * 521\n     * 移除N个值为value\n     * 522\n     *\n     * @param key   键\n     *              523\n     * @param count 移除多少个\n     *              524\n     * @param value 值\n     *              525\n     * @return 移除的个数\n     * 526\n     *&#x2F;\n\n    public long lRemove(String key, long count, Object value) &#123;\n\n        try &#123;\n\n            Long remove &#x3D; redisTemplate.opsForList().remove(key, count, value);\n\n            return remove;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return 0;\n\n        &#125;\n\n    &#125;\n&#125;\n","slug":"Redis/4. Redis整合SpringBoot","date":"2021-10-20T14:49:24.000Z","categories_index":"Redis","tags_index":"Redis","author_index":"小益子"},{"id":"db7ea4437a64676d67da146e8befffea","title":"3. Jedis","content":"依赖\n&lt;dependency&gt;\n    &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.6.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n连接使用\npublic class Ping &#123;\n\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;1. new Jedis就建立连接\n        Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;, 6379);\n\n        System.out.println(jedis.ping());\n    &#125;\n\n&#125;\n\n==Jedis所有API都与Redis命令一模一样==\n事务\npublic class Transaction &#123;\n    public static void main(String[] args) &#123;\n        Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;, 6379);\n        System.out.println(jedis.flushDB());\n\n        Map&lt;String,String&gt; user &#x3D; new HashMap&lt;&gt;();\n        user.put(&quot;name&quot;,&quot;doubly&quot;);\n        user.put(&quot;hello&quot;,&quot;world&quot;);\n        String jsonStr &#x3D; JSONUtil.toJsonStr(user);\n\n        redis.clients.jedis.Transaction multi &#x3D; jedis.multi();\n        try &#123;\n            multi.set(&quot;user1&quot;, jsonStr);\n            multi.set(&quot;user2&quot;, jsonStr);\n            &#x2F;&#x2F;执行事务\n            multi.exec();\n        &#125;catch (Exception ex)&#123;\n            &#x2F;&#x2F; 放弃事务\n            multi.discard();\n            ex.printStackTrace();\n        &#125;finally &#123;\n            System.out.println(jedis.get(&quot;user1&quot;));\n            System.out.println(jedis.get(&quot;user2&quot;));\n\n            &#x2F;&#x2F;关闭连接\n            jedis.close();\n        &#125;\n    &#125;\n&#125;\n\n乐观锁\npublic class OptimisticLock &#123;\n\n    public static void main(String[] args) &#123;\n        Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;,6379);\n\n        System.out.println(jedis.flushDB());\n\n        jedis.set(&quot;money&quot;,&quot;100&quot;);\n        jedis.set(&quot;out&quot;,&quot;0&quot;);\n\n        jedis.watch(&quot;money&quot;);\n        Transaction multi &#x3D; jedis.multi();\n\n        try&#123;\n            multi.incrBy(&quot;out&quot;,10);\n            multi.decrBy(&quot;money&quot;,10);\n\n            int i &#x3D; 1&#x2F;0;\n\n            multi.exec();\n            System.out.println(&quot;事务执行完成&quot;);\n        &#125;catch (Exception ex)&#123;\n            System.out.println(&quot;放弃事务&quot;);\n            System.out.println(multi.discard());\n            ex.printStackTrace();\n        &#125;finally &#123;\n            System.out.println(jedis.get(&quot;money&quot;));\n            System.out.println(jedis.get(&quot;out&quot;));\n            jedis.close();\n        &#125;\n\n    &#125;\n&#125;","slug":"Redis/3. Jedis","date":"2021-10-20T14:49:23.000Z","categories_index":"Redis","tags_index":"Redis","author_index":"小益子"},{"id":"ec09385bf6fd223c8e8314533a8c47e9","title":"2. Redis事务","content":"\n\n\n\n\n\n\n\n\nRedis事务本质\n一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行\n\n\n\n\n\n\n\n\n\nRedis事务特点\n\n一次性\n顺序性\n排他性\n\n==Redis单条命令是保证原子性的，但是事务不保证原子性。==\n==Redis事务没有隔离级别的概念==\n事务执行命令\n127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379(TX)&gt; set k1 v1\nQUEUED\n127.0.0.1:6379(TX)&gt; set k2 v2\nQUEUED\n127.0.0.1:6379(TX)&gt; get k2\nQUEUED\n127.0.0.1:6379(TX)&gt; exec\n1) OK\n2) OK\n3) &quot;v2&quot;\n127.0.0.1:6379&gt; get k2\n&quot;v2&quot;\n\n放弃事务命令\n127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379(TX)&gt; set k5 v5\nQUEUED\n127.0.0.1:6379(TX)&gt; set k6 v6\nQUEUED\n127.0.0.1:6379(TX)&gt; DISCARD\nOK\n127.0.0.1:6379&gt; get k5\n(nil)\n\n\n\n\n\n\n\n\n\n\n编译型异常，所有的命令都不会执行\n127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379(TX)&gt; set k1 v1\nQUEUED\n# 命令使用错误\n127.0.0.1:6379(TX)&gt; set k2\n(error) ERR wrong number of arguments for &#39;set&#39; command\n127.0.0.1:6379(TX)&gt; set k3 v3\nQUEUED\n127.0.0.1:6379(TX)&gt; exec\n(error) EXECABORT Transaction discarded because of previous errors.\n# 所有命令都未执行\n127.0.0.1:6379&gt; keys *\n(empty array)\n\n\n\n\n\n\n\n\n\n\n运行时异常，错误的命令抛出异常，其他命令继续执行（没有原子性的表现）\n127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379(TX)&gt; set k1 v1\nQUEUED\n127.0.0.1:6379(TX)&gt; incr k1\nQUEUED\n127.0.0.1:6379(TX)&gt; set k2 v2\nQUEUED\n#运行时抛出错误异常，其他命令继续执行\n127.0.0.1:6379(TX)&gt; exec\n1) OK\n2) (error) ERR value is not an integer or out of range\n3) OK\n127.0.0.1:6379&gt; get k1\n&quot;v1&quot;\n127.0.0.1:6379&gt; get k2\n&quot;v2&quot;\n\n\n乐观锁实现悲观锁：\n认为什么时候都会出问题，无论干什么都会加锁\n乐观锁：认为什么时候都不会出问题，所以不会上锁。更新数据的时候去判断一下，在此期间是否有人更改了数据。\n\n获取version\n更新的时候比较version\n\n正常加锁执行\n127.0.0.1:6379&gt; set money 100\nOK\n127.0.0.1:6379&gt; set out 0\nOK\n127.0.0.1:6379&gt; watch money\nOK\n127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379(TX)&gt; decrby money 20\nQUEUED\n127.0.0.1:6379(TX)&gt; INCRBY out 20\nQUEUED\n127.0.0.1:6379(TX)&gt; exec\n1) (integer) 80\n2) (integer) 20\n\n加锁后，数据被篡改\n127.0.0.1:6379&gt; watch money\nOK\n127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379(TX)&gt; decrby money 10\nQUEUED\n127.0.0.1:6379(TX)&gt; incrby money 10\nQUEUED\n\n#另一线程此时修改了数据\n127.0.0.1:6379(TX)&gt; exec\n(nil)\n\n# 另一线程\n127.0.0.1:6379&gt; set money 1000\nOK\n127.0.0.1:6379&gt; get money \n&quot;1000&quot;","slug":"Redis/2. Redis事务","date":"2021-10-20T14:49:22.000Z","categories_index":"Redis","tags_index":"Redis","author_index":"小益子"},{"id":"75c57edf98300619b2ad759418e62fac","title":"1. Redis概述","content":"Redis概述Redis是什么?\nRedis(==Re==mote ==di==ctionary ==s==erver)，即远程字典服务。是一个开元的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多重语言的API。\nRedis能干嘛？\n\n内存存储、持久化，内存中是断电即失、所以说持久化很重要（RDB、AOF）\n效率高，可以用于高速缓存\n发布订阅系统\n地图信息分析\n计时器、计数器（浏览量…）\n…\n\n特性\n\n多样的数据类型\n持久化\n集群\n事务\n…\n\n安装\n下载，直接官网下载即可\ntar -zxvf解压下载的redis-*.tar.gz\nmake 命令执行安装\nmake install将redis安装到/usr/local/bin目录下\ncp redis.conf /usr/local/bin/doublyConfig，将redis的配置文件拷贝一份，后续使用修改该配置文件。方便出问题复原\nvim redis.conf，编辑配置文件，\\daemonize搜索daemonize，将值改为yes，表示以后台的方式启动\nredis-server doublyConfig/redis.conf，使用修改的配置文件启动redis\nredis-cli -h localhost -p 6379，使用redis客户端连接server。-h表示主机，-p表示端口\n客户端连接后，使用ping，返回PONG，表示连接成功；set name doubly设置键值对；get name获取键值对；\n\n基础知识Redis是单线程的（据说6.0的已经是多线程的了？）\nRedis是基于内存操作的，性能瓶颈已经不是CPU了，而是内存和网络带宽。\n为什么Redis单线程还这么快？\n\n多线程不一定就比单线程快，因为多线程要频繁的进行上下文切换，是非常耗时的。\n高性能服务器也不一定是多线程的。\nCPU &gt; 内存 &gt; 硬盘，Redis将所有的数据放在内存中。对于内存系统没有上下文切换，在一个CPU上完成。\n\nRedis五大基础类型\nString类型\nList类型（双向链表）\nSet类型（无序不重复集合）\nHash类型（相当于Map）：适合对象的存储\nZset类型（有序集合）\n\n三大特殊类型\nGeospatial类型（地理位置），基于Zset实现\nHyperLogLog类型，基于算法的基数（不重复的元素）统计的数据结构。0.81%的错误率，允许容错的情况下可以使用，只占用12KB的内存，统计效率高。\nBitMap类型，位图\n\n基础命令set name doubly , get name：设置、获取值\nexists name：判断是否存在\nexpire name 10：设置过期时间（秒）\nttl name：查看key剩余时间\nmove name 1：移动name到数据库1\n\n数据库命令(select,dbsize)\n\nRedis默认有16个数据库\n配置文件中的位置\n# Set the number of databases. The default database is DB 0, you can select\n# a different one on a per-connection basis using SELECT &lt;dbid&gt; where\n# dbid is a number between 0 and &#39;databases&#39;-1\ndatabases 16\n\n127.0.0.1:6379&gt; DBSIZE #查看数据大小\n(integer) 5\n127.0.0.1:6379&gt; select 1 #切换数据库\nOK\n127.0.0.1:6379[1]&gt; keys * #查看所有的key\n(empty array) \n\n\n清除数据库命令\n\nflushdb：清除当前数据库\nflushall：清除所有数据库\n\nString类型相关命令\n\nappend name aaa：追加字符串，如果key不存在，则创建key\nstrlen name：返回字符串长度\nincr views：自增1\ndecr views：自减1\nincrby views 10：自增步长\ndecrby views 5：自减步长\ngetrange name 3 6：截取字符串\nsetrange name 3 abcd：替换字符串\nsetex name doubly 30：set with expire，设置值并同时设置过期时间\nsetnx name doubly：set not exist，不存在则创建KV，存在则创建失败\nmset k1 v1 k2 v2 k3 v3，mget k1 k2 k3：批量设置获取\nmsetnx k1 v1 k4 v4：setnx的批量操作，原子操作，一个失败就全部失败\n设置对象，user:{id}:{field}#设置一个对象，redis允许设置user:&#123;id&#125;:&#123;field&#125;格式\nmset user:1:name doubly age 12\n#同时获取对象的name和age\nmget user:1:name age\ngetset name doubly：先获取，再设置。返回当前值，并设置新的值\n\n\nList类型相关命令\n\nlpush list v1：在list头部插入新元素，没有则创建\nrpush list v2：在list尾部（右）插入新元素\nlrange list 0 -1：获取列表一段范围的元素\nlpop list [2],rpop list：弹出list左/右侧的元素\nlindex list 2：查看list某个下标的元素\nllen list：查询list的长度\nlrem list 2 value：移除list中2个value\nltrim list 1 2：截取list[1-2]\nrpoplpush list newlist：弹出list最右侧的元素并插入到新的list中，最后返回元素\nlset list 0 newitem：更新list某个下标的元素，如果key不存在则报错，如果下标不存在也报错\nlinsert list before|after value test：在list中的value前|后插入新元素\n\n\n\n\nSet类型相关命令\n\nsadd myset doubly：向set集合中新增一个元素，可以不存在则新建\nsmembers myset：查看set集合中的所有元素\nsismember myset doubly：验证set集合中某个元素是否存在\nscard myset：返回set集合中的元素个数\nsrem myset doubly：移除set集合中的指定元素\nsrandmember myset：获取set集合中的一个随机元素\nspop myset：从set集合中随机删除一个元素\nsmove myset newset doubly：将元素从一个set集合移动到另一个set集合中\nsdiff myset newset：获取两个set集合的差集。只获取myset有而newset没有的元素\nsinter myset newset：获取两个set集合的交集\nsunion myset newset：获取两个set集合的并集\n\n\nHash类型相关命令\n\nhset，hget：设置获取hash\nhmset，hmget：批量设置，获取（hset，hget也可以批量，4.0以后官方启用hmset,hmget?）\nhgetall：获取所有的键值对\nhdel：删除某一个field\nhlen：获取hash长度\nhexists：判断field是否存在\nhkeys：获取hash所有的key\nkvals：获取hash所有的value\nhincrby，hdecrby：hash中field自增、自减\nhsetnx：当field不存在时设置值\n\n\nZset类型相关命令\n\nzadd：向zset中增加元素\nzrange,zrevrange：按照索引正序、倒序列出范围内的元素\nzrangebyscore,zrevrangebyscore：按照score正序、倒序列出范围内的元素\nzrem：移除zset中某一个元素\nzcard：统计zset长度\nzcount：统计某个score范围内的元素个数\n\n\nGeospatial类型相关命令（Zset命令全部适用）\n\ngeoadd：添加地理经纬度信息，经纬度有范围限制，超过则报错127.0.0.1:6379&gt; geoadd city 116.40 39.90 beijing\n(integer) 1\n127.0.0.1:6379&gt; geoadd city 121.47 31.23 shanghai\n(integer) 1\n127.0.0.1:6379&gt; geoadd city 106.50 29.53 chongqing\n(integer) 1\n127.0.0.1:6379&gt; geoadd city 114.05 22.53 shenzhen\n(integer) 1\n127.0.0.1:6379&gt; geoadd city 120.16 30.24 hangzhou\n(integer) 1\n127.0.0.1:6379&gt; geoadd city 108.96 34.26 xian\n(integer) 1\ngeopos：获取某个地方的地理位置127.0.0.1:6379&gt; geopos city beijing\n1) 1) &quot;116.39999896287918091&quot;\n   2) &quot;39.90000009167092543&quot;\n   \n127.0.0.1:6379&gt; geopos city beijing shenzhen\n1) 1) &quot;116.39999896287918091&quot;\n   2) &quot;39.90000009167092543&quot;\n2) 1) &quot;114.04999762773513794&quot;\n   2) &quot;22.52999956292396888&quot;\ngeodist：计算两地之间的距离127.0.0.1:6379&gt; geodist city beijing shenzhen\n&quot;1944681.9952&quot;\n\n#设置单位\n127.0.0.1:6379&gt; geodist city beijing shenzhen km\n&quot;1944.6820&quot;\n127.0.0.1:6379&gt; geodist city beijing shanghai km\n&quot;1067.3788&quot;\ngeoradius：查询某地范围内的地区127.0.0.1:6379&gt; GEORADIUS city 114.05 22.50 1000 km\n1) &quot;shenzhen&quot;\n127.0.0.1:6379&gt; GEORADIUS city 114.05 22.50 10000 km\n1) &quot;chongqing&quot;\n2) &quot;xian&quot;\n3) &quot;shenzhen&quot;\n4) &quot;hangzhou&quot;\n5) &quot;shanghai&quot;\n6) &quot;beijing&quot;\n\n# 带上经纬度信息\n127.0.0.1:6379&gt; GEORADIUS city 114.05 22.50 5000 km withcoord \n1) 1) &quot;chongqing&quot;\n   2) 1) &quot;106.49999767541885376&quot;\n      2) &quot;29.52999957900659211&quot;\n2) 1) &quot;xian&quot;\n   2) 1) &quot;108.96000176668167114&quot;\n      2) &quot;34.25999964418929977&quot;\n3) 1) &quot;shenzhen&quot;\n   2) 1) &quot;114.04999762773513794&quot;\n      2) &quot;22.52999956292396888&quot;\n4) 1) &quot;hangzhou&quot;\n   2) 1) &quot;120.1600000262260437&quot;\n      2) &quot;30.2400003229490224&quot;\n5) 1) &quot;shanghai&quot;\n   2) 1) &quot;121.47000163793563843&quot;\n      2) &quot;31.22999903975783553&quot;\n6) 1) &quot;beijing&quot;\n   2) 1) &quot;116.39999896287918091&quot;\n      2) &quot;39.90000009167092543&quot;\n      \n# 限定统计个数\n127.0.0.1:6379&gt; GEORADIUS city 114.05 22.50 5000 km withcoord count 1\n1) 1) &quot;shenzhen&quot;\n   2) 1) &quot;114.04999762773513794&quot;\n      2) &quot;22.52999956292396888&quot;\n127.0.0.1:6379&gt; GEORADIUS city 114.05 22.50 5000 km withcoord count 2\n1) 1) &quot;shenzhen&quot;\n   2) 1) &quot;114.04999762773513794&quot;\n      2) &quot;22.52999956292396888&quot;\n2) 1) &quot;hangzhou&quot;\n   2) 1) &quot;120.1600000262260437&quot;\n      2) &quot;30.2400003229490224&quot;\n      \n#带上距离\n127.0.0.1:6379&gt; GEORADIUS city 114.05 22.50 5000 km withcoord withdist count 2\n1) 1) &quot;shenzhen&quot;\n   2) &quot;3.3367&quot;\n   3) 1) &quot;114.04999762773513794&quot;\n      2) &quot;22.52999956292396888&quot;\n2) 1) &quot;hangzhou&quot;\n   2) &quot;1053.9526&quot;\n   3) 1) &quot;120.1600000262260437&quot;\n      2) &quot;30.2400003229490224&quot;\ngeoradiusbymember：使用存入redis的地区进行范围查找127.0.0.1:6379&gt; GEORADIUSBYMEMBER city chongqing 1000 km\n1) &quot;chongqing&quot;\n2) &quot;xian&quot;\n127.0.0.1:6379&gt; GEORADIUSBYMEMBER city chongqing 2000 km\n1) &quot;chongqing&quot;\n2) &quot;xian&quot;\n3) &quot;shenzhen&quot;\n4) &quot;hangzhou&quot;\n5) &quot;shanghai&quot;\n6) &quot;beijing&quot;\n127.0.0.1:6379&gt; GEORADIUSBYMEMBER city shanghai 1000 km\n1) &quot;hangzhou&quot;\n2) &quot;shanghai&quot;\ngeohash：返回地方经纬度的hash127.0.0.1:6379&gt; geohash city shenzhen\n1) &quot;ws105m2wv80&quot;\n127.0.0.1:6379&gt; geohash city shenzhen beijing\n1) &quot;ws105m2wv80&quot;\n2) &quot;wx4fbxxfke0&quot;\n\n\nHyperLogLog类型相关命令\n#pfadd 添加元素\n127.0.0.1:6379&gt; pfadd k1 a b d e f g h i\n(integer) 1\n#pfcount 统计基数个数\n127.0.0.1:6379&gt; pfcount k1\n(integer) 8\n127.0.0.1:6379&gt; pfadd k2 h i j k\n(integer) 1\n127.0.0.1:6379&gt; pfcount k2\n(integer) 4\n#pfmerge 合并两组元素到一个新的key中\n127.0.0.1:6379&gt; pfmerge k3 k1 k2\nOK\n127.0.0.1:6379&gt; pfcount k3\n(integer) 10\n#去除重复计数\n127.0.0.1:6379&gt; pfadd k4 a a a a b\n(integer) 1\n127.0.0.1:6379&gt; pfcount k4\n(integer) 2\nBitMap类型命令\n#添加一个元素\n127.0.0.1:6379&gt; setbit sign 0 1\n(integer) 0\n127.0.0.1:6379&gt; setbit sign 1 0\n(integer) 0\n127.0.0.1:6379&gt; setbit sign 2 0\n(integer) 0\n127.0.0.1:6379&gt; setbit sign 3 0\n(integer) 0\n#获取某一个元素\n127.0.0.1:6379&gt; getbit sign 2\n(integer) 0\n#统计值为1的数量\n127.0.0.1:6379&gt; bitcount sign\n(integer) 1\n\n","slug":"Redis/1. Redis简介、安装、基本知识","date":"2021-10-20T14:49:21.000Z","categories_index":"Redis","tags_index":"Redis","author_index":"小益子"},{"id":"2d40603b2799bf1e42342c1fcddf6a6a","title":"0. NoSQL概述","content":"NoSQL概述为什么要用NoSql？\n数据量如果太大，一个机器放不下\n数据的索引（如MySQL的B+Tree，300万一定要建立索引），一个机器内存也放不下\n访问量（读写混合），一个服务器承受不了\n\n用户的个人信息、社交网络、地理位置、用户自己产生的数据、用户日志等等爆发式增长！这个时候我们就需要使用NoSQL数据库，NoSQL数据库可以很好的处理以上问题。\nNoSQL特点\n方便扩展（数据之间没有关系，很好扩展）\n大数据量高性能（Redis 写8w/s 读11w/s），NoSQL的缓存记录级是一种细粒度的缓存，性能会比较高\n数据类型是多样型的（不需要事先设计数据库）\n传统的RDBMS和NoSQL\n\n\n\n\n\n\n\n\n传统RDBMS：\n\n结构化组织\nSQL\n数据和关系都存在单独的表中\n操作操作，数据定义语言\n严格的一致性\n基础的事物\n…\n\n\n\n\n\n\n\n\n\n\n\n\nNoSQL：\n\n不仅仅是数据\n没有固定的查询语言\n键值对存储，列存储，文档存储，图形数据库（社交关系）\n最终一致性\nCAP定理和BASE理论（BA、S、E)（异地多活）\n高性能、高可用、高扩展\n\nNoSQL四大分类KV键值对\n新浪：Redis\n美团：Redis + Tair\n阿里、百度：Redis + memecache\n\n文档型数据库（bson格式，和json一样）\nMongoDB（一般必须要掌握）\n是一个基于分布式文件存储的数据库，C++编写，主要用于处理大量的文档\nMongoDB是一个介于关系型数据库和非关系型数据中中间的产品！MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的！\n\n\nCouchDB\n\n列存储数据库\nHBase\n分布式文件系统\n\n图关系数据库\n\n\n\n\n\n\n\n\n他不是存图形，放的是关系，比如：朋友圈社交网络，广告推荐！\n\nNeo4j\nInfoGrid\n\n","slug":"Redis/0. NoSQL概述","date":"2021-10-20T14:49:20.000Z","categories_index":"Redis","tags_index":"Redis","author_index":"小益子"},{"id":"a648e8bf5173782b69842a75bd58b03c","title":"JVM相关理解","content":"Java虚拟机整体架构祥图\n类加载器\n虚拟机自带的加载器\n\n启动类（根、BootStrap）加载器\n\n扩展类加载器\n\n应用程序（系统）加载器\n\n\npublic static void main(String[] args) &#123;\n    ClassLoader classLoader &#x3D; OtherTest.class.getClassLoader();\n    &#x2F;&#x2F;AppClassLoader，应用程序加载器   实现java.lang.abstract\n    System.out.println(classLoader);\n    &#x2F;&#x2F;ExtClassLoader，扩展加载器   jre&#x2F;lib&#x2F;ext目录\n    System.out.println(classLoader.getParent());\n    &#x2F;&#x2F;null，不存在或者java无法获取   rt.jar\n    System.out.println(classLoader.getParent().getParent());\n&#125;\n\n双亲委派机制\n类加载器收到加载类的请求\n\n将这个请求向上委托父类加载器去完成，一直向上委托到根加载器\n\n根加载器检查是否能够加载此类，能加载就加载并结束；不能加载则抛出异常，通知子加载器进行加载\n\n重复步骤3\n\n\n示例代码：\npackage java.lang;\n&#x2F;*\n * @Description\n * @Author Doubly\n * @Date 2021&#x2F;10&#x2F;8\n *&#x2F;\npublic class String &#123;\n    public String toString()&#123;\n        return &quot;Hello&quot;;\n    &#125;\n    public static void main(String[] args) &#123;\n        String s &#x3D; new String();\n        System.out.println(s.toString());\n    &#125;\n&#125;\n\n运行结果：\n错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:\n   public static void main(String[] args)\n否则 JavaFX 应用程序类必须扩展javafx.application.Application           \n\n\n\n\n\n\n\n\n\n\n为了保证程序的安全，首先在AppClassLoader中找String，虽然已经找到，但是会继续在ExtClassLoader中找，最后在BootStrapClassLoader中找，找到rt.jar下面的String。所以不会家在我们自己写的String，会报没有main方法的错误。\nAppClassLoader -&gt; ExtClassLoader -&gt; BootstrapClassLoader（最终执行）\nnative关键字凡是带了native关键字的，说明Java的作用范围达不到了。会进入本地方法栈，通过本地方法接口（JNI）调用本地方法库。比如Object中的hashcode()方法，就是调用的本地方法。\n方法区静态变量、常量、类信息（构造方法、接口定义）、运行时的常量池存在方法区中，但是实例变量存在堆内存，和方法区无关\n栈8大基本类型+对象引用+实例的方法\n堆一个jvm只有一个堆内存，堆内存大小是可以调节的。\n默认分配的总内存是电脑的1/4，初始化的内存是电脑的1/64.\n代码示例：\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;返回虚拟机试图使用的最大内存\n        long maxMemory &#x3D; Runtime.getRuntime().maxMemory();\n        &#x2F;&#x2F;返回虚拟机初始化使用的总内存\n        long totalMemory &#x3D; Runtime.getRuntime().totalMemory();\n\n        System.out.println(&quot;max:&quot;+maxMemory + &quot;字节 &quot; + (maxMemory&#x2F;(double)1024&#x2F;1024) + &quot;MB&quot;);\n        System.out.println(&quot;max:&quot;+totalMemory + &quot;字节 &quot; + (totalMemory&#x2F;(double)1024&#x2F;1024) + &quot;MB&quot;);\n    &#125;\n&#125;\n\n结果：\nmax:1908932608字节 1820.5MB \nmax:128974848字节 123.0MB  \n\n​            \n堆内存细分三个区域：\n\n新生区（伊甸园区+幸存区0区+幸存区1区）（幸存区也叫from区与to区）\n\n养老区\n\n永久区\n\n\n新生区伊甸园区所有的对象都是在伊甸园区new出来的，伊甸园区满了会出发轻gc\n幸存区（0区+1区）gc触发后，还存在引用指向对象，对象就不会被回收，会进入幸存区。伊甸园区和幸存区都满了以后会今进行重gc。\n养老区幸存区满了之后，会进入养老区。一般99%的对象都会被清除，默认当一个对象经历15次后可以进入养老区。养老区满了之后就出现了OOM（Out Of Memory）。\n\n\n\n\n\n\n\n\n\n查看JVM堆中每个区的情况，可使用如下参数\nJVM参数：\n-Xms1024m -Xmx2048m -XX:+PrintGCDetails   \n\n输出：\nHeap\n PSYoungGen      total 305664K, used 20971K [0x0000000795580000, 0x00000007aaa80000, 0x00000007c0000000)\n  eden space 262144K, 8% used [0x0000000795580000,0x00000007969fafb8,0x00000007a5580000)\n  from space 43520K, 0% used [0x00000007a8000000,0x00000007a8000000,0x00000007aaa80000)\n  to   space 43520K, 0% used [0x00000007a5580000,0x00000007a5580000,0x00000007a8000000)\n ParOldGen       total 699392K, used 0K [0x0000000740000000, 0x000000076ab00000, 0x0000000795580000)\n  object space 699392K, 0% used [0x0000000740000000,0x0000000740000000,0x000000076ab00000)\n Metaspace       used 3104K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 339K, capacity 388K, committed 512K, reserved 1048576K\n           \n\nOOM之后如何排查问题？\n\n尝试扩大堆内存看结果\n\n分析内存，看一下哪个地方出现了问题（专业工具）\n\n\n内存快照分析工具：MAT（Eclipse最早继承）,Jprofiler\nMAT、JProfiler作用：\n\n分析Dump内存文件，快速定位内存泄漏\n\n获得堆中的数据\n\n获得大的对象\n\n\n如何获取JVM的dump文件？\n-Xms1m -Xmx1m -XX:+HeapDumpOnOutOfMemoryError\n\npublic class Test &#123;\n    &#x2F;&#x2F;-Xms1m -Xmx1m -XX:+HeapDumpOnOutOfMemoryError\n    public static void main(String[] args) &#123;\n        String str &#x3D; &quot;MyString&quot;;\n        while (true)&#123;\n            System.out.println(str);\n            str +&#x3D; new Random(999999999);\n        &#125;\n    &#125;\n&#125;    \n\n永久区/元空间\n\n\n\n\n\n\n\n\n逻辑上存在，物理上不存在。新生区+老年区=jvm使用的堆内存\n这个区域常驻内存的，用来存放jdk自身携带的Class对象、Interface元数据，存储的是Java运行的一些环境或类信息。这个区域不存在垃圾回收。关闭虚拟机就会释放这个区域的内存。\n历史：\n\nJdk1.6之前：永久代，常量池在方法区重\n\nJDK1.7：永久代，但是慢慢的退化了。去永久代，常量池在堆中\n\nJDK1.8以后：无永久代，常量池在元空间\n\n\n垃圾回收垃圾回收主要是在伊甸园区和养老区\n垃圾回收可分为两种：\n\n轻量级垃圾回收（轻gc）\n​    回收新生区和偶尔幸存区\n\n重量级垃圾回收（重gc、full gc）\n​    养老区满了，回收养老区\n\n\nJVM如何判断对象需要回收？\n\n引用计数法：每个对象引用次数做计数，每次被引用则计数+1，失去引用则-1。当计数为0的就清除。\n可达性算法：从GC Roots开始查找引用，能够被找到的说明被引用可达，其余的则引用不可达，需要清除。\n\n什么是GC Roots？\n\n虚拟机栈（栈帧中的本地变量表）中引用的对象\n方法区中类静态属性引用的对象\n方法区中常量引用的对象\n本地方法栈中JNI（即一般说的native方法）中引用的对象\n\ngc算法标记清除法：扫描对象，对活着的对象进行标记；对没有标记的对象进行清除\n​        优点：不需要额外空间\n​        缺点：标记和清除两次扫描，严重浪费时间；会产生内存碎片\n标记压缩：再对标记清除算法进行压缩整理\n​        再次扫描，向一段移动存活对对象，防止内存碎片的产生\n复制算法：新生区以及from区的存活对象复制到to区，to区永远是空的\n​        优点：没有内存碎片\n​        缺点：浪费空间，to区永远是空的\n​        最佳使用场景：对象存活度较低，新生区\n总结内存效率：复制算法&gt;标记清除&gt;标记压缩（时间复杂度）\n内存整齐度：复制算法=标记压缩&gt;标记清除\n内存利用率：标记压缩=标记清除&gt;复制算法\n\n\n\n\n\n\n\n\n\n没有最优的算法，只有最合适的算法。\n所以GC使用分代收集算法\n新生区：存活率较低，使用复制算法\n老年区：存活率较高，使用标记清除+标记压缩算法\n","slug":"Java/JVM相关理解","date":"2021-10-14T14:49:20.000Z","categories_index":"Java","tags_index":"JVM","author_index":"小益子"},{"id":"7c57be050b6f578d9f3dc30fc68278e1","title":"（已解决）IDEA Tomcat控制台中文乱码","content":"@TOC\n前言此篇博客记录自己解决win系统idea配置tomcat控制台输出乱码问题，所有的尝试我都会列举出来。有同样问题的朋友可以借鉴，我本人的解决方法为方法6，推荐优先尝试\n环境系统：windows 7IDEA：2020.1Tomcat：7.0.96\n问题描述：IDEA配置Tomcat后，启动在IDEA控制台的输出，中文为乱码\n尝试办法1.配置启动参数（未解决）-Dfile.encoding&#x3D;UTF-8\n\n\n2.修改IDEA配置，idea64.exe.vmoptions（未解决）安装目录\\JetBrains\\IntelliJ IDEA 2019.2.2\\bin\\idea64.exe.vmoptions与安装目录\\JetBrains\\IntelliJ IDEA 2019.2.2\\bin\\idea.exe.vmoptions增加一行\n-Dfile.encoding&#x3D;UTF-8\n\n\n同时也配置方法1\n3.修改Tomcat配置（未解决）Tomcat安装目录...\\apache-tomcat-8.5.57\\conf\\logging.properties，将所有的UTF-8修改为GBK，保存重启\n4.配置IDEA FileEncoding（未解决）从File-&gt;Setting ,设置File Encodings ,检查Default Encodings 是否是UTF-8\n5.配置JAVA_TOOL_OPTION（未解决）Name：JAVA_TOOL_OPTIONValue：-Dfile.encoding=UTF-8同时配置了方法1,2,4\n6.通过设置修改VmOption（解决）这个不同于方法2，这个是通过程序提供的方法修改参数，最终测试有效Help-&gt;Edit Custom VM Options...，添加一行-Dfile.encoding=UTF-8\n\n\n\n\n\n\n\n\n\n我这里同时配置了方法4，因为我认为统一编码格式挺好的，所以没有还原该配置，如果单独配置方法6不生效，可以尝试配置方法4\n\n总结先附上解决效果图（喜极而泣）\n通过最后成功的方法分析，修改的配置文件其实是在AppData目录下的配置文件\n","slug":"Java/（已解决）IDEA-Tomcat控制台中文乱码","date":"2021-08-19T06:24:30.000Z","categories_index":"Java,工具软件","tags_index":"IDEA","author_index":"小益子"},{"id":"3ec33308e179bb2c1ac2ac241962ed4f","title":"SpringCloud Nacos","content":"简介为什么叫Nacos\nNacos:Dynamic Naming and Configuration Service前四个字母分别为naming和Configuration的前两个字母，最后的s为service\n是什么？\n一个更易于构建云原生应用的动态服务发现，配置管理和服务管理平台。Nacos就是注册中心+配置中心的组合\n下载&amp;安装&amp;运行\n\n\n\n\n\n\n\n\n环境：Java8 + Maven环境\n下载：https://github.com/alibaba/nacos\n安装：直接解压缩\n运行：运行startup.cmd\n运行成功后访问 http://localhost:8848/nacos，帐号密码默认都是nacos\n服务注册中心服务提供者坐标：\n&lt;!--SpringCloud alibaba Nacos--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n配置：\nserver:\n  port: 9001\n\nspring:\n  application:\n    name: nacos-payment-provider\n  cloud:\n    nacos:\n      discovery:\n        server-addr: 127.0.0.1:8848\n\n启动类：\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class Payment9001 &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Payment9001.class,args);\n    &#125;\n&#125;\n\n服务：\n@RestController\n@RequestMapping(&quot;&#x2F;payment&quot;)\npublic class PaymentController &#123;\n\n    @Value(&quot;$&#123;server.port&#125;&quot;)\n    private String port;\n\n    @GetMapping(&quot;&#x2F;nacos&#x2F;&#123;id&#125;&quot;)\n    public String getPayment(@PathVariable(&quot;id&quot;) Integer id)&#123;\n        return &quot;nacos port:&quot;+port+&quot; id:&quot;+id;\n    &#125;\n&#125;\n\n服务消费者坐标：\n&lt;!--SpringCloud alibaba Nacos--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n配置：\nserver:\n  port: 83\nspring:\n  application:\n    name: nacos-consumer-order\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848\n\n#消费者将要去访问的微服务名称（注册成功进nacos的微服务提供者）\nservice-url:\n  nacos-user-service: http:&#x2F;&#x2F;nacos-payment-provider\n\n启动类：\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class Payment9001 &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Payment9001.class,args);\n    &#125;\n&#125;\n\n配置：\n@Configuration\npublic class Config &#123;\n\n    @Bean\n    @LoadBalanced       &#x2F;&#x2F;负载均衡根据服务名查找报错，需要添加此注解\n    public RestTemplate getRestTemplate()&#123;\n        return new RestTemplate();\n    &#125;\n\n&#125;\n\n服务：\n@Slf4j@RestController@RequestMapping(&quot;&#x2F;consumer&quot;)public class OrderNacosController &#123;    @Resource    private RestTemplate restTemplate;    @Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;)    private String serviceUrl;    @GetMapping(&quot;&#x2F;get&#x2F;&#123;id&#125;&quot;)    public String get(@PathVariable(&quot;id&quot;) String id)&#123;        return restTemplate.getForObject(serviceUrl+&quot;&#x2F;payment&#x2F;nacos&#x2F;&quot;+id,String.class);    &#125;&#125;\n\nCAP切换CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）\nC是所有借点在同一时间看到的数据是一致的；而A的定义是所有的请求都会收到响应。\n如何选择模式\n一般来说，如果不需要存储服务级别的信息且服务实例都是通过nacos-client注册，并且能够保持心跳上报，那么就可以选择AP模式。当前主流的服务如Spring Cloud和Dubbo服务，都是用于AP模式，AP模式为了服务的可用性而减弱了一致性，因此AP模式下只支持注册临时实例。\n如果需要在服务级别编辑或者存储配置信息，那么CP是必须，K8S服务和DNS服务则适用于CP模式。CP模式下则支持注册持久化实力，此时则是Raft协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。\n服务配置中心基础配置坐标：\n&lt;!--SpringCloud alibaba Nacos--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;\n\n配置：\nbootstrap:\nserver:  port: 3377spring:  application:    name: nacos-config-client  cloud:    nacos:      discovery:        server-addr: 192.168.31.66:8848      config:        server-addr: 192.168.31.66:8848        file-extension: yaml #指定配置文件格式\n\napplication:\nspring:  profiles:    active: dev\n\n\n\n\n\n\n\n\n\n\n为什么两个配置？\nNacos同SpringCloud-config一样，在项目初始化时，要保证先从配置中心进行配置拉取。拉取配置之后，才能保证项目的正常启动。\nSpringBoot中配置文件的加载时存在有线级顺序的，bootstrap优先级高于application\n在 Nacos Spring Cloud 中，dataId 的完整格式如下：\n$&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;\n\n\n\n\n\n\n\n\n\nprefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix来配置。\nspring.profiles.active 即为当前环境对应的 profile，详情可以参考 Spring Boot文档。 注意：当 spring.profiles.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 $&#123;prefix&#125;.$&#123;file-extension&#125;\nfile-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。\n","slug":"SpringCloud/SpringCloud-Nacos","date":"2021-08-19T06:23:05.000Z","categories_index":"Java,Spring系列","tags_index":"SpringCloud,Nacos","author_index":"小益子"},{"id":"69ac20172609268de83162921aca655c","title":"如何申请免费顶级域名","content":"前言freenom.com是一个提供免费域名申请的网站。目前提供了TK，ML，CF，GA，GQ免费的顶级域名。需要注意的是如果长时间不用，域名会被自动回收。\n步骤\n注册账号（尽量完善个人信息，不完善可能导致下单失败），可以参考一下信息填写\n\n查询域名的可用性，选择要注册的域名，点击完成进入购物车\n\n更改购买时长，最长可以选到12个月免费时长（快到期自动续费即可）\n\n\n\n在购物车中进行付款\n\n在阿里云（其他DNS解析同理）提供的免费DNS解析中进行配置。首先添加域名提示未使用阿里云解析\n\n进行解析设置，添加如下设置。记录类型为NS，记录值为上图中的DNS服务器\n\n在freenom中配置nameserver。首先进入域名管理界面\n\n点击管理选项\n\n选择NameServer\n\n选择Use custom nameservers，填入阿里云的DNS服务器，点击Change Nameservers\n\n返回阿里云域名管理，可以看到DNS服务器状态为正常\n\n在解析管理中添加解析，如图添加了云服务器的配置\n\n由于服务器中还未搭建网站等，直接通过ping命令访问。可以看到成功ping通，并且IP地址为我们服务器的地址。\n\n\n","slug":"如何申请免费顶级域名","date":"2021-08-18T15:37:12.000Z","categories_index":"互联网","tags_index":"免费域名","author_index":"小益子"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start创建一个新文章#以下命令功能相同，都在post下面创建了新文章\n$ hexo new &quot;My New Post&quot;\n$ hexo n &quot;My New Post&quot;\n$ hexo new post &quot;My New Post&quot;\n\nMore info: Writing\n启动服务#以下命令等价\n$ hexo server\n$ hexo s\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\n发布网站到远程$ hexo deploy\n$ hexo d\n\nMore info: Deployment\n","slug":"hello-world","date":"2020-08-18T15:37:12.000Z","categories_index":"博客搭建","tags_index":"Hexo","author_index":"小益子"}]