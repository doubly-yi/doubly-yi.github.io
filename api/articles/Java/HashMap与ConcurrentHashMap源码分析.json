{"title":"HashMap与ConcurrentHashMap源码分析","uid":"3689e206f36869899ed85f878a46311b","slug":"Java/HashMap与ConcurrentHashMap源码分析","date":"2022-01-03T22:49:09.000Z","updated":"2022-01-06T14:42:50.490Z","comments":true,"path":"api/articles/Java/HashMap与ConcurrentHashMap源码分析.json","keywords":null,"cover":"/images/default-cover2.jpg","content":"<h1 id=\"JDK-1-7中\"><a href=\"#JDK-1-7中\" class=\"headerlink\" title=\"JDK 1.7中\"></a>JDK 1.7中</h1><h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h2><p>以<code>数组+链表（单向链表）</code>的形式存储，以<code>Entry对象</code>存储</p>\n<p><img src=\"/post/Java/HashMap%E4%B8%8EConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220104070932257.png\" alt=\"image-20220104070932257\"></p>\n<p>HashMap中的Entry对象数组：</p>\n<p><img src=\"/post/Java/HashMap%E4%B8%8EConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220104070326213.png\" alt=\"Entry对象数组\"></p>\n<p>Entry对象中的next指针：</p>\n<p><img src=\"/post/Java/HashMap%E4%B8%8EConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220104070553553.png\" alt=\"image-20220104070553553\"></p>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><p>构造方法传入初始容量和加载因子，对HashMap中的属性加载因子和阈值进行赋值。调用空参则进行则会赋默认值。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16\nstatic final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public HashMap() &#123;\n    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public HashMap(int initialCapacity, float loadFactor) &#123;\n    &#x2F;&#x2F;判断初始容量是否小于0\n    if (initialCapacity &lt; 0)\n        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +\n                                           initialCapacity);\n    &#x2F;&#x2F;判断初始容量是否大于最大容量\n    if (initialCapacity &gt; MAXIMUM_CAPACITY)\n        initialCapacity &#x3D; MAXIMUM_CAPACITY;\n    &#x2F;&#x2F;判断加载因子\n    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +\n                                           loadFactor);\n\t&#x2F;&#x2F;赋值加载因子\n    this.loadFactor &#x3D; loadFactor;\n    &#x2F;&#x2F;初始容量赋值给阈值\n    threshold &#x3D; initialCapacity;\n    &#x2F;&#x2F;空方法，在LinkedHashMap中有用到\n    init();\n&#125;</code></pre>\n\n\n\n<h3 id=\"put方法\"><a href=\"#put方法\" class=\"headerlink\" title=\"put方法\"></a><code>put</code>方法</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public V put(K key, V value) &#123;\n    &#x2F;&#x2F;判断Entry数组是否为空\n    if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;\n        &#x2F;&#x2F;初始化数组\n        inflateTable(threshold);\n    &#125;\n    &#x2F;&#x2F;判断key是否为null，为null则放入数组第0个位置\n    if (key &#x3D;&#x3D; null)\n        return putForNullKey(value);\n    &#x2F;&#x2F;通过hash算法获取key的hash值\n    int hash &#x3D; hash(key);\n    &#x2F;&#x2F;通过hash值和数组长度计算在数组中的位置\n    int i &#x3D; indexFor(hash, table.length);\n    &#x2F;&#x2F;遍历数组下标i上的链表，如果有重复key，则替换并返回旧值\n    for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;\n        Object k;\n        if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123;\n            V oldValue &#x3D; e.value;\n            e.value &#x3D; value;\n            e.recordAccess(this);\n            return oldValue;\n        &#125;\n    &#125;\n\n  \t&#x2F;&#x2F;修改次数\n    modCount++;\n    &#x2F;&#x2F;没有重复则添加元素到链表中，采用头插法\n    addEntry(hash, key, value, i);\n    return null;\n&#125;</code></pre>\n\n\n\n<h4 id=\"inflateTable方法\"><a href=\"#inflateTable方法\" class=\"headerlink\" title=\"inflateTable方法\"></a><code>inflateTable</code>方法</h4><p>初始化Table的方法。</p>\n<ol>\n<li>首先将传入的阈值（也就是初始容量，构造方法中赋值给阈值）进行<code>inflateTable</code>方法计算，获得大于等于<code>toSize</code>的2的幂次方的数，即为table的容量。</li>\n<li>计算阈值为 加载因子 * 容量</li>\n<li>new一个容量为capacity的Entry数组</li>\n<li></li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void inflateTable(int toSize) &#123;\n    &#x2F;&#x2F; Find a power of 2 &gt;&#x3D; toSize\n    int capacity &#x3D; roundUpToPowerOf2(toSize);\n\n    threshold &#x3D; (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    table &#x3D; new Entry[capacity];\n    initHashSeedAsNeeded(capacity);\n&#125;</code></pre>\n\n\n\n<h5 id=\"roundUpToPowerOf2方法\"><a href=\"#roundUpToPowerOf2方法\" class=\"headerlink\" title=\"roundUpToPowerOf2方法\"></a><code>roundUpToPowerOf2</code>方法</h5><p>获得大于等于<code>number</code>的2的幂次方的数。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>为什么初始化数组一定要是2的幂次方数？</strong></p>\n<p>在<code>indexFor</code>方法中，会通过hash值和数组的长度来计算数组的下标。通过与操作<code>h &amp; (length-1)</code>时，则需要保证数组的长度为2的幂次方数，才能保证<code>(length-1)</code>得到一个二进制的低位全部为1的数。</p></blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static int roundUpToPowerOf2(int number) &#123;\n    &#x2F;&#x2F; assert number &gt;&#x3D; 0 : &quot;number must be non-negative&quot;;\n    return number &gt;&#x3D; MAXIMUM_CAPACITY\n            ? MAXIMUM_CAPACITY\n            : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;\n&#125;</code></pre>\n\n\n\n<h4 id=\"putForNullKey方法\"><a href=\"#putForNullKey方法\" class=\"headerlink\" title=\"putForNullKey方法\"></a><code>putForNullKey</code>方法</h4><p>遍历数组第0个位置上的链表，如果有重复则替换并返回旧值；没有重复则调用<code>addEntry</code>方法将元素添加在第0个位置的链表上。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>数组第0个位置上不一定只存了key为NULL的值，其他Key算出来的下标也可能为0</p></blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private V putForNullKey(V value) &#123;\n    for (Entry&lt;K,V&gt; e &#x3D; table[0]; e !&#x3D; null; e &#x3D; e.next) &#123;\n        if (e.key &#x3D;&#x3D; null) &#123;\n            V oldValue &#x3D; e.value;\n            e.value &#x3D; value;\n            e.recordAccess(this);\n            return oldValue;\n        &#125;\n    &#125;\n    modCount++;\n    addEntry(0, null, value, 0);\n    return null;\n&#125;</code></pre>\n\n\n\n<h4 id=\"hash方法\"><a href=\"#hash方法\" class=\"headerlink\" title=\"hash方法\"></a><code>hash</code>方法</h4><p>获取Hash值</p>\n<ol>\n<li>通过<code>hashCode</code>方法获取hash值</li>\n<li>与hash种子进行异或运算</li>\n<li>进行右移与异或运算</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>为什么要进行右移与异或？而不直接使用<code>hashCode</code>方法返回的值？</strong></p>\n<p>在indexFor方法中，使用hash值进行下标的计算时，只保留了hash值的低位，高位全部被舍弃，没有参与到下标的计算中来。如果这里直接使用hashCode方法，hashCode方法时可以被重写的，如果重写的方法散列性很差，那么发生hash碰撞的可能性比较大；而进行右移与异或操作后，影响hash值的改变，则可以让高位也参与到下标的计算中来。增加下标的随机性。</p></blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final int hash(Object k) &#123;\n    int h &#x3D; hashSeed;\n    if (0 !&#x3D; h &amp;&amp; k instanceof String) &#123;\n        return sun.misc.Hashing.stringHash32((String) k);\n    &#125;\n\n    h ^&#x3D; k.hashCode();\n\n    &#x2F;&#x2F; This function ensures that hashCodes that differ only by\n    &#x2F;&#x2F; constant multiples at each bit position have a bounded\n    &#x2F;&#x2F; number of collisions (approximately 8 at default load factor).\n    h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);\n    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);\n&#125;</code></pre>\n\n\n\n<h4 id=\"indexFor方法\"><a href=\"#indexFor方法\" class=\"headerlink\" title=\"indexFor方法\"></a><code>indexFor</code>方法</h4><p>通过hash值获取数组的下标</p>\n<p>下标要求：</p>\n<ol>\n<li>取值范围不能超过数组长度</li>\n<li>下标要平均分布在数组中</li>\n</ol>\n<p><img src=\"/post/Java/HashMap%E4%B8%8EConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220106064002892.png\" alt=\"image-20220106064002892\"></p>\n<p>数组长度为2的幂次方，-1则能得到除最高位为1的一个二进制数，与hash值进行与操作，则保留了hash值地位的所有数。由于只取了地位，所以不会超过数组长度；hash同时也是散列的，所以也满足平均分布的要求。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static int indexFor(int h, int length) &#123;\n    &#x2F;&#x2F; assert Integer.bitCount(length) &#x3D;&#x3D; 1 : &quot;length must be a non-zero power of 2&quot;;\n    return h &amp; (length-1);\n&#125;</code></pre>\n\n\n\n<h4 id=\"addEntry方法\"><a href=\"#addEntry方法\" class=\"headerlink\" title=\"addEntry方法\"></a><code>addEntry</code>方法</h4><p>添加元素到HashMap中来</p>\n<ol>\n<li>判断数组中存放的元素个数是否大于阈值，并且要存放的位置是否不为null，都满足则进行数组的扩容。扩容的容量为旧数组的2倍</li>\n<li>创建元素并使用头插法，将元素插入到链表中</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void addEntry(int hash, K key, V value, int bucketIndex) &#123;\n    if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;\n        resize(2 * table.length);\n        hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;\n        bucketIndex &#x3D; indexFor(hash, table.length);\n    &#125;\n\n    createEntry(hash, key, value, bucketIndex);\n&#125;</code></pre>\n\n\n\n<h5 id=\"resize方法\"><a href=\"#resize方法\" class=\"headerlink\" title=\"resize方法\"></a><code>resize</code>方法</h5><ol>\n<li>判断旧的容量是否达到最大容量，达到了则不进行扩容</li>\n<li>new 一个2倍容量的新数组</li>\n<li>transfer方法将数组元素从旧数组中转移</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void resize(int newCapacity) &#123;\n    Entry[] oldTable &#x3D; table;\n    int oldCapacity &#x3D; oldTable.length;\n    if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) &#123;\n        threshold &#x3D; Integer.MAX_VALUE;\n        return;\n    &#125;\n\n    Entry[] newTable &#x3D; new Entry[newCapacity];\n    transfer(newTable, initHashSeedAsNeeded(newCapacity));\n    table &#x3D; newTable;\n    threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n&#125;</code></pre>\n\n\n\n<h6 id=\"transfer方法\"><a href=\"#transfer方法\" class=\"headerlink\" title=\"transfer方法\"></a><code>transfer</code>方法</h6><p>双重循环移动数组元素，for循环遍历数组，while循环遍历链表。以头插法将元素插入到新的数组中。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>转移同样采用了indexFor计算数组的下标，在没有rehash的情况下，新的下标只会出现在原来的下标或者<code>i+oldTable.length</code>的位置</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>由于采用了头插法移动数组元素，新数组中的链表与原数组中的链表将会呈倒序</p></blockquote>\n<p>![image-20220106211345431](/Users/doubly/Library/Application Support/typora-user-images/image-20220106211345431.png)</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void transfer(Entry[] newTable, boolean rehash) &#123;\n    int newCapacity &#x3D; newTable.length;\n    for (Entry&lt;K,V&gt; e : table) &#123;\n        while(null !&#x3D; e) &#123;\n            Entry&lt;K,V&gt; next &#x3D; e.next;\n            if (rehash) &#123;\n                e.hash &#x3D; null &#x3D;&#x3D; e.key ? 0 : hash(e.key);\n            &#125;\n            int i &#x3D; indexFor(e.hash, newCapacity);\n          \t&#x2F;&#x2F;头插法  \n          \te.next &#x3D; newTable[i];\n            newTable[i] &#x3D; e;\n            e &#x3D; next;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h5 id=\"createEntry方法\"><a href=\"#createEntry方法\" class=\"headerlink\" title=\"createEntry方法\"></a><code>createEntry</code>方法</h5><p>使用头插法，将元素插入到数组下标为<code>bucketIndex</code>的链表中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void createEntry(int hash, K key, V value, int bucketIndex) &#123;\n    Entry&lt;K,V&gt; e &#x3D; table[bucketIndex];\n    table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, e);\n    size++;\n&#125;</code></pre>\n\n\n\n<h3 id=\"多线程下链表成环问题\"><a href=\"#多线程下链表成环问题\" class=\"headerlink\" title=\"多线程下链表成环问题\"></a>多线程下链表成环问题</h3><p>两个线程同时进行扩容，并且都已经进入了transfer方法，都执行道了图中的代码位置。</p>\n<p><img src=\"/post/Java/HashMap%E4%B8%8EConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220106213412277.png\" alt=\"image-20220106213412277\"></p>\n<ol start=\"0\">\n<li>准备执行的旧数组</li>\n</ol>\n<p><img src=\"/post/Java/HashMap%E4%B8%8EConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220106220126268.png\" alt=\"image-20220106220126268\"></p>\n<ol>\n<li>没有卡住的线程执行完代码</li>\n</ol>\n<p><img src=\"/post/Java/HashMap%E4%B8%8EConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220106220243877.png\" alt=\"image-20220106220243877\"></p>\n<ol start=\"2\">\n<li>卡住的线程从<code>next = e.next</code>后开始执行第一次循环</li>\n</ol>\n<p><img src=\"/post/Java/HashMap%E4%B8%8EConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220106222231788.png\" alt=\"image-20220106222231788\"></p>\n<ol start=\"3\">\n<li>执行完第二次循环</li>\n</ol>\n<p><img src=\"/post/Java/HashMap%E4%B8%8EConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220106222356633.png\" alt=\"image-20220106222356633\"></p>\n<ol start=\"4\">\n<li>执行第三次循环</li>\n</ol>\n<p><img src=\"/post/Java/HashMap%E4%B8%8EConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20220106222602950.png\" alt=\"image-20220106222602950\"></p>\n<ol start=\"5\">\n<li>假设有get方法来获取值，那么进行key比较的时候就会进入无限循环</li>\n</ol>\n<h1 id=\"JDK-1-8中\"><a href=\"#JDK-1-8中\" class=\"headerlink\" title=\"JDK 1.8中\"></a>JDK 1.8中</h1>","feature":true,"text":"JDK 1.7中HashMap以数组+链表（单向链表）的形式存储，以Entry对象存储 HashMap中的Entry对象数组： Entry对象中的next指针： 构造方法构造方法传入初始容量和加载因子，对HashMap中的属性加载因子和阈值进行赋值。调用空参则进行则会赋默认值。 ...","link":"","photos":[],"count_time":{"symbolsCount":"7.2k","symbolsTime":"7 mins."},"categories":[{"name":"Java","slug":"Java","count":10,"path":"api/categories/Java.json"}],"tags":[{"name":"HashMap","slug":"HashMap","count":1,"path":"api/tags/HashMap.json"},{"name":"ConcurrentHashMap","slug":"ConcurrentHashMap","count":1,"path":"api/tags/ConcurrentHashMap.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JDK-1-7%E4%B8%AD\"><span class=\"toc-text\">JDK 1.7中</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HashMap\"><span class=\"toc-text\">HashMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">构造方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#put%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">put方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#inflateTable%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">inflateTable方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#roundUpToPowerOf2%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">roundUpToPowerOf2方法</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#putForNullKey%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">putForNullKey方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#hash%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">hash方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#indexFor%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">indexFor方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#addEntry%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">addEntry方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#resize%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">resize方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#transfer%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">transfer方法</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#createEntry%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">createEntry方法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E9%93%BE%E8%A1%A8%E6%88%90%E7%8E%AF%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">多线程下链表成环问题</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JDK-1-8%E4%B8%AD\"><span class=\"toc-text\">JDK 1.8中</span></a></li></ol>","author":{"name":"小益子","slug":"blog-author","avatar":"/images/HeadPhoto.jpg","link":"/","description":"小益子的个人博客","socials":{"github":"https://github.com/doubly-yi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_18335837","juejin":"","customs":{"gitee":{"icon":"/icons/gitee2.svg","link":"https://gitee.com/doubly"},"bilibili":{"icon":"/icons/bilibili.svg","link":"https://space.bilibili.com/294694129"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"JUC","uid":"696c711dc425c21ecfe6691bc40887b7","slug":"Java/JUC","date":"2021-12-20T22:22:09.000Z","updated":"2021-12-29T23:03:27.628Z","comments":true,"path":"api/articles/Java/JUC.json","keywords":null,"cover":"/images/default-cover3.jpg","text":"什么是JUC？就是包，java.util.concurrent 线程和进程进程：一个程序，QQ.exe Music.exe，程序的集合 .jar 一个进程往往可以包含多个线程，至少包含一个！ Java默认有几个线程？2个，Main线程和GC线程 线程：开了一个进程Typora，写...","link":"","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"25 mins."},"categories":[{"name":"Java","slug":"Java","count":10,"path":"api/categories/Java.json"}],"tags":[{"name":"JUC","slug":"JUC","count":1,"path":"api/tags/JUC.json"}],"author":{"name":"小益子","slug":"blog-author","avatar":"/images/HeadPhoto.jpg","link":"/","description":"小益子的个人博客","socials":{"github":"https://github.com/doubly-yi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_18335837","juejin":"","customs":{"gitee":{"icon":"/icons/gitee2.svg","link":"https://gitee.com/doubly"},"bilibili":{"icon":"/icons/bilibili.svg","link":"https://space.bilibili.com/294694129"}}}},"feature":true}}