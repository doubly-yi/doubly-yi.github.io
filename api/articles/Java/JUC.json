{"title":"JUC","uid":"696c711dc425c21ecfe6691bc40887b7","slug":"Java/JUC","date":"2021-12-20T22:22:09.000Z","updated":"2021-12-29T23:03:27.628Z","comments":true,"path":"api/articles/Java/JUC.json","keywords":null,"cover":"/images/default-cover3.jpg","content":"<h1 id=\"什么是JUC？\"><a href=\"#什么是JUC？\" class=\"headerlink\" title=\"什么是JUC？\"></a>什么是JUC？</h1><p>就是包，java.util.concurrent</p>\n<h1 id=\"线程和进程\"><a href=\"#线程和进程\" class=\"headerlink\" title=\"线程和进程\"></a>线程和进程</h1><p><strong>进程</strong>：一个程序，QQ.exe Music.exe，程序的集合 .jar</p>\n<p>一个进程往往可以包含多个线程，至少包含一个！</p>\n<h2 id=\"Java默认有几个线程？\"><a href=\"#Java默认有几个线程？\" class=\"headerlink\" title=\"Java默认有几个线程？\"></a>Java默认有几个线程？</h2><p>2个，Main线程和GC线程</p>\n<p><strong>线程</strong>：开了一个进程Typora，写字、自动保存是线程负责的</p>\n<p>对Java而言 ：Thread、Runnable、Callable</p>\n<h2 id=\"Java真的可以开启线程吗？\"><a href=\"#Java真的可以开启线程吗？\" class=\"headerlink\" title=\"Java真的可以开启线程吗？\"></a>Java真的可以开启线程吗？</h2><p>不可以，只能通过本地方法调用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public synchronized void start() &#123;\n    &#x2F;**\n     * This method is not invoked for the main method thread or &quot;system&quot;\n     * group threads created&#x2F;set up by the VM. Any new functionality added\n     * to this method in the future may have to also be added to the VM.\n     *\n     * A zero status value corresponds to state &quot;NEW&quot;.\n     *&#x2F;\n    if (threadStatus !&#x3D; 0)\n        throw new IllegalThreadStateException();\n\n    &#x2F;* Notify the group that this thread is about to be started\n     * so that it can be added to the group&#39;s list of threads\n     * and the group&#39;s unstarted count can be decremented. *&#x2F;\n    group.add(this);\n\n    boolean started &#x3D; false;\n    try &#123;\n        start0();\n        started &#x3D; true;\n    &#125; finally &#123;\n        try &#123;\n            if (!started) &#123;\n                group.threadStartFailed(this);\n            &#125;\n        &#125; catch (Throwable ignore) &#123;\n            &#x2F;* do nothing. If start0 threw a Throwable then\n              it will be passed up the call stack *&#x2F;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;本地方法，底层的C++，Java无法直接操作\nprivate native void start0();\n</code></pre>\n\n\n\n<h2 id=\"并发、并行\"><a href=\"#并发、并行\" class=\"headerlink\" title=\"并发、并行\"></a>并发、并行</h2><p>并发：CPU一核，通过快速交替模拟出来多条线程同时运行，其实每次只有一条线程运行。</p>\n<p>并行：CPU多核，多个线程可以同时执行；线程池</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;获取CPU的核数\n        &#x2F;&#x2F; CPU密集型，IO密集型\n        System.out.println(Runtime.getRuntime().availableProcessors());\n    &#125;\n&#125;\n</code></pre>\n\n<p>并发编程的本质：充分利用CPU资源</p>\n<h2 id=\"线程的几种状态\"><a href=\"#线程的几种状态\" class=\"headerlink\" title=\"线程的几种状态\"></a>线程的几种状态</h2><p>一般来说：创建-&gt;就绪-&gt;运行-&gt;阻塞-&gt;死亡</p>\n<p>源码中：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public enum State &#123;\n    &#x2F;&#x2F; 创建\n    NEW,\n\n    &#x2F;&#x2F; 运行\n    RUNNABLE,\n\n    &#x2F;&#x2F; 阻塞\n    BLOCKED,\n\n    &#x2F;&#x2F; 等待，一直等下去\n    WAITING,\n\n    &#x2F;&#x2F; 超时等待，超时后不再等\n    TIMED_WAITING,\n\n    &#x2F;&#x2F; 终止\n    TERMINATED;\n&#125;</code></pre>\n\n\n\n<h2 id=\"wait和sleep的区别\"><a href=\"#wait和sleep的区别\" class=\"headerlink\" title=\"wait和sleep的区别\"></a>wait和sleep的区别</h2><ol>\n<li>来自不同的类</li>\n</ol>\n<p>wait -&gt; Object</p>\n<p>sleep -&gt; Thread</p>\n<ol start=\"2\">\n<li>关于锁的释放</li>\n</ol>\n<p>wait会释放锁，sleep不会释放锁，抱着锁睡觉！</p>\n<ol start=\"3\">\n<li>使用的范围不同</li>\n</ol>\n<p>wait：必须在同步代码块中</p>\n<p>sleep：可以在任何地方睡</p>\n<ol start=\"4\">\n<li>是否需要捕获异常</li>\n</ol>\n<p><del>wait不需要捕获异常，sleep必须要捕获异常</del></p>\n<h2 id=\"notify与notifyAll、signal与signalAll的区别\"><a href=\"#notify与notifyAll、signal与signalAll的区别\" class=\"headerlink\" title=\"notify与notifyAll、signal与signalAll的区别\"></a>notify与notifyAll、signal与signalAll的区别</h2><p><strong>notify与notifyAll的区别</strong></p>\n<p>notify是从等待池中随机唤醒一个线程，而notifyAll是唤醒所有线程</p>\n<p><strong>signal和signalAll的区别</strong></p>\n<p>signal是从等待队列中唤醒第一个线程，而signalAll是signal的循环，唤醒所有线程</p>\n<h1 id=\"Lock锁\"><a href=\"#Lock锁\" class=\"headerlink\" title=\"Lock锁\"></a>Lock锁</h1><h2 id=\"传统锁Synchronized\"><a href=\"#传统锁Synchronized\" class=\"headerlink\" title=\"传统锁Synchronized\"></a>传统锁Synchronized</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SaleTicket &#123;\n    public static void main(String[] args) &#123;\n        Ticket ticket &#x3D; new Ticket();\n        new Thread(()-&gt;&#123;ticket.sale();&#125;,&quot;A&quot;).start();\n        new Thread(ticket::sale,&quot;B&quot;).start();\n        new Thread(ticket::sale,&quot;C&quot;).start();\n    &#125;\n&#125;\n\nclass Ticket&#123;\n    &#x2F;&#x2F;票的数量\n    private int num &#x3D; 50;\n\n    public synchronized void sale()&#123;\n        while (num &gt; 0) &#123;\n            System.out.println(Thread.currentThread().getName() + &quot;卖出了第&quot; + num-- + &quot;张票，剩余：&quot; + num);\n            try &#123;\n                TimeUnit.MILLISECONDS.sleep(100);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"Lock接口\"><a href=\"#Lock接口\" class=\"headerlink\" title=\"Lock接口\"></a>Lock接口</h2><p>所有已知实现类</p>\n<ul>\n<li><p>ReentrantLock，可重入锁（常用）</p>\n<ul>\n<li>公平锁：十分公平，先来后到</li>\n<li><strong>非公平锁：十分不公平，可以插队（默认）</strong></li>\n</ul>\n<p><img src=\"/post/Java/JUC/image-20211222064125393.png\" alt=\"image-20211222064125393\"></p>\n</li>\n<li><p>ReentrantReadWriteLock.ReadLock，读锁</p>\n</li>\n<li><p>ReentrantReadWriteLock.WriteLock，写锁</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SaleTicketWithLock &#123;\n    public static void main(String[] args) &#123;\n        Ticket2 ticket &#x3D; new Ticket2();\n        new Thread(()-&gt;&#123;ticket.sale();&#125;,&quot;A&quot;).start();\n        new Thread(ticket::sale,&quot;B&quot;).start();\n        new Thread(ticket::sale,&quot;C&quot;).start();\n    &#125;\n&#125;\n\n&#x2F;**\n * Lock三部曲\n * 1. new ReentrantLock();\n * 2. 加锁，lock.lock();\n * 3. 释放锁，lock.unlock();\n *&#x2F;\nclass Ticket2&#123;\n    &#x2F;&#x2F;票的数量\n    private int num &#x3D; 50;\n\n    &#x2F;&#x2F;定义锁\n    Lock lock &#x3D; new ReentrantLock();\n\n    public void sale()&#123;\n        lock.lock();\n        try &#123;\n            while (num &gt; 0) &#123;\n                System.out.println(Thread.currentThread().getName() + &quot;卖出了第&quot; + num-- + &quot;张票，剩余：&quot; + num);\n                try &#123;\n                    TimeUnit.MILLISECONDS.sleep(100);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"Synchronized与Lock的区别\"><a href=\"#Synchronized与Lock的区别\" class=\"headerlink\" title=\"Synchronized与Lock的区别\"></a>Synchronized与Lock的区别</h2><ol>\n<li>Synchronized是一个Java内置的<strong>关键字</strong>，Lock是一个<strong>Java类</strong></li>\n<li>Synchronized无法判断获取锁的状态，Lock可以判断是否获取到了锁</li>\n<li>Synchronized会自动释放锁，Lock必须要手动释放锁。如果不释放锁，会出现死锁</li>\n<li>Synchronized，如果线程1获取了锁并阻塞，线程2会一直等待；Lock锁就不一定会等下去<code>lock.tryLock()</code></li>\n<li>Synchronized可重入锁，不可以中断的，非公平；Lock可重入锁，可以判断 锁，默认非公平（可以自己设置）</li>\n<li>Synchronized适合锁少量的代码同步问题，Lock适合锁大量的同步代码</li>\n</ol>\n<h1 id=\"生产者和消费者问题\"><a href=\"#生产者和消费者问题\" class=\"headerlink\" title=\"生产者和消费者问题\"></a>生产者和消费者问题</h1><h2 id=\"Synchronized版\"><a href=\"#Synchronized版\" class=\"headerlink\" title=\"Synchronized版\"></a>Synchronized版</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package top.doubly;\n\npublic class ProducerAndConsumer &#123;\n    public static void main(String[] args) &#123;\n        Data data &#x3D; new Data();\n        new Thread(()-&gt;&#123;\n            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                data.increment();\n            &#125;\n        &#125;,&quot;A&quot;).start();\n        new Thread(()-&gt;&#123;\n            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                data.decrement();\n            &#125;\n        &#125;,&quot;B&quot;).start();\n    &#125;\n\n&#125;\n\n\nclass Data&#123;\n    private int num &#x3D; 0;\n\n    &#x2F;**\n     * 生产者消费者问题步骤\n     * 1. 判断等待\n     * 2. 业务\n     * 3. 通知\n     *&#x2F;\n    public synchronized void increment()&#123;\n        if(num !&#x3D; 0)&#123;\n            try &#123;\n                this.wait();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        num +&#x3D; 1;\n        System.out.println(Thread.currentThread().getName() + &quot;&#x3D;&gt;&quot; + num);\n        this.notifyAll();\n    &#125;\n\n    &#x2F;**\n     * 生产者消费者问题步骤\n     * 1. 判断等待\n     * 2. 业务\n     * 3. 通知\n     *&#x2F;\n    public synchronized void decrement()&#123;\n        if(num &#x3D;&#x3D; 0)&#123;\n            try &#123;\n                this.wait();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        num -&#x3D; 1;\n        System.out.println(Thread.currentThread().getName() + &quot;&#x3D;&gt;&quot; + num);\n        this.notifyAll();\n    &#125;\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>问题存在，A B C D四个线程时，会出现虚假唤醒</p></blockquote>\n<p><img src=\"/post/Java/JUC/image-20211223063815860.png\" alt=\"image-20211223063815860\"></p>\n<p>解决办法：<strong>if改为while</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package top.doubly;\n\npublic class ProducerAndConsumer &#123;\n    public static void main(String[] args) &#123;\n        Data data &#x3D; new Data();\n        new Thread(()-&gt;&#123;\n            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                data.increment();\n            &#125;\n        &#125;,&quot;A&quot;).start();\n        new Thread(()-&gt;&#123;\n            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                data.decrement();\n            &#125;\n        &#125;,&quot;B&quot;).start();new Thread(()-&gt;&#123;\n            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                data.increment();\n            &#125;\n        &#125;,&quot;C&quot;).start();\n        new Thread(()-&gt;&#123;\n            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                data.decrement();\n            &#125;\n        &#125;,&quot;D&quot;).start();\n\n    &#125;\n\n&#125;\n\n\nclass Data&#123;\n    private int num &#x3D; 0;\n\n    &#x2F;**\n     * 生产者消费者问题步骤\n     * 1. 判断等待\n     * 2. 业务\n     * 3. 通知\n     *&#x2F;\n    public synchronized void increment()&#123;\n        &#x2F;&#x2F;System.out.println(Thread.currentThread().getName()+&quot;进入方法&quot;);\n        while (num !&#x3D; 0)&#123;\n            try &#123;\n                &#x2F;&#x2F;System.out.println(Thread.currentThread().getName()+&quot;进入等待&quot;);\n                this.wait();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        num +&#x3D; 1;\n        System.out.println(Thread.currentThread().getName() + &quot;&#x3D;&gt;&quot; + num);\n        this.notifyAll();\n    &#125;\n\n    &#x2F;**\n     * 生产者消费者问题步骤\n     * 1. 判断等待\n     * 2. 业务\n     * 3. 通知\n     *&#x2F;\n    public synchronized void decrement()&#123;\n        &#x2F;&#x2F;System.out.println(Thread.currentThread().getName()+&quot;进入方法&quot;);\n        while (num &#x3D;&#x3D; 0)&#123;\n            try &#123;\n                &#x2F;&#x2F;System.out.println(Thread.currentThread().getName()+&quot;进入等待&quot;);\n                this.wait();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        num -&#x3D; 1;\n        System.out.println(Thread.currentThread().getName() + &quot;&#x3D;&gt;&quot; + num);\n        this.notifyAll();\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"JUC版\"><a href=\"#JUC版\" class=\"headerlink\" title=\"JUC版\"></a>JUC版</h2><p>使用await和signal方法代替了Object的监视器方法（wait,notify,notiryAll）</p>\n<p><img src=\"/post/Java/JUC/image-20211223070551339.png\" alt=\"image-20211223070551339\"></p>\n<p>代码实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package top.doubly;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class ProducerAndConsumerWithJUC &#123;\n    public static void main(String[] args) &#123;\n        Data2 data &#x3D; new Data2();\n        new Thread(()-&gt;&#123;\n            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                data.increment();\n            &#125;\n        &#125;,&quot;A&quot;).start();\n        new Thread(()-&gt;&#123;\n            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                data.decrement();\n            &#125;\n        &#125;,&quot;B&quot;).start();new Thread(()-&gt;&#123;\n            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                data.increment();\n            &#125;\n        &#125;,&quot;C&quot;).start();\n        new Thread(()-&gt;&#123;\n            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                data.decrement();\n            &#125;\n        &#125;,&quot;D&quot;).start();\n\n    &#125;\n\n&#125;\n\n\nclass Data2&#123;\n    private int num &#x3D; 0;\n\n    private Lock lock &#x3D; new ReentrantLock(false);\n    private Condition condition &#x3D; lock.newCondition();\n    &#x2F;**\n     * 生产者消费者问题步骤\n     * 1. 判断等待\n     * 2. 业务\n     * 3. 通知\n     *&#x2F;\n    public void increment()&#123;\n        lock.lock();\n        try &#123;\n            while (num !&#x3D; 0) &#123;\n                try &#123;\n                    condition.await();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            num +&#x3D; 1;\n            System.out.println(Thread.currentThread().getName() + &quot;&#x3D;&gt;&quot; + num);\n            condition.signalAll();\n        &#125;finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 生产者消费者问题步骤\n     * 1. 判断等待\n     * 2. 业务\n     * 3. 通知\n     *&#x2F;\n    public void decrement()&#123;\n        lock.lock();\n        try &#123;\n            while (num &#x3D;&#x3D; 0) &#123;\n                try &#123;\n                    condition.await();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            num -&#x3D; 1;\n            System.out.println(Thread.currentThread().getName() + &quot;&#x3D;&gt;&quot; + num);\n            condition.signalAll();\n        &#125;finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>执行结果，虽然num结果是0和1交替执行，但A,B,C,D四个线程乱序执行</p>\n<p><img src=\"/post/Java/JUC/image-20211224062724514.png\" alt=\"image-20211224062724514\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>任何一个新的技术，绝对不是仅仅只是覆盖了原来的技术，一定会有优势和补充</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> <strong>Condition可以精准的通知和唤醒线程，实现有序的执行A,B,C,D线程</strong></p></blockquote>\n<p>改进：可以new多个Condition区分不同状态</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Data2&#123;\n    private int num &#x3D; 0;\n\n    private Lock lock &#x3D; new ReentrantLock(false);\n    private Condition isZero1 &#x3D; lock.newCondition();\n    private Condition isZero2 &#x3D; lock.newCondition();\n    private Condition notZero1 &#x3D; lock.newCondition();\n    private Condition notZero2 &#x3D; lock.newCondition();\n    &#x2F;&#x2F;private Condition condition &#x3D; lock.newCondition();\n    &#x2F;**\n     * 生产者消费者问题步骤\n     * 1. 判断等待\n     * 2. 业务\n     * 3. 通知\n     *&#x2F;\n    public void increment()&#123;\n        lock.lock();\n        try &#123;\n            String threadName &#x3D; Thread.currentThread().getName();\n            if (num !&#x3D; 0) &#123;\n                try &#123;\n                    &#x2F;&#x2F;condition.await();\n                    if(&quot;A&quot;.equals(threadName)) &#123;\n                        notZero1.await();\n                    &#125;else if(&quot;C&quot;.equals(threadName))&#123;\n                        notZero2.await();\n                    &#125;\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            num +&#x3D; 1;\n            System.out.println(threadName + &quot;&#x3D;&gt;&quot; + num);\n            if (&quot;A&quot;.equals(threadName)) &#123;\n                isZero1.signalAll();\n            &#125; else if(&quot;C&quot;.equals(threadName))&#123;\n                isZero2.signalAll();\n            &#125;\n            &#x2F;&#x2F;condition.signalAll();\n        &#125;finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 生产者消费者问题步骤\n     * 1. 判断等待\n     * 2. 业务\n     * 3. 通知\n     *&#x2F;\n    public void decrement()&#123;\n        lock.lock();\n        try &#123;\n            String threadName &#x3D; Thread.currentThread().getName();\n            while (num &#x3D;&#x3D; 0) &#123;\n                try &#123;\n                    &#x2F;&#x2F;condition.await();\n                    if(&quot;B&quot;.equals(threadName))&#123;\n                        isZero1.await();\n                    &#125;else if(&quot;D&quot;.equals(threadName))&#123;\n                        isZero2.await();\n                    &#125;\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            num -&#x3D; 1;\n            System.out.println(threadName + &quot;&#x3D;&gt;&quot; + num);\n            &#x2F;&#x2F;condition.signalAll();\n            if(&quot;B&quot;.equals(threadName))&#123;\n                notZero2.signalAll();\n            &#125;else if(&quot;D&quot;.equals(threadName))&#123;\n                notZero1.signalAll();\n            &#125;\n        &#125;finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>执行结果，A,B,C,D顺序依次执行</p>\n<p><img src=\"/post/Java/JUC/image-20211224064129596.png\" alt=\"image-20211224064129596\"></p>\n<h1 id=\"8锁现象\"><a href=\"#8锁现象\" class=\"headerlink\" title=\"8锁现象\"></a>8锁现象</h1><ol>\n<li><strong>标准情况下，两个线程先打印发短信还是打电话？</strong></li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test1 &#123;\n    public static void main(String[] args) &#123;\n        Phone phone &#x3D; new Phone();\n\n        new Thread(phone::sendSms).start();\n\n        try &#123;\n            TimeUnit.SECONDS.sleep(1);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        new Thread(phone::call).start();\n    &#125;\n&#125;\n\nclass Phone&#123;\n    public synchronized void sendSms()&#123;\n        System.out.println(&quot;发短信&quot;);\n    &#125;\n\n    public synchronized void call()&#123;\n        System.out.println(&quot;打电话&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>结果：发短信，打电话</p>\n<ol start=\"2\">\n<li><strong>发短信线程先休息4s钟，是发短信还是打电话？</strong></li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test1 &#123;\n    public static void main(String[] args) &#123;\n        Phone phone &#x3D; new Phone();\n\n        new Thread(phone::sendSms).start();\n\n        try &#123;\n            TimeUnit.SECONDS.sleep(1);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        new Thread(phone::call).start();\n    &#125;\n&#125;\n\nclass Phone&#123;\n    public synchronized void sendSms() &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(4);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(&quot;发短信&quot;);\n    &#125;\n\n    public synchronized void call()&#123;\n        System.out.println(&quot;打电话&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>结果：发短信、打电话</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>synchronized锁的对象是方法的调用者，即phone对象！</p>\n<p>两个方法用的是同一个锁，所以谁先拿到谁先执行！</p></blockquote>\n<ol start=\"3\">\n<li><strong>Phone增加了一个普通方法后，线程B调用hello方法，是先执行发短信还是hello？</strong></li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test2 &#123;\n    public static void main(String[] args) &#123;\n        Phone2 phone &#x3D; new Phone2();\n\n        new Thread(phone::sendSms,&quot;A&quot;).start();\n\n        try &#123;\n            TimeUnit.SECONDS.sleep(1);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        new Thread(phone::hello,&quot;B&quot;).start();\n    &#125;\n&#125;\n\nclass Phone2&#123;\n    public synchronized void sendSms() &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(4);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(&quot;发短信&quot;);\n    &#125;\n\n    public synchronized void call()&#123;\n        System.out.println(&quot;打电话&quot;);\n    &#125;\n\n    &#x2F;&#x2F;这里没有锁\n    public void hello()&#123;\n        System.out.println(&quot;hello&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>结果：hello，发短信</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>hello是普通方法，没有加锁，所以不需要获取锁就可以立即执行</p></blockquote>\n<ol start=\"4\">\n<li><strong>两个线程使用两个对象执行两个同步方法，先执行发短信还是先打电话？</strong></li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test2 &#123;\n    public static void main(String[] args) &#123;\n        Phone2 phone1 &#x3D; new Phone2();\n        Phone2 phone2 &#x3D; new Phone2();\n\n        new Thread(phone1::sendSms,&quot;A&quot;).start();\n\n        try &#123;\n            TimeUnit.SECONDS.sleep(1);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        new Thread(phone2::call,&quot;B&quot;).start();\n    &#125;\n&#125;\n\nclass Phone2&#123;\n    public synchronized void sendSms() &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(4);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(&quot;发短信&quot;);\n    &#125;\n\n    public synchronized void call()&#123;\n        System.out.println(&quot;打电话&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>结果：打电话、发短信</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里是两个不同的调用对象，A线程锁的是phone1，B线程锁的是phone2</p></blockquote>\n<ol start=\"5\">\n<li><strong>增加两个静态方法，AB线程调用两个静态方法，是先发短信还是先打电话？</strong></li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test3 &#123;\n    public static void main(String[] args) &#123;\n        Phone3 phone &#x3D; new Phone3();\n\n        new Thread(()-&gt;&#123;\n            phone.sendSms();\n        &#125;,&quot;A&quot;).start();\n\n        try &#123;\n            TimeUnit.SECONDS.sleep(1);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        new Thread(()-&gt;&#123;\n            phone.call();\n        &#125;,&quot;B&quot;).start();\n    &#125;\n&#125;\n\nclass Phone3&#123;\n    public static synchronized void sendSms() &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(4);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(&quot;发短信&quot;);\n    &#125;\n\n    public static synchronized void call()&#123;\n        System.out.println(&quot;打电话&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>结果：发短信</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>静态同步方法锁的是class对象，class对象全局唯一，所以两个线程竞争同一把锁</p></blockquote>\n<ol start=\"6\">\n<li><strong>定义两个对象，分别调用两个静态方法，是先发短信还是先打电话？</strong></li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test4 &#123;\n    public static void main(String[] args) &#123;\n        Phone3 phone1 &#x3D; new Phone3();\n        Phone3 phone2 &#x3D; new Phone3();\n\n        new Thread(()-&gt;&#123;\n            phone1.sendSms();\n        &#125;,&quot;A&quot;).start();\n\n        try &#123;\n            TimeUnit.SECONDS.sleep(1);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        new Thread(()-&gt;&#123;\n            phone2.call();\n        &#125;,&quot;B&quot;).start();\n    &#125;\n&#125;\n\nclass Phone4&#123;\n    public static synchronized void sendSms() &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(4);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(&quot;发短信&quot;);\n    &#125;\n\n    public static synchronized void call()&#123;\n        System.out.println(&quot;打电话&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>结果：发短信、打电话</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>两个对象的静态同步方法锁的都是Phone的class对象</p></blockquote>\n<ol start=\"7\">\n<li><strong>1个静态同步方法，1个普通同步方法，1个对象，先打印发短信还是打电话？</strong></li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test4 &#123;\n    public static void main(String[] args) &#123;\n        Phone4 phone1 &#x3D; new Phone4();\n\n        new Thread(()-&gt;&#123;\n            phone1.sendSms();\n        &#125;,&quot;A&quot;).start();\n\n        try &#123;\n            TimeUnit.SECONDS.sleep(1);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        new Thread(()-&gt;&#123;\n            phone1.call();\n        &#125;,&quot;B&quot;).start();\n    &#125;\n&#125;\n\nclass Phone4&#123;\n    public static synchronized void sendSms() &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(4);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(&quot;发短信&quot;);\n    &#125;\n\n    public synchronized void call()&#123;\n        System.out.println(&quot;打电话&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>结果：打电话、发短信</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>静态同步方法锁的是class对象，普通同步方法锁的是phone对象，两个线程没有竞争</p></blockquote>\n<ol start=\"8\">\n<li><strong>1个静态同步方法，1个普通同步方法，2个对象，先打印发短信还是打电话？</strong></li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test4 &#123;\n    public static void main(String[] args) &#123;\n        Phone4 phone1 &#x3D; new Phone4();\n        Phone4 phone2 &#x3D; new Phone4();\n\n        new Thread(()-&gt;&#123;\n            phone1.sendSms();\n        &#125;,&quot;A&quot;).start();\n\n        try &#123;\n            TimeUnit.SECONDS.sleep(1);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        new Thread(()-&gt;&#123;\n            phone2.call();\n        &#125;,&quot;B&quot;).start();\n    &#125;\n&#125;\n\nclass Phone4&#123;\n    public static synchronized void sendSms() &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(4);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(&quot;发短信&quot;);\n    &#125;\n\n    public synchronized void call()&#123;\n        System.out.println(&quot;打电话&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>结果：打电话、发短信</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>静态同步方法锁的是class对象，普通同步方法锁的是phone对象，两个线程没有竞争</p></blockquote>\n<p>总结：new this锁的是具体对象，static class锁的是类对象</p>\n<h1 id=\"集合类不安全\"><a href=\"#集合类不安全\" class=\"headerlink\" title=\"集合类不安全\"></a>集合类不安全</h1><h2 id=\"List不安全\"><a href=\"#List不安全\" class=\"headerlink\" title=\"List不安全\"></a>List不安全</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ListTest &#123;\n    public static void main(String[] args) &#123;\n        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            new Thread(()-&gt;&#123;\n                list.add(UUID.randomUUID().toString().substring(0,5));\n                System.out.println(list);\n            &#125;,String.valueOf(i)).start();\n        &#125;\n\n    &#125;\n&#125;</code></pre>\n\n<p>运行结果，发生异常</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[0aa0d, fd313, 170eb]\n[0aa0d, fd313, 170eb, 109dc, 8edff, 53ab7, 15bca]\n[0aa0d, fd313, 170eb, 109dc, 8edff, 53ab7]\n[0aa0d, fd313, 170eb, 109dc, 8edff]\n[0aa0d, fd313, 170eb, 109dc]\n[0aa0d, fd313, 170eb]\n[0aa0d, fd313, 170eb]\n[0aa0d, fd313, 170eb, 109dc, 8edff, 53ab7, 15bca, 4322d, d1ca0, 838ac]\n[0aa0d, fd313, 170eb, 109dc, 8edff, 53ab7, 15bca, 4322d]\nException in thread &quot;9&quot; java.util.ConcurrentModificationException\n\tat java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)\n\tat java.util.ArrayList$Itr.next(ArrayList.java:859)\n\tat java.util.AbstractCollection.toString(AbstractCollection.java:461)\n\tat java.lang.String.valueOf(String.java:2994)\n\tat java.io.PrintStream.println(PrintStream.java:821)\n\tat top.doubly.unsafe.ListTest.lambda$main$0(ListTest.java:15)\n\tat java.lang.Thread.run(Thread.java:748)\n\nProcess finished with exit code 0</code></pre>\n\n<p><code>java.util.ConcurrentModificationException</code> 并发修改异常</p>\n<p><strong>解决方案</strong>：</p>\n<ol>\n<li><code>List&lt;String&gt; list = new Vector&lt;&gt;();</code>，Vector从1.0就有，ArrayList从1.2，</li>\n<li><code>List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</code></li>\n<li><code>List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</code></li>\n</ol>\n<p><strong>CopyOnWriteArrayList</strong></p>\n<p>写入时复制，简称COW。计算机程序设计领域的一种优化策略；</p>\n<h2 id=\"Set不安全\"><a href=\"#Set不安全\" class=\"headerlink\" title=\"Set不安全\"></a>Set不安全</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SetTest &#123;\n    public static void main(String[] args) &#123;\n        Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();\n\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            new Thread(()-&gt;&#123;\n                set.add(UUID.randomUUID().toString());\n                System.out.println(set);\n            &#125;).start();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>运行时发生异常</p>\n<p><img src=\"/post/Java/JUC/image-20211229065009372.png\" alt=\"image-20211229065009372\"></p>\n<p><strong>解决方案</strong>：</p>\n<ol>\n<li><code>Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</code></li>\n<li><code>Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</code></li>\n</ol>\n<p><strong>HashSet底层</strong></p>\n<p>HashSet底层就是一个HashMap，看源码</p>\n<p><img src=\"/post/Java/JUC/image-20211229065603461.png\" alt=\"image-20211229065603461\"></p>\n<p><img src=\"/post/Java/JUC/image-20211229065642172.png\" alt=\"image-20211229065642172\"></p>\n<p><img src=\"/post/Java/JUC/image-20211229065704906.png\" alt=\"image-20211229065704906\"></p>\n<h2 id=\"Map不安全\"><a href=\"#Map不安全\" class=\"headerlink\" title=\"Map不安全\"></a>Map不安全</h2><h3 id=\"HashMap基础回顾\"><a href=\"#HashMap基础回顾\" class=\"headerlink\" title=\"HashMap基础回顾\"></a>HashMap基础回顾</h3><p><img src=\"/post/Java/JUC/image-20211229070320956.png\" alt=\"image-20211229070320956\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MapTest &#123;\n    public static void main(String[] args) &#123;\n        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            new Thread(()-&gt;&#123;\n                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString());\n                System.out.println(map);\n            &#125;).start();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>运行同样出现异常</p>\n<p><img src=\"/post/Java/JUC/image-20211229070504728.png\" alt=\"image-20211229070504728\"></p>\n<p>解决方法：</p>\n<ol>\n<li><code>Map&lt;String,Object&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</code></li>\n<li><code>Map&lt;String,Object&gt; map = new ConcurrentHashMap&lt;&gt;();</code></li>\n</ol>\n<h3 id=\"ConcurrentHashMap原理\"><a href=\"#ConcurrentHashMap原理\" class=\"headerlink\" title=\"ConcurrentHashMap原理\"></a>ConcurrentHashMap原理</h3><h1 id=\"Callable\"><a href=\"#Callable\" class=\"headerlink\" title=\"Callable\"></a>Callable</h1><ol>\n<li>可以有返回值</li>\n<li>可以抛出异常</li>\n<li>方法不同，run()/call()</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CallableTest &#123;\n\n    public static void main(String[] args) &#123;\n        MyCallable myCallable &#x3D; new MyCallable();\n        FutureTask&lt;String&gt; futureTask &#x3D; new FutureTask&lt;&gt;(myCallable);\n        new Thread(futureTask).start();\n        String s &#x3D; null;\n        try &#123;\n            s &#x3D; futureTask.get();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; catch (ExecutionException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(&quot;获取&quot;+s);\n    &#125;\n\n&#125;\n\nclass MyCallable implements Callable&lt;String&gt;&#123;\n\n    @Override\n    public String call() throws Exception &#123;\n        System.out.println(&quot;call()&quot;);\n        return &quot;test&quot;;\n    &#125;\n&#125;</code></pre>\n\n<p>注意：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>futureTask.get()方法会产生阻塞，一般会将get方法写在最后，活着使用异步通信</p></blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    MyCallable myCallable &#x3D; new MyCallable();\n    FutureTask&lt;String&gt; futureTask &#x3D; new FutureTask&lt;&gt;(myCallable);\n    new Thread(futureTask,&quot;A&quot;).start();\n    new Thread(futureTask,&quot;B&quot;).start();\n    String s &#x3D; futureTask.get();\n    System.out.println(&quot;获取&quot;+s);\n&#125;</code></pre>\n\n<p>![image-20211230065157470](/Users/doubly/Library/Application Support/typora-user-images/image-20211230065157470.png)</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>两个线程执行一个callable，只会被执行一次，结果会被缓存</p></blockquote>\n<h1 id=\"常用的辅助类\"><a href=\"#常用的辅助类\" class=\"headerlink\" title=\"常用的辅助类\"></a>常用的辅助类</h1><h2 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h2><p>![image-20211230065536145](/Users/doubly/Library/Application Support/typora-user-images/image-20211230065536145.png)</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CountDownLatchDemo &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        &#x2F;&#x2F;总数是6\n        CountDownLatch countDownLatch &#x3D; new CountDownLatch(6);\n\n        for (int i &#x3D; 0; i &lt; 6; i++) &#123;\n            new Thread(()-&gt;&#123;\n                System.out.println(Thread.currentThread().getName()+&quot; Go out&quot;);\n                &#x2F;&#x2F;数量-1\n                countDownLatch.countDown();\n            &#125;,String.valueOf(i)).start();\n        &#125;\n\n        countDownLatch.await();\n\n        System.out.println(&quot;Close Door&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>原理：</p>\n<p><code>countDownLatch.countDown();</code>进行数量-1</p>\n<p><code>countDownLatch.await();</code>等待计数器归零，然后再向下执行</p>\n<p>每次有线程调用<code>countDown()</code>数量-1，假设计数器变为0，<code>countDownLatch.await();</code>就会被唤醒</p>\n","feature":true,"text":"什么是JUC？就是包，java.util.concurrent 线程和进程进程：一个程序，QQ.exe Music.exe，程序的集合 .jar 一个进程往往可以包含多个线程，至少包含一个！ Java默认有几个线程？2个，Main线程和GC线程 线程：开了一个进程Typora，写...","link":"","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"25 mins."},"categories":[{"name":"Java","slug":"Java","count":10,"path":"api/categories/Java.json"}],"tags":[{"name":"JUC","slug":"JUC","count":1,"path":"api/tags/JUC.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFJUC%EF%BC%9F\"><span class=\"toc-text\">什么是JUC？</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">线程和进程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java%E9%BB%98%E8%AE%A4%E6%9C%89%E5%87%A0%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">Java默认有几个线程？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java%E7%9C%9F%E7%9A%84%E5%8F%AF%E4%BB%A5%E5%BC%80%E5%90%AF%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">Java真的可以开启线程吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E5%8F%91%E3%80%81%E5%B9%B6%E8%A1%8C\"><span class=\"toc-text\">并发、并行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">线程的几种状态</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#wait%E5%92%8Csleep%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">wait和sleep的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#notify%E4%B8%8EnotifyAll%E3%80%81signal%E4%B8%8EsignalAll%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">notify与notifyAll、signal与signalAll的区别</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Lock%E9%94%81\"><span class=\"toc-text\">Lock锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E7%BB%9F%E9%94%81Synchronized\"><span class=\"toc-text\">传统锁Synchronized</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Lock%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">Lock接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Synchronized%E4%B8%8ELock%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Synchronized与Lock的区别</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">生产者和消费者问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Synchronized%E7%89%88\"><span class=\"toc-text\">Synchronized版</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JUC%E7%89%88\"><span class=\"toc-text\">JUC版</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#8%E9%94%81%E7%8E%B0%E8%B1%A1\"><span class=\"toc-text\">8锁现象</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%8D%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">集合类不安全</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#List%E4%B8%8D%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">List不安全</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Set%E4%B8%8D%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">Set不安全</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Map%E4%B8%8D%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">Map不安全</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HashMap%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE\"><span class=\"toc-text\">HashMap基础回顾</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ConcurrentHashMap%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">ConcurrentHashMap原理</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Callable\"><span class=\"toc-text\">Callable</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BE%85%E5%8A%A9%E7%B1%BB\"><span class=\"toc-text\">常用的辅助类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CountDownLatch\"><span class=\"toc-text\">CountDownLatch</span></a></li></ol></li></ol>","author":{"name":"小益子","slug":"blog-author","avatar":"/images/HeadPhoto.jpg","link":"/","description":"小益子的个人博客","socials":{"github":"https://github.com/doubly-yi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_18335837","juejin":"","customs":{"gitee":{"icon":"/icons/gitee2.svg","link":"https://gitee.com/doubly"},"bilibili":{"icon":"/icons/bilibili.svg","link":"https://space.bilibili.com/294694129"}}}},"mapped":true,"prev_post":{"title":"HashMap与ConcurrentHashMap源码分析","uid":"3689e206f36869899ed85f878a46311b","slug":"Java/HashMap与ConcurrentHashMap源码分析","date":"2022-01-03T22:49:09.000Z","updated":"2022-01-06T14:42:50.490Z","comments":true,"path":"api/articles/Java/HashMap与ConcurrentHashMap源码分析.json","keywords":null,"cover":"/images/default-cover2.jpg","text":"JDK 1.7中HashMap以数组+链表（单向链表）的形式存储，以Entry对象存储 HashMap中的Entry对象数组： Entry对象中的next指针： 构造方法构造方法传入初始容量和加载因子，对HashMap中的属性加载因子和阈值进行赋值。调用空参则进行则会赋默认值。 ...","link":"","photos":[],"count_time":{"symbolsCount":"7.2k","symbolsTime":"7 mins."},"categories":[{"name":"Java","slug":"Java","count":10,"path":"api/categories/Java.json"}],"tags":[{"name":"HashMap","slug":"HashMap","count":1,"path":"api/tags/HashMap.json"},{"name":"ConcurrentHashMap","slug":"ConcurrentHashMap","count":1,"path":"api/tags/ConcurrentHashMap.json"}],"author":{"name":"小益子","slug":"blog-author","avatar":"/images/HeadPhoto.jpg","link":"/","description":"小益子的个人博客","socials":{"github":"https://github.com/doubly-yi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_18335837","juejin":"","customs":{"gitee":{"icon":"/icons/gitee2.svg","link":"https://gitee.com/doubly"},"bilibili":{"icon":"/icons/bilibili.svg","link":"https://space.bilibili.com/294694129"}}}},"feature":true},"next_post":{"title":"Lambda表达式","uid":"32a652994e7e566383677d79f35d7c59","slug":"Java/Lambda表达式","date":"2021-12-14T22:25:04.000Z","updated":"2021-12-14T23:01:08.295Z","comments":true,"path":"api/articles/Java/Lambda表达式.json","keywords":null,"cover":"/images/default-cover2.jpg","text":"在jdk8中，为了简化代码，减少不必要的代码，推出了Lambda表达式 变化过程演示 定义函数式接口 函数式接口：只有一个方法的接口，成为函数式接口。 只有函数式接口，才可以用Lambda实现 interface ILike&#123; public void print(); ...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"Java","slug":"Java","count":10,"path":"api/categories/Java.json"}],"tags":[{"name":"Lambda","slug":"Lambda","count":1,"path":"api/tags/Lambda.json"}],"author":{"name":"小益子","slug":"blog-author","avatar":"/images/HeadPhoto.jpg","link":"/","description":"小益子的个人博客","socials":{"github":"https://github.com/doubly-yi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_18335837","juejin":"","customs":{"gitee":{"icon":"/icons/gitee2.svg","link":"https://gitee.com/doubly"},"bilibili":{"icon":"/icons/bilibili.svg","link":"https://space.bilibili.com/294694129"}}}},"feature":true}}