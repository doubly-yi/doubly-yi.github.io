[{"title":"HashMap与ConcurrentHashMap源码分析","uid":"3689e206f36869899ed85f878a46311b","slug":"Java/HashMap与ConcurrentHashMap源码分析","date":"2022-01-03T22:49:09.000Z","updated":"2022-01-06T14:42:50.490Z","comments":true,"path":"api/articles/Java/HashMap与ConcurrentHashMap源码分析.json","cover":"/images/default-cover2.jpg","text":"JDK 1.7中HashMap以数组+链表（单向链表）的形式存储，以Entry对象存储 HashMap中的Entry对象数组： Entry对象中的next指针： 构造方法构造方法传入初始容量和加载因子，对HashMap中的属性加载因子和阈值进行赋值。调用空参则进行则会赋默认值。 ...","link":"","photos":[],"count_time":{"symbolsCount":"7.2k","symbolsTime":"7 mins."},"categories":[{"name":"Java","slug":"Java","count":10,"path":"api/categories/Java.json"}],"tags":[{"name":"HashMap","slug":"HashMap","count":1,"path":"api/tags/HashMap.json"},{"name":"ConcurrentHashMap","slug":"ConcurrentHashMap","count":1,"path":"api/tags/ConcurrentHashMap.json"}],"author":{"name":"小益子","slug":"blog-author","avatar":"/images/HeadPhoto.jpg","link":"/","description":"小益子的个人博客","socials":{"github":"https://github.com/doubly-yi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_18335837","juejin":"","customs":{"gitee":{"icon":"/icons/gitee2.svg","link":"https://gitee.com/doubly"},"bilibili":{"icon":"/icons/bilibili.svg","link":"https://space.bilibili.com/294694129"}}}},"feature":true},{"title":"JUC","uid":"696c711dc425c21ecfe6691bc40887b7","slug":"Java/JUC","date":"2021-12-20T22:22:09.000Z","updated":"2021-12-29T23:03:27.628Z","comments":true,"path":"api/articles/Java/JUC.json","cover":"/images/default-cover3.jpg","text":"什么是JUC？就是包，java.util.concurrent 线程和进程进程：一个程序，QQ.exe Music.exe，程序的集合 .jar 一个进程往往可以包含多个线程，至少包含一个！ Java默认有几个线程？2个，Main线程和GC线程 线程：开了一个进程Typora，写...","link":"","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"25 mins."},"categories":[{"name":"Java","slug":"Java","count":10,"path":"api/categories/Java.json"}],"tags":[{"name":"JUC","slug":"JUC","count":1,"path":"api/tags/JUC.json"}],"author":{"name":"小益子","slug":"blog-author","avatar":"/images/HeadPhoto.jpg","link":"/","description":"小益子的个人博客","socials":{"github":"https://github.com/doubly-yi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_18335837","juejin":"","customs":{"gitee":{"icon":"/icons/gitee2.svg","link":"https://gitee.com/doubly"},"bilibili":{"icon":"/icons/bilibili.svg","link":"https://space.bilibili.com/294694129"}}}},"feature":true},{"title":"Lambda表达式","uid":"32a652994e7e566383677d79f35d7c59","slug":"Java/Lambda表达式","date":"2021-12-14T22:25:04.000Z","updated":"2021-12-14T23:01:08.295Z","comments":true,"path":"api/articles/Java/Lambda表达式.json","cover":"/images/default-cover2.jpg","text":"在jdk8中，为了简化代码，减少不必要的代码，推出了Lambda表达式 变化过程演示 定义函数式接口 函数式接口：只有一个方法的接口，成为函数式接口。 只有函数式接口，才可以用Lambda实现 interface ILike&#123; public void print(); ...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"Java","slug":"Java","count":10,"path":"api/categories/Java.json"}],"tags":[{"name":"Lambda","slug":"Lambda","count":1,"path":"api/tags/Lambda.json"}],"author":{"name":"小益子","slug":"blog-author","avatar":"/images/HeadPhoto.jpg","link":"/","description":"小益子的个人博客","socials":{"github":"https://github.com/doubly-yi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_18335837","juejin":"","customs":{"gitee":{"icon":"/icons/gitee2.svg","link":"https://gitee.com/doubly"},"bilibili":{"icon":"/icons/bilibili.svg","link":"https://space.bilibili.com/294694129"}}}},"feature":true}]