[{"title":"HashMap与ConcurrentHashMap源码分析","url":"/post/Java/HashMap%E4%B8%8EConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html","content":"JDK 1.7中HashMap以数组+链表（单向链表）的形式存储，以Entry对象存储\n\nHashMap中的Entry对象数组：\n\nEntry对象中的next指针：\n\n构造方法构造方法传入初始容量和加载因子，对HashMap中的属性加载因子和阈值进行赋值。调用空参则进行则会赋默认值。\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\npublic HashMap() &#123;\n    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);\n&#125;\n\npublic HashMap(int initialCapacity, float loadFactor) &#123;\n    //判断初始容量是否小于0\n    if (initialCapacity &lt; 0)\n        throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                           initialCapacity);\n    //判断初始容量是否大于最大容量\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    //判断加载因子\n    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                           loadFactor);\n\t//赋值加载因子\n    this.loadFactor = loadFactor;\n    //初始容量赋值给阈值\n    threshold = initialCapacity;\n    //空方法，在LinkedHashMap中有用到\n    init();\n&#125;\n\n\n\nput方法\nmodCount\npublic static void main(String[] args) &#123;\n        Map&lt;String,String> hashMap = new HashMap();\n        hashMap.put(\"1\",\"1\");\n        hashMap.put(\"2\",\"2\");\n\n        for (String key : hashMap.keySet()) &#123;\n            if(key.equals(\"2\"))&#123;\n                hashMap.remove(key);\n            &#125;\n        &#125;\n\n    &#125;\n\n表示HashMap的修改次数，在执行如上的代码时会抛出异常ConcurrentModifycationException。\n这是一种快是失败（Fast-Fail）机制，容错机制。是针对如两个线程操作hashmap，一个遍历一个删除的情况，这个情况下hashmap会有安全问题，于是就直接抛出异常，停止执行代码。\n\npublic V put(K key, V value) &#123;\n    //判断Entry数组是否为空\n    if (table == EMPTY_TABLE) &#123;\n        //初始化数组\n        inflateTable(threshold);\n    &#125;\n    //判断key是否为null，为null则放入数组第0个位置\n    if (key == null)\n        return putForNullKey(value);\n    //通过hash算法获取key的hash值\n    int hash = hash(key);\n    //通过hash值和数组长度计算在数组中的位置\n    int i = indexFor(hash, table.length);\n    //遍历数组下标i上的链表，如果有重复key，则替换并返回旧值\n    for (Entry&lt;K,V> e = table[i]; e != null; e = e.next) &#123;\n        Object k;\n        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        &#125;\n    &#125;\n\n  \t//修改次数\n    modCount++;\n    //没有重复则添加元素到链表中，采用头插法\n    addEntry(hash, key, value, i);\n    return null;\n&#125;\n\n\n\ninflateTable方法初始化Table的方法。\n\n首先将传入的阈值（也就是初始容量，构造方法中赋值给阈值）进行inflateTable方法计算，获得大于等于toSize的2的幂次方的数，即为table的容量。\n计算阈值为 加载因子 * 容量\nnew一个容量为capacity的Entry数组\n\n\nprivate void inflateTable(int toSize) &#123;\n    // Find a power of 2 >= toSize\n    int capacity = roundUpToPowerOf2(toSize);\n\n    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    table = new Entry[capacity];\n    initHashSeedAsNeeded(capacity);\n&#125;\n\n\n\nroundUpToPowerOf2方法获得大于等于number的2的幂次方的数。\n\n为什么初始化数组一定要是2的幂次方数？\n在indexFor方法中，会通过hash值和数组的长度来计算数组的下标。通过与操作h &amp; (length-1)时，则需要保证数组的长度为2的幂次方数，才能保证(length-1)得到一个二进制的低位全部为1的数。\n\nprivate static int roundUpToPowerOf2(int number) &#123;\n    // assert number >= 0 : \"number must be non-negative\";\n    return number >= MAXIMUM_CAPACITY\n            ? MAXIMUM_CAPACITY\n            : (number > 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;\n&#125;\n\n\n\ninitHashSeedAsNeeded方法初始化hash种子\n当容量大于配置的值后，就会生成一个hash种子。\nhash种子的目的是让生成的hash更加散列。\nfinal boolean initHashSeedAsNeeded(int capacity) &#123;\n    boolean currentAltHashing = hashSeed != 0;\n    boolean useAltHashing = sun.misc.VM.isBooted() &amp;&amp;\n      \t\t\t//只有满足以下条件时才会初始化hash种子\n            (capacity >= Holder.ALTERNATIVE_HASHING_THRESHOLD);\n    boolean switching = currentAltHashing ^ useAltHashing;\n    if (switching) &#123;\n        hashSeed = useAltHashing\n            ? sun.misc.Hashing.randomHashSeed(this)\n            : 0;\n    &#125;\n    return switching;\n&#125;\n\n\n\nHolder类中关于ALTERNATIVE_HASHING_THRESHOLD的赋值\n用户配置了启动参数-Djdk.map.althashing.threshold后，才会有值；否则默认是Integer.MAX_VALUE\nstatic final int static final int ALTERNATIVE_HASHING_THRESHOLD;\n\nstatic &#123;\n  \t//3. altThreshold是用户在启动参数中增加的-Djdk.map.althashing.threshold\n    String altThreshold = java.security.AccessController.doPrivileged(\n        new sun.security.action.GetPropertyAction(\n            \"jdk.map.althashing.threshold\"));\n\n    int threshold;\n    try &#123;\n      \t//2. altThreshold赋值给threshold\n        threshold = (null != altThreshold)\n                ? Integer.parseInt(altThreshold)\n                : ALTERNATIVE_HASHING_THRESHOLD_DEFAULT;\n\n        // disable alternative hashing if -1\n        if (threshold == -1) &#123;\n            threshold = Integer.MAX_VALUE;\n        &#125;\n\n        if (threshold &lt; 0) &#123;\n            throw new IllegalArgumentException(\"value must be positive integer.\");\n        &#125;\n    &#125; catch(IllegalArgumentException failed) &#123;\n        throw new Error(\"Illegal value for 'jdk.map.althashing.threshold'\", failed);\n    &#125;\n\t\t//1. 将threshold赋值给ALTERNATIVE_HASHING_THRESHOLD\n    ALTERNATIVE_HASHING_THRESHOLD = threshold;\n&#125;\n\nputForNullKey方法遍历数组第0个位置上的链表，如果有重复则替换并返回旧值；没有重复则调用addEntry方法将元素添加在第0个位置的链表上。\n\n数组第0个位置上不一定只存了key为NULL的值，其他Key算出来的下标也可能为0\n\nprivate V putForNullKey(V value) &#123;\n    for (Entry&lt;K,V> e = table[0]; e != null; e = e.next) &#123;\n        if (e.key == null) &#123;\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        &#125;\n    &#125;\n    modCount++;\n    addEntry(0, null, value, 0);\n    return null;\n&#125;\n\n\n\nhash方法获取Hash值\n\n通过hashCode方法获取hash值\n与hash种子进行异或运算\n进行右移与异或运算\n\n\n为什么要进行右移与异或？而不直接使用hashCode方法返回的值？\n在indexFor方法中，使用hash值进行下标的计算时，只保留了hash值的低位，高位全部被舍弃，没有参与到下标的计算中来。如果这里直接使用hashCode方法，hashCode方法时可以被重写的，如果重写的方法散列性很差，那么发生hash碰撞的可能性比较大；而进行右移与异或操作后，影响hash值的改变，则可以让高位也参与到下标的计算中来。增加下标的随机性。\n\nfinal int hash(Object k) &#123;\n    int h = hashSeed;\n    if (0 != h &amp;&amp; k instanceof String) &#123;\n        return sun.misc.Hashing.stringHash32((String) k);\n    &#125;\n\n    h ^= k.hashCode();\n\n    // This function ensures that hashCodes that differ only by\n    // constant multiples at each bit position have a bounded\n    // number of collisions (approximately 8 at default load factor).\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n&#125;\n\n\n\nindexFor方法通过hash值获取数组的下标\n下标要求：\n\n取值范围不能超过数组长度\n下标要平均分布在数组中\n\n\n数组长度为2的幂次方，-1则能得到除最高位为1的一个二进制数，与hash值进行与操作，则保留了hash值地位的所有数。由于只取了地位，所以不会超过数组长度；hash同时也是散列的，所以也满足平均分布的要求。\nstatic int indexFor(int h, int length) &#123;\n    // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";\n    return h &amp; (length-1);\n&#125;\n\n\n\naddEntry方法添加元素到HashMap中来\n\n判断数组中存放的元素个数是否大于阈值，并且要存放的位置是否不为null，都满足则进行数组的扩容。扩容的容量为旧数组的2倍\n创建元素并使用头插法，将元素插入到链表中\n\nvoid addEntry(int hash, K key, V value, int bucketIndex) &#123;\n    if ((size >= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;\n        resize(2 * table.length);\n        hash = (null != key) ? hash(key) : 0;\n        bucketIndex = indexFor(hash, table.length);\n    &#125;\n\n    createEntry(hash, key, value, bucketIndex);\n&#125;\n\n\n\nresize方法\n判断旧的容量是否达到最大容量，达到了则不进行扩容\nnew 一个2倍容量的新数组\ntransfer方法将数组元素从旧数组中转移\n\nvoid resize(int newCapacity) &#123;\n    Entry[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    if (oldCapacity == MAXIMUM_CAPACITY) &#123;\n        threshold = Integer.MAX_VALUE;\n        return;\n    &#125;\n\n    Entry[] newTable = new Entry[newCapacity];\n    transfer(newTable, initHashSeedAsNeeded(newCapacity));\n    table = newTable;\n    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n&#125;\n\n\n\ntransfer方法双重循环移动数组元素，for循环遍历数组，while循环遍历链表。以头插法将元素插入到新的数组中。\n\n转移同样采用了indexFor计算数组的下标，在没有rehash的情况下，新的下标只会出现在原来的下标或者i+oldTable.length的位置\n\n\n由于采用了头插法移动数组元素，新数组中的链表与原数组中的链表将会呈倒序\n\n![image-20220106211345431](/Users/doubly/Library/Application Support/typora-user-images/image-20220106211345431.png)\nvoid transfer(Entry[] newTable, boolean rehash) &#123;\n    int newCapacity = newTable.length;\n    for (Entry&lt;K,V> e : table) &#123;\n        while(null != e) &#123;\n            Entry&lt;K,V> next = e.next;\n            if (rehash) &#123;\n                e.hash = null == e.key ? 0 : hash(e.key);\n            &#125;\n            int i = indexFor(e.hash, newCapacity);\n          \t//头插法  \n          \te.next = newTable[i];\n            newTable[i] = e;\n            e = next;\n        &#125;\n    &#125;\n&#125;\n\n\n\ncreateEntry方法使用头插法，将元素插入到数组下标为bucketIndex的链表中\nvoid createEntry(int hash, K key, V value, int bucketIndex) &#123;\n    Entry&lt;K,V> e = table[bucketIndex];\n    table[bucketIndex] = new Entry&lt;>(hash, key, value, e);\n    size++;\n&#125;\n\n\n\n多线程下链表成环问题两个线程同时进行扩容，并且都已经进入了transfer方法，都执行道了图中的代码位置。\n\n\n准备执行的旧数组 \n\n\n没有卡住的线程执行完代码  \n\n\n卡住的线程从next = e.next后开始执行第一次循环  \n\n\n执行完第二次循环  \n\n\n\n\n执行第三次循环\n\n\n\n假设有get方法来获取值，那么进行key比较的时候就会进入无限循环\n\nget方法判断key为空则取数组第0个位置上的entry\npublic V get(Object key) &#123;\n    if (key == null)\n        return getForNullKey();\n    Entry&lt;K,V> entry = getEntry(key);\n\n    return null == entry ? null : entry.getValue();\n&#125;\n\n首先算出key的hash值\n根据hash算出下标\n在数组对应下标的链表中遍历查找，如果key相等则返回entry，没找到则返回null\nfinal Entry&lt;K,V> getEntry(Object key) &#123;\n    if (size == 0) &#123;\n        return null;\n    &#125;\n\n    int hash = (key == null) ? 0 : hash(key);\n    for (Entry&lt;K,V> e = table[indexFor(hash, table.length)];\n         e != null;\n         e = e.next) &#123;\n        Object k;\n        if (e.hash == hash &amp;&amp;\n            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n            return e;\n    &#125;\n    return null;\n&#125;\n\n\n\nConcurrentHashMapHashMap是线程不安全的，那么解决的方法有\n\nHashTable\n\nHashTable直接在get,put方法上加了synchronized，使得线程安全。\n而当不同线程同时存储到数组的不同索引上时，此时他们并不冲突，用HashTable效率就会比较低\n\nConcurrentHashMap\n\n采用了分段锁的设计，效率高\nConcurrent HashMap中，由entry的table变成了segement的数组，然后segement中存储的才是entry的数组\n构造函数//使用默认初始容量 (16)、负载因子 (0.75) 和 concurrencyLevel (16) 创建一个新的空映射。\npublic ConcurrentHashMap() &#123;\n    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);\n&#125;\n\npublic ConcurrentHashMap(int initialCapacity,\n                             float loadFactor, int concurrencyLevel) &#123;\n        if (!(loadFactor > 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)\n            throw new IllegalArgumentException();\n        if (concurrencyLevel > MAX_SEGMENTS)\n            concurrencyLevel = MAX_SEGMENTS;\n        // Find power-of-two sizes best matching arguments\n        int sshift = 0;\n        int ssize = 1;\n        //利用循环得到大于等于并发级别的2的幂次方的数\n  \t\t\twhile (ssize &lt; concurrencyLevel) &#123;\n            ++sshift;\n            ssize &lt;&lt;= 1;\n        &#125;\n        this.segmentShift = 32 - sshift;\n        this.segmentMask = ssize - 1;\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        int c = initialCapacity / ssize;\n        if (c * ssize &lt; initialCapacity)\n            ++c;\n        int cap = MIN_SEGMENT_TABLE_CAPACITY;\n        while (cap &lt; c)\n            cap &lt;&lt;= 1;\n        // create segments and segments[0]\n  \t\t\t//生成一个segment对象放在segment[0]的位置上，当调用put方法时，如果计算出的下标上segment对象为null，则会以第0个位置上的segment对象为模板创建一个新的对象\n        Segment&lt;K,V> s0 =\n            new Segment&lt;K,V>(loadFactor, (int)(cap * loadFactor),\n                             (HashEntry&lt;K,V>[])new HashEntry[cap]);\n        Segment&lt;K,V>[] ss = (Segment&lt;K,V>[])new Segment[ssize];\n  \t\t\t//UNSAFE操作\n        UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]\n        this.segments = ss;\n    &#125;\n\n\nconcurrencyLevel\n并发级别，默认是16，其实指的就是segement的个数。\nSegement 下的entry数组的长度是计算出来的，为concurrencyLevel/initialCapacity，然后取大于该值的最小2的幂次方，就是entry的数组大小\n\n注意：DEFAULT_INITIAL_CAPACITY的容量指的还是entry的个数，不是segement的个数\nUNSAFE操作public class UnsafeTest &#123;\n\n    private static sun.misc.Unsafe UNSAFE;\n    private static long I_OFFSET;\n\n    static &#123;\n        try &#123;\n            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            field.setAccessible(true);\n            UNSAFE = (Unsafe) field.get(null);\n\n            I_OFFSET = UNSAFE.objectFieldOffset(Person.class.getDeclaredField(\"i\"));\n        &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        final Person person = new Person();\n        new Thread(new Runnable()&#123;\n            @Override\n            public void run() &#123;\n                while (true) &#123;\n                    //UNSAFE操作中的CAS操作，原子性，比较并交换\n                    boolean b = UNSAFE.compareAndSwapInt(person, I_OFFSET, person.i, person.i + 1);\n                    if(b) System.out.println(UNSAFE.getIntVolatile(person, I_OFFSET));\n                    //person.i++;\n                    //System.out.println(person.i);\n                    try &#123;\n                        TimeUnit.MILLISECONDS.sleep(500);\n                    &#125; catch (InterruptedException e) &#123;\n                        e.printStackTrace();\n                    &#125;\n                &#125;\n            &#125;\n        &#125;).start();\n\n        new Thread(new Runnable()&#123;\n            @Override\n            public void run() &#123;\n                while (true) &#123;\n                    boolean b = UNSAFE.compareAndSwapInt(person, I_OFFSET, person.i, person.i + 1);\n                    if(b) System.out.println(UNSAFE.getIntVolatile(person, I_OFFSET));\n                    //person.i++;\n                    //System.out.println(person.i);\n                    try &#123;\n                        TimeUnit.MILLISECONDS.sleep(500);\n                    &#125; catch (InterruptedException e) &#123;\n                        e.printStackTrace();\n                    &#125;\n                &#125;\n            &#125;\n        &#125;).start();\n    &#125;\n&#125;\n\nclass Person&#123;\n    int i = 0;\n&#125;\n\n\n\n在ConcurrentHashMap中用到了UNSAFE的CAS操作，比如\n两个线程同时进行一个put操作，且都在同一个位置，且segment为null。同时put就会存在并发安全问题，segment被覆盖。而采用CAS则可以不用加锁就保证线程安全。\nput方法\n计算key的hash值\n通过hash值获取在segment数组中的下标hashCode &amp; segment[].length -1\n如果segment为null，则通过CAS操作创建一个segment\n调用segment的put方法\n获取segment中entry数组的下标hashCode &amp; hashEntry[].length -1\n\npublic V put(K key, V value) &#123;\n    Segment&lt;K,V> s;\n    if (value == null)\n        throw new NullPointerException();\n    //获取hash值\n    int hash = hash(key);\n    //获取在segment数组中的下标 \n    int j = (hash >>> segmentShift) &amp; segmentMask;\n    //取segments数组中第j个位置的值\n    if ((s = (Segment&lt;K,V>)UNSAFE.getObject          // nonvolatile; recheck\n         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment\n        s = ensureSegment(j);\n    return s.put(key, hash, value, false);\n&#125;\n\n\n\nJDK 1.8中","categories":["Java"],"tags":["HashMap","ConcurrentHashMap"]},{"title":"JUC","url":"/post/Java/JUC.html","content":"什么是JUC？就是包，java.util.concurrent\n线程和进程进程：一个程序，QQ.exe Music.exe，程序的集合 .jar\n一个进程往往可以包含多个线程，至少包含一个！\nJava默认有几个线程？2个，Main线程和GC线程\n线程：开了一个进程Typora，写字、自动保存是线程负责的\n对Java而言 ：Thread、Runnable、Callable\nJava真的可以开启线程吗？不可以，只能通过本地方法调用\npublic synchronized void start() &#123;\n    /**\n     * This method is not invoked for the main method thread or \"system\"\n     * group threads created/set up by the VM. Any new functionality added\n     * to this method in the future may have to also be added to the VM.\n     *\n     * A zero status value corresponds to state \"NEW\".\n     */\n    if (threadStatus != 0)\n        throw new IllegalThreadStateException();\n\n    /* Notify the group that this thread is about to be started\n     * so that it can be added to the group's list of threads\n     * and the group's unstarted count can be decremented. */\n    group.add(this);\n\n    boolean started = false;\n    try &#123;\n        start0();\n        started = true;\n    &#125; finally &#123;\n        try &#123;\n            if (!started) &#123;\n                group.threadStartFailed(this);\n            &#125;\n        &#125; catch (Throwable ignore) &#123;\n            /* do nothing. If start0 threw a Throwable then\n              it will be passed up the call stack */\n        &#125;\n    &#125;\n&#125;\n\n//本地方法，底层的C++，Java无法直接操作\nprivate native void start0();\n\n\n\n\n并发、并行并发：CPU一核，通过快速交替模拟出来多条线程同时运行，其实每次只有一条线程运行。\n并行：CPU多核，多个线程可以同时执行；线程池\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        //获取CPU的核数\n        // CPU密集型，IO密集型\n        System.out.println(Runtime.getRuntime().availableProcessors());\n    &#125;\n&#125;\n\n\n并发编程的本质：充分利用CPU资源\n线程的几种状态一般来说：创建-&gt;就绪-&gt;运行-&gt;阻塞-&gt;死亡\n源码中：\npublic enum State &#123;\n    // 创建\n    NEW,\n\n    // 运行\n    RUNNABLE,\n\n    // 阻塞\n    BLOCKED,\n\n    // 等待，一直等下去\n    WAITING,\n\n    // 超时等待，超时后不再等\n    TIMED_WAITING,\n\n    // 终止\n    TERMINATED;\n&#125;\n\n\n\nwait和sleep的区别\n来自不同的类\n\nwait -&gt; Object\nsleep -&gt; Thread\n\n关于锁的释放\n\nwait会释放锁，sleep不会释放锁，抱着锁睡觉！\n\n使用的范围不同\n\nwait：必须在同步代码块中\nsleep：可以在任何地方睡\n\n是否需要捕获异常\n\nwait不需要捕获异常，sleep必须要捕获异常\nnotify与notifyAll、signal与signalAll的区别notify与notifyAll的区别\nnotify是从等待池中随机唤醒一个线程，而notifyAll是唤醒所有线程\nsignal和signalAll的区别\nsignal是从等待队列中唤醒第一个线程，而signalAll是signal的循环，唤醒所有线程\nLock锁传统锁Synchronizedpublic class SaleTicket &#123;\n    public static void main(String[] args) &#123;\n        Ticket ticket = new Ticket();\n        new Thread(()->&#123;ticket.sale();&#125;,\"A\").start();\n        new Thread(ticket::sale,\"B\").start();\n        new Thread(ticket::sale,\"C\").start();\n    &#125;\n&#125;\n\nclass Ticket&#123;\n    //票的数量\n    private int num = 50;\n\n    public synchronized void sale()&#123;\n        while (num > 0) &#123;\n            System.out.println(Thread.currentThread().getName() + \"卖出了第\" + num-- + \"张票，剩余：\" + num);\n            try &#123;\n                TimeUnit.MILLISECONDS.sleep(100);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n\nLock接口所有已知实现类\n\nReentrantLock，可重入锁（常用）\n\n公平锁：十分公平，先来后到\n非公平锁：十分不公平，可以插队（默认）\n\n\n\nReentrantReadWriteLock.ReadLock，读锁\n\nReentrantReadWriteLock.WriteLock，写锁\n\n\npublic class SaleTicketWithLock &#123;\n    public static void main(String[] args) &#123;\n        Ticket2 ticket = new Ticket2();\n        new Thread(()->&#123;ticket.sale();&#125;,\"A\").start();\n        new Thread(ticket::sale,\"B\").start();\n        new Thread(ticket::sale,\"C\").start();\n    &#125;\n&#125;\n\n/**\n * Lock三部曲\n * 1. new ReentrantLock();\n * 2. 加锁，lock.lock();\n * 3. 释放锁，lock.unlock();\n */\nclass Ticket2&#123;\n    //票的数量\n    private int num = 50;\n\n    //定义锁\n    Lock lock = new ReentrantLock();\n\n    public void sale()&#123;\n        lock.lock();\n        try &#123;\n            while (num > 0) &#123;\n                System.out.println(Thread.currentThread().getName() + \"卖出了第\" + num-- + \"张票，剩余：\" + num);\n                try &#123;\n                    TimeUnit.MILLISECONDS.sleep(100);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n&#125;\n\n\n\nSynchronized与Lock的区别\nSynchronized是一个Java内置的关键字，Lock是一个Java类\nSynchronized无法判断获取锁的状态，Lock可以判断是否获取到了锁\nSynchronized会自动释放锁，Lock必须要手动释放锁。如果不释放锁，会出现死锁\nSynchronized，如果线程1获取了锁并阻塞，线程2会一直等待；Lock锁就不一定会等下去lock.tryLock()\nSynchronized可重入锁，不可以中断的，非公平；Lock可重入锁，可以判断 锁，默认非公平（可以自己设置）\nSynchronized适合锁少量的代码同步问题，Lock适合锁大量的同步代码\n\n生产者和消费者问题Synchronized版package top.doubly;\n\npublic class ProducerAndConsumer &#123;\n    public static void main(String[] args) &#123;\n        Data data = new Data();\n        new Thread(()->&#123;\n            for (int i = 0; i &lt; 10; i++) &#123;\n                data.increment();\n            &#125;\n        &#125;,\"A\").start();\n        new Thread(()->&#123;\n            for (int i = 0; i &lt; 10; i++) &#123;\n                data.decrement();\n            &#125;\n        &#125;,\"B\").start();\n    &#125;\n\n&#125;\n\n\nclass Data&#123;\n    private int num = 0;\n\n    /**\n     * 生产者消费者问题步骤\n     * 1. 判断等待\n     * 2. 业务\n     * 3. 通知\n     */\n    public synchronized void increment()&#123;\n        if(num != 0)&#123;\n            try &#123;\n                this.wait();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        num += 1;\n        System.out.println(Thread.currentThread().getName() + \"=>\" + num);\n        this.notifyAll();\n    &#125;\n\n    /**\n     * 生产者消费者问题步骤\n     * 1. 判断等待\n     * 2. 业务\n     * 3. 通知\n     */\n    public synchronized void decrement()&#123;\n        if(num == 0)&#123;\n            try &#123;\n                this.wait();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        num -= 1;\n        System.out.println(Thread.currentThread().getName() + \"=>\" + num);\n        this.notifyAll();\n    &#125;\n&#125;\n\n\n问题存在，A B C D四个线程时，会出现虚假唤醒\n\n\n解决办法：if改为while\npackage top.doubly;\n\npublic class ProducerAndConsumer &#123;\n    public static void main(String[] args) &#123;\n        Data data = new Data();\n        new Thread(()->&#123;\n            for (int i = 0; i &lt; 10; i++) &#123;\n                data.increment();\n            &#125;\n        &#125;,\"A\").start();\n        new Thread(()->&#123;\n            for (int i = 0; i &lt; 10; i++) &#123;\n                data.decrement();\n            &#125;\n        &#125;,\"B\").start();new Thread(()->&#123;\n            for (int i = 0; i &lt; 10; i++) &#123;\n                data.increment();\n            &#125;\n        &#125;,\"C\").start();\n        new Thread(()->&#123;\n            for (int i = 0; i &lt; 10; i++) &#123;\n                data.decrement();\n            &#125;\n        &#125;,\"D\").start();\n\n    &#125;\n\n&#125;\n\n\nclass Data&#123;\n    private int num = 0;\n\n    /**\n     * 生产者消费者问题步骤\n     * 1. 判断等待\n     * 2. 业务\n     * 3. 通知\n     */\n    public synchronized void increment()&#123;\n        //System.out.println(Thread.currentThread().getName()+\"进入方法\");\n        while (num != 0)&#123;\n            try &#123;\n                //System.out.println(Thread.currentThread().getName()+\"进入等待\");\n                this.wait();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        num += 1;\n        System.out.println(Thread.currentThread().getName() + \"=>\" + num);\n        this.notifyAll();\n    &#125;\n\n    /**\n     * 生产者消费者问题步骤\n     * 1. 判断等待\n     * 2. 业务\n     * 3. 通知\n     */\n    public synchronized void decrement()&#123;\n        //System.out.println(Thread.currentThread().getName()+\"进入方法\");\n        while (num == 0)&#123;\n            try &#123;\n                //System.out.println(Thread.currentThread().getName()+\"进入等待\");\n                this.wait();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        num -= 1;\n        System.out.println(Thread.currentThread().getName() + \"=>\" + num);\n        this.notifyAll();\n    &#125;\n&#125;\n\n\n\nJUC版使用await和signal方法代替了Object的监视器方法（wait,notify,notiryAll）\n\n代码实现\npackage top.doubly;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class ProducerAndConsumerWithJUC &#123;\n    public static void main(String[] args) &#123;\n        Data2 data = new Data2();\n        new Thread(()->&#123;\n            for (int i = 0; i &lt; 10; i++) &#123;\n                data.increment();\n            &#125;\n        &#125;,\"A\").start();\n        new Thread(()->&#123;\n            for (int i = 0; i &lt; 10; i++) &#123;\n                data.decrement();\n            &#125;\n        &#125;,\"B\").start();new Thread(()->&#123;\n            for (int i = 0; i &lt; 10; i++) &#123;\n                data.increment();\n            &#125;\n        &#125;,\"C\").start();\n        new Thread(()->&#123;\n            for (int i = 0; i &lt; 10; i++) &#123;\n                data.decrement();\n            &#125;\n        &#125;,\"D\").start();\n\n    &#125;\n\n&#125;\n\n\nclass Data2&#123;\n    private int num = 0;\n\n    private Lock lock = new ReentrantLock(false);\n    private Condition condition = lock.newCondition();\n    /**\n     * 生产者消费者问题步骤\n     * 1. 判断等待\n     * 2. 业务\n     * 3. 通知\n     */\n    public void increment()&#123;\n        lock.lock();\n        try &#123;\n            while (num != 0) &#123;\n                try &#123;\n                    condition.await();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            num += 1;\n            System.out.println(Thread.currentThread().getName() + \"=>\" + num);\n            condition.signalAll();\n        &#125;finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n\n    /**\n     * 生产者消费者问题步骤\n     * 1. 判断等待\n     * 2. 业务\n     * 3. 通知\n     */\n    public void decrement()&#123;\n        lock.lock();\n        try &#123;\n            while (num == 0) &#123;\n                try &#123;\n                    condition.await();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            num -= 1;\n            System.out.println(Thread.currentThread().getName() + \"=>\" + num);\n            condition.signalAll();\n        &#125;finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n&#125;\n\n执行结果，虽然num结果是0和1交替执行，但A,B,C,D四个线程乱序执行\n\n\n任何一个新的技术，绝对不是仅仅只是覆盖了原来的技术，一定会有优势和补充\n\n\n Condition可以精准的通知和唤醒线程，实现有序的执行A,B,C,D线程\n\n改进：可以new多个Condition区分不同状态\nclass Data2&#123;\n    private int num = 0;\n\n    private Lock lock = new ReentrantLock(false);\n    private Condition isZero1 = lock.newCondition();\n    private Condition isZero2 = lock.newCondition();\n    private Condition notZero1 = lock.newCondition();\n    private Condition notZero2 = lock.newCondition();\n    //private Condition condition = lock.newCondition();\n    /**\n     * 生产者消费者问题步骤\n     * 1. 判断等待\n     * 2. 业务\n     * 3. 通知\n     */\n    public void increment()&#123;\n        lock.lock();\n        try &#123;\n            String threadName = Thread.currentThread().getName();\n            if (num != 0) &#123;\n                try &#123;\n                    //condition.await();\n                    if(\"A\".equals(threadName)) &#123;\n                        notZero1.await();\n                    &#125;else if(\"C\".equals(threadName))&#123;\n                        notZero2.await();\n                    &#125;\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            num += 1;\n            System.out.println(threadName + \"=>\" + num);\n            if (\"A\".equals(threadName)) &#123;\n                isZero1.signalAll();\n            &#125; else if(\"C\".equals(threadName))&#123;\n                isZero2.signalAll();\n            &#125;\n            //condition.signalAll();\n        &#125;finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n\n    /**\n     * 生产者消费者问题步骤\n     * 1. 判断等待\n     * 2. 业务\n     * 3. 通知\n     */\n    public void decrement()&#123;\n        lock.lock();\n        try &#123;\n            String threadName = Thread.currentThread().getName();\n            while (num == 0) &#123;\n                try &#123;\n                    //condition.await();\n                    if(\"B\".equals(threadName))&#123;\n                        isZero1.await();\n                    &#125;else if(\"D\".equals(threadName))&#123;\n                        isZero2.await();\n                    &#125;\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            num -= 1;\n            System.out.println(threadName + \"=>\" + num);\n            //condition.signalAll();\n            if(\"B\".equals(threadName))&#123;\n                notZero2.signalAll();\n            &#125;else if(\"D\".equals(threadName))&#123;\n                notZero1.signalAll();\n            &#125;\n        &#125;finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n&#125;\n\n执行结果，A,B,C,D顺序依次执行\n\n8锁现象\n标准情况下，两个线程先打印发短信还是打电话？\n\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n        Phone phone = new Phone();\n\n        new Thread(phone::sendSms).start();\n\n        try &#123;\n            TimeUnit.SECONDS.sleep(1);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        new Thread(phone::call).start();\n    &#125;\n&#125;\n\nclass Phone&#123;\n    public synchronized void sendSms()&#123;\n        System.out.println(\"发短信\");\n    &#125;\n\n    public synchronized void call()&#123;\n        System.out.println(\"打电话\");\n    &#125;\n&#125;\n\n结果：发短信，打电话\n\n发短信线程先休息4s钟，是发短信还是打电话？\n\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n        Phone phone = new Phone();\n\n        new Thread(phone::sendSms).start();\n\n        try &#123;\n            TimeUnit.SECONDS.sleep(1);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        new Thread(phone::call).start();\n    &#125;\n&#125;\n\nclass Phone&#123;\n    public synchronized void sendSms() &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(4);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(\"发短信\");\n    &#125;\n\n    public synchronized void call()&#123;\n        System.out.println(\"打电话\");\n    &#125;\n&#125;\n\n结果：发短信、打电话\n\nsynchronized锁的对象是方法的调用者，即phone对象！\n两个方法用的是同一个锁，所以谁先拿到谁先执行！\n\n\nPhone增加了一个普通方法后，线程B调用hello方法，是先执行发短信还是hello？\n\npublic class Test2 &#123;\n    public static void main(String[] args) &#123;\n        Phone2 phone = new Phone2();\n\n        new Thread(phone::sendSms,\"A\").start();\n\n        try &#123;\n            TimeUnit.SECONDS.sleep(1);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        new Thread(phone::hello,\"B\").start();\n    &#125;\n&#125;\n\nclass Phone2&#123;\n    public synchronized void sendSms() &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(4);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(\"发短信\");\n    &#125;\n\n    public synchronized void call()&#123;\n        System.out.println(\"打电话\");\n    &#125;\n\n    //这里没有锁\n    public void hello()&#123;\n        System.out.println(\"hello\");\n    &#125;\n&#125;\n\n结果：hello，发短信\n\nhello是普通方法，没有加锁，所以不需要获取锁就可以立即执行\n\n\n两个线程使用两个对象执行两个同步方法，先执行发短信还是先打电话？\n\npublic class Test2 &#123;\n    public static void main(String[] args) &#123;\n        Phone2 phone1 = new Phone2();\n        Phone2 phone2 = new Phone2();\n\n        new Thread(phone1::sendSms,\"A\").start();\n\n        try &#123;\n            TimeUnit.SECONDS.sleep(1);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        new Thread(phone2::call,\"B\").start();\n    &#125;\n&#125;\n\nclass Phone2&#123;\n    public synchronized void sendSms() &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(4);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(\"发短信\");\n    &#125;\n\n    public synchronized void call()&#123;\n        System.out.println(\"打电话\");\n    &#125;\n&#125;\n\n结果：打电话、发短信\n\n这里是两个不同的调用对象，A线程锁的是phone1，B线程锁的是phone2\n\n\n增加两个静态方法，AB线程调用两个静态方法，是先发短信还是先打电话？\n\npublic class Test3 &#123;\n    public static void main(String[] args) &#123;\n        Phone3 phone = new Phone3();\n\n        new Thread(()->&#123;\n            phone.sendSms();\n        &#125;,\"A\").start();\n\n        try &#123;\n            TimeUnit.SECONDS.sleep(1);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        new Thread(()->&#123;\n            phone.call();\n        &#125;,\"B\").start();\n    &#125;\n&#125;\n\nclass Phone3&#123;\n    public static synchronized void sendSms() &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(4);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(\"发短信\");\n    &#125;\n\n    public static synchronized void call()&#123;\n        System.out.println(\"打电话\");\n    &#125;\n&#125;\n\n结果：发短信\n\n静态同步方法锁的是class对象，class对象全局唯一，所以两个线程竞争同一把锁\n\n\n定义两个对象，分别调用两个静态方法，是先发短信还是先打电话？\n\npublic class Test4 &#123;\n    public static void main(String[] args) &#123;\n        Phone3 phone1 = new Phone3();\n        Phone3 phone2 = new Phone3();\n\n        new Thread(()->&#123;\n            phone1.sendSms();\n        &#125;,\"A\").start();\n\n        try &#123;\n            TimeUnit.SECONDS.sleep(1);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        new Thread(()->&#123;\n            phone2.call();\n        &#125;,\"B\").start();\n    &#125;\n&#125;\n\nclass Phone4&#123;\n    public static synchronized void sendSms() &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(4);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(\"发短信\");\n    &#125;\n\n    public static synchronized void call()&#123;\n        System.out.println(\"打电话\");\n    &#125;\n&#125;\n\n结果：发短信、打电话\n\n两个对象的静态同步方法锁的都是Phone的class对象\n\n\n1个静态同步方法，1个普通同步方法，1个对象，先打印发短信还是打电话？\n\npublic class Test4 &#123;\n    public static void main(String[] args) &#123;\n        Phone4 phone1 = new Phone4();\n\n        new Thread(()->&#123;\n            phone1.sendSms();\n        &#125;,\"A\").start();\n\n        try &#123;\n            TimeUnit.SECONDS.sleep(1);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        new Thread(()->&#123;\n            phone1.call();\n        &#125;,\"B\").start();\n    &#125;\n&#125;\n\nclass Phone4&#123;\n    public static synchronized void sendSms() &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(4);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(\"发短信\");\n    &#125;\n\n    public synchronized void call()&#123;\n        System.out.println(\"打电话\");\n    &#125;\n&#125;\n\n结果：打电话、发短信\n\n静态同步方法锁的是class对象，普通同步方法锁的是phone对象，两个线程没有竞争\n\n\n1个静态同步方法，1个普通同步方法，2个对象，先打印发短信还是打电话？\n\npublic class Test4 &#123;\n    public static void main(String[] args) &#123;\n        Phone4 phone1 = new Phone4();\n        Phone4 phone2 = new Phone4();\n\n        new Thread(()->&#123;\n            phone1.sendSms();\n        &#125;,\"A\").start();\n\n        try &#123;\n            TimeUnit.SECONDS.sleep(1);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        new Thread(()->&#123;\n            phone2.call();\n        &#125;,\"B\").start();\n    &#125;\n&#125;\n\nclass Phone4&#123;\n    public static synchronized void sendSms() &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(4);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(\"发短信\");\n    &#125;\n\n    public synchronized void call()&#123;\n        System.out.println(\"打电话\");\n    &#125;\n&#125;\n\n结果：打电话、发短信\n\n静态同步方法锁的是class对象，普通同步方法锁的是phone对象，两个线程没有竞争\n\n总结：new this锁的是具体对象，static class锁的是类对象\n集合类不安全List不安全public class ListTest &#123;\n    public static void main(String[] args) &#123;\n        List&lt;String> list = new ArrayList&lt;>();\n\n        for (int i = 0; i &lt; 10; i++) &#123;\n            new Thread(()->&#123;\n                list.add(UUID.randomUUID().toString().substring(0,5));\n                System.out.println(list);\n            &#125;,String.valueOf(i)).start();\n        &#125;\n\n    &#125;\n&#125;\n\n运行结果，发生异常\n[0aa0d, fd313, 170eb]\n[0aa0d, fd313, 170eb, 109dc, 8edff, 53ab7, 15bca]\n[0aa0d, fd313, 170eb, 109dc, 8edff, 53ab7]\n[0aa0d, fd313, 170eb, 109dc, 8edff]\n[0aa0d, fd313, 170eb, 109dc]\n[0aa0d, fd313, 170eb]\n[0aa0d, fd313, 170eb]\n[0aa0d, fd313, 170eb, 109dc, 8edff, 53ab7, 15bca, 4322d, d1ca0, 838ac]\n[0aa0d, fd313, 170eb, 109dc, 8edff, 53ab7, 15bca, 4322d]\nException in thread \"9\" java.util.ConcurrentModificationException\n\tat java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)\n\tat java.util.ArrayList$Itr.next(ArrayList.java:859)\n\tat java.util.AbstractCollection.toString(AbstractCollection.java:461)\n\tat java.lang.String.valueOf(String.java:2994)\n\tat java.io.PrintStream.println(PrintStream.java:821)\n\tat top.doubly.unsafe.ListTest.lambda$main$0(ListTest.java:15)\n\tat java.lang.Thread.run(Thread.java:748)\n\nProcess finished with exit code 0\n\njava.util.ConcurrentModificationException 并发修改异常\n解决方案：\n\nList&lt;String&gt; list = new Vector&lt;&gt;();，Vector从1.0就有，ArrayList从1.2，\nList&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());\nList&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();\n\nCopyOnWriteArrayList\n写入时复制，简称COW。计算机程序设计领域的一种优化策略；\nSet不安全public class SetTest &#123;\n    public static void main(String[] args) &#123;\n        Set&lt;String> set = new HashSet&lt;>();\n\n        for (int i = 0; i &lt; 10; i++) &#123;\n            new Thread(()->&#123;\n                set.add(UUID.randomUUID().toString());\n                System.out.println(set);\n            &#125;).start();\n        &#125;\n    &#125;\n&#125;\n\n运行时发生异常\n\n解决方案：\n\nSet&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());\nSet&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();\n\nHashSet底层\nHashSet底层就是一个HashMap，看源码\n\n\n\nMap不安全HashMap基础回顾\npublic class MapTest &#123;\n    public static void main(String[] args) &#123;\n        Map&lt;String,Object> map = new HashMap&lt;>();\n        for (int i = 0; i &lt; 10; i++) &#123;\n            new Thread(()->&#123;\n                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString());\n                System.out.println(map);\n            &#125;).start();\n        &#125;\n    &#125;\n&#125;\n\n运行同样出现异常\n\n解决方法：\n\nMap&lt;String,Object&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());\nMap&lt;String,Object&gt; map = new ConcurrentHashMap&lt;&gt;();\n\nConcurrentHashMap原理Callable\n可以有返回值\n可以抛出异常\n方法不同，run()/call()\n\npublic class CallableTest &#123;\n\n    public static void main(String[] args) &#123;\n        MyCallable myCallable = new MyCallable();\n        FutureTask&lt;String> futureTask = new FutureTask&lt;>(myCallable);\n        new Thread(futureTask).start();\n        String s = null;\n        try &#123;\n            s = futureTask.get();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; catch (ExecutionException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(\"获取\"+s);\n    &#125;\n\n&#125;\n\nclass MyCallable implements Callable&lt;String>&#123;\n\n    @Override\n    public String call() throws Exception &#123;\n        System.out.println(\"call()\");\n        return \"test\";\n    &#125;\n&#125;\n\n注意：\n\nfutureTask.get()方法会产生阻塞，一般会将get方法写在最后，活着使用异步通信\n\npublic static void main(String[] args) &#123;\n    MyCallable myCallable = new MyCallable();\n    FutureTask&lt;String> futureTask = new FutureTask&lt;>(myCallable);\n    new Thread(futureTask,\"A\").start();\n    new Thread(futureTask,\"B\").start();\n    String s = futureTask.get();\n    System.out.println(\"获取\"+s);\n&#125;\n\n\n\n两个线程执行一个callable，只会被执行一次，结果会被缓存\n\n常用的辅助类CountDownLatch计数辅助工具类，当计数为0时，线程才会继续向下执行。一般在必须要执行任务的时候使用\n\npublic class CountDownLatchDemo &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        //总数是6\n        CountDownLatch countDownLatch = new CountDownLatch(6);\n\n        for (int i = 0; i &lt; 6; i++) &#123;\n            new Thread(()->&#123;\n                System.out.println(Thread.currentThread().getName()+\" Go out\");\n                //数量-1\n                countDownLatch.countDown();\n            &#125;,String.valueOf(i)).start();\n        &#125;\n\t\t//等待计数器归零，然后再向下执行\n        countDownLatch.await();\n\n        System.out.println(\"Close Door\");\n    &#125;\n&#125;\n\n原理：\ncountDownLatch.countDown();进行数量-1\ncountDownLatch.await();等待计数器归零，然后再向下执行\n每次有线程调用countDown()数量-1，假设计数器变为0，countDownLatch.await();就会被唤醒\nCyclicBarrier加法计数器\n\npublic class CyclicBarrierDemo &#123;\n\n    public static void main(String[] args) &#123;\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> &#123;\n            System.out.println(\"神龙召唤成功\");\n        &#125;);\n        for (int i = 0; i &lt; 7; i++) &#123;\n            final int temp = i;\n            new Thread(()->&#123;\n                System.out.println(Thread.currentThread().getName()+\"集齐第\"+temp+\"颗龙珠\");\n                try &#123;\n                    //等待，直到计数器计数完成才能继续执行\n                    cyclicBarrier.await();\n                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                System.out.println(Thread.currentThread().getName());\n            &#125;).start();\n        &#125;\n    &#125; \n    \n&#125;\n\n输出\nThread-0集齐第0颗龙珠\nThread-4集齐第4颗龙珠\nThread-3集齐第3颗龙珠\nThread-1集齐第1颗龙珠\nThread-6集齐第6颗龙珠\nThread-2集齐第2颗龙珠\nThread-5集齐第5颗龙珠\n神龙召唤成功\nThread-5\nThread-4\nThread-0\nThread-2\nThread-6\nThread-1\nThread-3\n\n\n\n如果计数器设置了8，而计数器只计数到了7，程序就会一直等待。\n使用cyclicBarrier.await(10, TimeUnit.SECONDS);可以防止一直等待的情况，超时后会抛出异常。\nSemaphore信号量\n\n一个计数信号量。 在概念上，信号量维持一组许可证。 如果有必要，每个acquire()都会阻塞，直到许可证可用，然后才能使用它。 每个release()添加许可证，潜在地释放阻塞获取方。 但是，没有使用实际的许可证对象; Semaphore只保留可用数量的计数，并相应地执行。\n信号量通常用于限制线程数，而不是访问某些（物理或逻辑）资源。 \n\n抢车位的例子：\n7辆车抢3个车位，只有前面的车出来之后，后面的车才可以抢到车位\npublic class SemaphoreDemo &#123;\n    public static void main(String[] args) &#123;\n        Semaphore semaphore = new Semaphore(3);\n        for (int i = 0; i &lt; 7; i++) &#123;\n            new Thread(() -> &#123;\n                try &#123;\n                    semaphore.acquire();\n                    System.out.println(Thread.currentThread().getName() + \"抢到了车位\");\n                    TimeUnit.SECONDS.sleep(3);\n                    System.out.println(Thread.currentThread().getName() + \"离开了车位\");\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125; finally &#123;\n                    semaphore.release();\n                &#125;\n            &#125;).start();\n        &#125;\n    &#125;\n&#125;\n\n输出\nThread-1抢到了车位\nThread-2抢到了车位\nThread-0抢到了车位\nThread-2离开了车位\nThread-1离开了车位\nThread-0离开了车位\nThread-3抢到了车位\nThread-4抢到了车位\nThread-5抢到了车位\nThread-5离开了车位\nThread-3离开了车位\nThread-4离开了车位\nThread-6抢到了车位\nThread-6离开了车位\n\n\n\n原理\nsemaphore.acquire();：获得许可证，假如已经满了，则进行等待，等待许可证被释放为止\nsemaphore.release();：释放许可证，会将当前的信号量释放+1，然后唤醒等待的线程。\n作用\n\n多个共享资源互斥的使用\n并发限流，控制最大的线程数\n\n读写锁public interface ReadWriteLock\n一个 ReadWriteLock维护一对关联的locks ，一个用于只读操作，一个用于写入。 read lock可以由多个阅读器线程同时进行，只要没有作者。 write lock是独家的。\n模拟缓存同时读取的情况。高速缓存需要不可以同时写，但可以同时读，以提高效率\npublic class ReadWriteLockDemo &#123;\n    public static void main(String[] args) &#123;\n        MyCache3 myCache = new MyCache3();\n\n        for (int i = 0; i &lt; 5; i++) &#123;\n            final int temp = i;\n            new Thread(()->&#123;\n                myCache.put(String.valueOf(temp),temp);\n            &#125;).start();\n        &#125;\n\n        for (int i = 0; i &lt; 5; i++) &#123;\n            final int temp = i;\n            new Thread(()->&#123;\n                myCache.get(String.valueOf(temp));\n            &#125;).start();\n        &#125;\n    &#125;\n&#125;\n\n//无锁的情况下，多个线程会出现同时写入的情况，显然时不行的\nclass MyCache1&#123;\n    private final Map&lt;String,Object> map = new HashMap&lt;>();\n\n    public void put(String key,Object value)&#123;\n        System.out.println(Thread.currentThread().getName()+\"开始写入\"+key);\n        map.put(key,value);\n        System.out.println(Thread.currentThread().getName()+\"写入结束\");\n    &#125;\n\n    public Object get(String key)&#123;\n        System.out.println(Thread.currentThread().getName()+\"开始读取\"+key);\n        Object o = map.get(key);\n        System.out.println(Thread.currentThread().getName()+\"读取结束\");\n        return o;\n    &#125;\n&#125;\n\n//只给写入加锁的情况下，会出现写入时数据被读取的情况，脏读也是不被允许的\nclass MyCache2&#123;\n    private final Map&lt;String,Object> map = new HashMap&lt;>();\n\n    public synchronized void put(String key,Object value)&#123;\n        System.out.println(Thread.currentThread().getName()+\"开始写入\");\n        map.put(key,value);\n        System.out.println(Thread.currentThread().getName()+\"写入结束\");\n    &#125;\n\n    public Object get(String key)&#123;\n        System.out.println(Thread.currentThread().getName()+\"开始读取\");\n        Object o = map.get(key);\n        System.out.println(Thread.currentThread().getName()+\"读取结束\");\n        return o;\n    &#125;\n&#125;\n\n//使用读写锁，就可以保证写的时候只有一个线程，读的时候可以多个线程同时读取。并且写的时候不可以读取。\nclass MyCache3&#123;\n    private final Map&lt;String,Object> map = new HashMap&lt;>();\n\n    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    public void put(String key,Object value)&#123;\n        //写锁加锁\n        readWriteLock.writeLock().lock();\n        try &#123;\n            System.out.println(Thread.currentThread().getName() + \"开始写入\");\n            map.put(key, value);\n            System.out.println(Thread.currentThread().getName() + \"写入结束\");\n        &#125; finally &#123;\n            //写锁释放锁\n            readWriteLock.writeLock().unlock();\n        &#125;\n    &#125;\n\n    public Object get(String key)&#123;\n        //读锁加锁\n        readWriteLock.readLock().lock();\n        Object o;\n        try &#123;\n            System.out.println(Thread.currentThread().getName() + \"开始读取\");\n            o = map.get(key);\n            System.out.println(Thread.currentThread().getName() + \"读取结束\");\n        &#125;finally &#123;\n            //读锁释放锁\n            readWriteLock.readLock().unlock();\n        &#125;\n        return o;\n    &#125;\n&#125;\n\n\n\n独占锁（写锁）：一次只能一个线程占有\n共享锁（读锁）：一次可以多个线程占有\nReadWriteLock\n读-读：可以共存\n写-写：不可以共存\n读-写：不可以共存\n阻塞队列队列\n先进先出，FIFO。写：往队列插入元素；读：从队列取出元素\n阻塞\n写入时阻塞：当队列已经满了，就会阻塞\n读取时阻塞：当队列为空时，就会阻塞\n阻塞队列：BlockingQueue\n双端队列：Deque，即队列两头可操作\n\n\n四组API操作\n\n\n操作\n抛出异常\n有返回值，不抛出异常\n阻塞，等待\n超时等待\n\n\n\n插入\nadd\noffer\nput\noffer(,,)\n\n\n删除\nremove\npoll\ntake\npoll(,)\n\n\n检测队首元素\nelement\npeek\n-\n-\n\n\n抛出异常\n当队列已满时，插入元素抛出异常\n当队列为空时，取出元素抛出异常\n当队列为空时，获取队首元素抛出异常\n\npublic static void test1()&#123;\n    System.out.println(arrayBlockingQueue.add(\"1\"));\n    System.out.println(arrayBlockingQueue.add(\"2\"));\n    System.out.println(arrayBlockingQueue.add(\"3\"));\n\n    //当队列已满的时候会抛出异常\n    //System.out.println(arrayBlockingQueue.add(\"4\"));\n\n    System.out.println(arrayBlockingQueue.remove());\n    System.out.println(arrayBlockingQueue.remove());\n    System.out.println(arrayBlockingQueue.remove());\n\n    //当队列为空的时候，会抛出异常\n    //System.out.println(arrayBlockingQueue.remove());\n\n    //获取队首元素，当队首为空时，抛出异常\n    System.out.println(arrayBlockingQueue.element());\n&#125;\n\n不抛异常\n当队列已满时，插入元素返回false\n当队列为空时，取出元素返回null\n当队列为空时，获取队首元素返回null\n\npublic static void test2()&#123;\n    System.out.println(arrayBlockingQueue.offer(\"1\"));\n    System.out.println(arrayBlockingQueue.offer(\"2\"));\n    System.out.println(arrayBlockingQueue.offer(\"3\"));\n    //当阻塞队列已满时，返回false，不抛出异常\n    System.out.println(arrayBlockingQueue.offer(\"4\"));\n\n    System.out.println(arrayBlockingQueue.poll());\n    System.out.println(arrayBlockingQueue.poll());\n    System.out.println(arrayBlockingQueue.poll());\n    //当阻塞队列为空时，返回null，不抛出异常\n    System.out.println(arrayBlockingQueue.poll());\n\n    //获取队首元素，当队首为空时，返回null\n    System.out.println(arrayBlockingQueue.peek());\n&#125;\n\n等待\n当队列已满时，插入元素一直处于等待状态\n当队列为空时，取出元素一直处于等待状态\n\n\n在等待过程中，有其他线程插入新元素或取出新元素，程序将正常进行取出或插入操作\n\npublic static void test3() throws InterruptedException &#123;\n    arrayBlockingQueue.put(\"1\");\n    arrayBlockingQueue.put(\"2\");\n    arrayBlockingQueue.put(\"3\");\n    //当队列已满时，将一直处于等待状态\n    //arrayBlockingQueue.put(\"4\");\n\n    System.out.println(arrayBlockingQueue.take());\n    System.out.println(arrayBlockingQueue.take());\n    System.out.println(arrayBlockingQueue.take());\n\n    /*new Thread(()->&#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(5);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        arrayBlockingQueue.add(\"4\");\n        System.out.println(Thread.currentThread().getName()+\"向队列中插入新元素\");\n    &#125;).start();*/\n\n    //当队列为空时，将一直处于阻塞状态\n    System.out.println(arrayBlockingQueue.take());\n&#125;\n\n超时等待\n当队列已满时，插入元素等待指定时间后返回false\n当队列为空时，取出元素等待指定时间后返回null\n\n\n当其他线程取出或插入数据后，程序将继续正常执行，并返回true或队首元素\n\npublic static void test4() throws InterruptedException &#123;\n    System.out.println(arrayBlockingQueue.offer(\"1\"));\n    System.out.println(arrayBlockingQueue.offer(\"2\"));\n    System.out.println(arrayBlockingQueue.offer(\"3\"));\n    //超时等待，当队列已满后，等待一段时间，超时后将返回false\n    System.out.println(arrayBlockingQueue.offer(\"4\",3,TimeUnit.SECONDS));\n\n    System.out.println(arrayBlockingQueue.poll());\n    System.out.println(arrayBlockingQueue.poll());\n    System.out.println(arrayBlockingQueue.poll());\n    //超时等待，当队列为空时，等待一段时间后，将超时返回null\n    System.out.println(arrayBlockingQueue.poll(3, TimeUnit.SECONDS));\n&#125;\n\n\n\nSynchronousQueue同步队列同步队列没有容量，不存储元素\n放进去一个元素后，必须等待取出来后，才能再往里面放元素\npublic static void main(String[] args) &#123;\n\n    SynchronousQueue&lt;String> synchronousQueue = new SynchronousQueue&lt;>();\n\n    new Thread(()->&#123;\n        try &#123;\n            System.out.println(Thread.currentThread().getName()+\"添加元素1\");\n            synchronousQueue.put(\"1\");\n            System.out.println(Thread.currentThread().getName()+\"添加元素2\");\n            synchronousQueue.put(\"2\");\n            System.out.println(Thread.currentThread().getName()+\"添加元素3\");\n            synchronousQueue.put(\"3\");\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;).start();\n\n\n    new Thread(()->&#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(3);\n            System.out.println(Thread.currentThread().getName()+\"获取元素\"+synchronousQueue.take());\n            TimeUnit.SECONDS.sleep(3);\n            System.out.println(Thread.currentThread().getName()+\"获取元素\"+synchronousQueue.take());\n            TimeUnit.SECONDS.sleep(3);\n            System.out.println(Thread.currentThread().getName()+\"获取元素\"+synchronousQueue.take());\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;).start();\n&#125;\n\n运行结果\nThread-0添加元素1\nThread-1获取元素1\nThread-0添加元素2\nThread-1获取元素2\nThread-0添加元素3\nThread-1获取元素3\n\n\n\n从结果中可以看出，同步队列必须要在配对之后（即一个存，一个取），写入的线程和读取的线程才会正常结束。\n\n线程池（重点）池化技术\n事先准备好一些资源，如果有人要用，就来池中拿来用，用完之后归还\n线程池、连接池、内存池、对象池。。。\n线程池的好处\n\n降低资源的消耗\n提高响应的速度\n方便管理\n\n线程复用、可以控制最大并发数、管理线程\n3大方法、7大参数、4种拒绝策略\n3大方法public static void main(String[] args) &#123;\n    //创建只有单个线程的线程池\n    ExecutorService threadPool = Executors.newSingleThreadExecutor();\n    //创建固定线程个数的线程池\n    ExecutorService threadPool = Executors.newFixedThreadPool(5);\n    //可伸缩的，线程数量可变的。CPU足够强时，则可以容纳更多线程\n    ExecutorService threadPool = Executors.newCachedThreadPool();\n    try &#123;\n        for (int i = 0; i &lt; 100; i++) &#123;\n            threadPool.execute(() -> &#123;\n                System.out.println(Thread.currentThread().getName() + \" OK\");\n            &#125;);\n        &#125;\n    &#125;finally &#123;\n        //程序运行结束，需要关闭线程池\n        threadPool.shutdown();\n    &#125;\n&#125;\n\n\n\n创建只有单个线程的线程池ExecutorService threadPool = Executors.newSingleThreadExecutor();\npool-1-thread-1 OK\npool-1-thread-1 OK\npool-1-thread-1 OK\npool-1-thread-1 OK\npool-1-thread-1 OK\npool-1-thread-1 OK\npool-1-thread-1 OK\npool-1-thread-1 OK\npool-1-thread-1 OK\npool-1-thread-1 OK\n创建固定线程个数的线程池ExecutorService threadPool = Executors.newFixedThreadPool(5);\npool-1-thread-1 OK\npool-1-thread-4 OK\npool-1-thread-5 OK\npool-1-thread-3 OK\npool-1-thread-2 OK\npool-1-thread-3 OK\npool-1-thread-5 OK\npool-1-thread-4 OK\npool-1-thread-1 OK\npool-1-thread-2 OK\n可伸缩的，线程数量可变的。CPU足够强时，则可以创建更多线程ExecutorService threadPool = Executors.newCachedThreadPool();\npool-1-thread-1 OK\npool-1-thread-4 OK\npool-1-thread-3 OK\npool-1-thread-2 OK\npool-1-thread-6 OK\npool-1-thread-5 OK\npool-1-thread-7 OK\npool-1-thread-8 OK\npool-1-thread-9 OK\npool-1-thread-10 OK\n\n7大参数newSingleThreadExecutor方法\npublic static ExecutorService newSingleThreadExecutor() &#123;\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue&lt;Runnable>()));\n&#125;\n\nnewFixedThreadPool方法\npublic static ExecutorService newFixedThreadPool(int nThreads) &#123;\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue&lt;Runnable>());\n&#125;\n\nnewCachedThreadPool方法\npublic static ExecutorService newCachedThreadPool() &#123;\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,  //约21亿个线程，会造成OOM\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue&lt;Runnable>());\n&#125;\n\n\n\n通过查看三种创建线程的方法可以得知，其实都是new了ThreadPoolExecutor，那么在ThreadPoolExecutor的构造方法中，就可以看到7大参数了。\npublic ThreadPoolExecutor(int corePoolSize,\t\t\t//核心线程大小\n                          int maximumPoolSize,\t//最大线程大小\n                          long keepAliveTime,\t\t//空闲存活时间\n                          TimeUnit unit,\t\t\t\t//时间单位\n                          BlockingQueue&lt;Runnable> workQueue,\t//阻塞队列\n                          ThreadFactory threadFactory,\t\t\t\t//线程工厂\n                          RejectedExecutionHandler handler) &#123;\t//拒绝策略\n    if (corePoolSize &lt; 0 ||\n        maximumPoolSize &lt;= 0 ||\n        maximumPoolSize &lt; corePoolSize ||\n        keepAliveTime &lt; 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.acc = System.getSecurityManager() == null ?\n            null :\n            AccessController.getContext();\n    this.corePoolSize = corePoolSize;\n    this.maximumPoolSize = maximumPoolSize;\n    this.workQueue = workQueue;\n    this.keepAliveTime = unit.toNanos(keepAliveTime);\n    this.threadFactory = threadFactory;\n    this.handler = handler;\n&#125;\n\n\n\n参数解释\n\ncorePoolSize：核心线程大小，线程池创建后就创建的线程个数\nmaximumPoolSize：最大线程大小，线程池创建的最大线程个数\nkeepAliveTime：空闲存活时间，核心线程以外的线程多久没有执行任务之后，将进行线程的资源回收，释放线程\nUnit：时间单位\nworkQueue：阻塞队列，用于存放等待执行的任务\nthreadFactory：线程工厂，创建新线程时使用的工厂\nhandler：拒绝策略，线程池达到最大线程并且阻塞队列已满后，再添加执行任务时的决绝策略\n\n线程池创建后，首先创建核心线程大小的线程数；新加进来的任务存在阻塞队列中，当阻塞队列满了之后，线程池开启新的线程执行任务，直到线程数量达到最大线程数。当达到最大线程数量之后，阻塞队列再次满了之后，将使用给定的拒绝策略来拒绝新加入的任务。\n手动new一个线程池\npublic static void main(String[] args) &#123;\n\n    ThreadPoolExecutor threadPool = new ThreadPoolExecutor(\n            2,\t\t\t//核心线程数\n            5,\t\t\t//最大线程数\n            10,\t\t\t//空闲存活时间\n            TimeUnit.SECONDS,\t//时间单位\n            new LinkedBlockingQueue&lt;>(3),\t//阻塞队列，用于存放任务\n            Executors.defaultThreadFactory(), \t//线程工厂\n            new ThreadPoolExecutor.AbortPolicy()//拒绝策略\n    );\n\n\n    try &#123;\n        for (int i = 0; i &lt; 9; i++) &#123;\n            threadPool.execute(() -> &#123;\n                System.out.println(Thread.currentThread().getName() + \" OK\");\n            &#125;);\n        &#125;\n    &#125;finally &#123;\n        //程序运行结束，需要关闭线程池\n        threadPool.shutdown();\n    &#125;\n\n\n&#125;\n\n\n\n当线程数（即上面代码中的i）为2时，使用核心线程执行任务\npool-1-thread-1 OK\npool-1-thread-2 OK\n\n当线程数为3-5时，使用核心线程执行任务，并将新的任务放在等待队列中\npool-1-thread-1 OK\npool-1-thread-2 OK\npool-1-thread-1 OK\npool-1-thread-2 OK\npool-1-thread-1 OK\n\n当线程数为6-8时，开启新的线程执行任务，直到达最大线程数\npool-1-thread-1 OK\npool-1-thread-3 OK\npool-1-thread-1 OK\npool-1-thread-2 OK\npool-1-thread-1 OK\npool-1-thread-3 OK\npool-1-thread-5 OK\npool-1-thread-4 OK\n\n当线程数超过8时，在最大线程数+等待队列大小个任务之后加入的任务，抛出异常（这里根据拒绝策略执行，下面讲）\npool-1-thread-1 OK\npool-1-thread-3 OK\npool-1-thread-1 OK\npool-1-thread-2 OK\npool-1-thread-5 OK\npool-1-thread-1 OK\npool-1-thread-3 OK\npool-1-thread-4 OK\nException in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task top.doubly.threadPool.ThreadPoolDemo01$$Lambda$1&#x2F;381259350@3feba861 rejected from java.util.concurrent.ThreadPoolExecutor@5b480cf9[Running, pool size &#x3D; 5, active threads &#x3D; 0, queued tasks &#x3D; 0, completed tasks &#x3D; 8]\n\tat java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)\n\tat java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)\n\tat java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)\n\tat top.doubly.threadPool.ThreadPoolDemo01.main(ThreadPoolDemo01.java:28)\n\n\n\n4大拒绝策略\nAbortPolicy\n抛出异常\nThreadPoolExecutor threadPool = new ThreadPoolExecutor(\n        2,\n        5,\n        10,\n        TimeUnit.SECONDS,\n        new LinkedBlockingQueue&lt;>(3),\n        Executors.defaultThreadFactory(),\n        new ThreadPoolExecutor.AbortPolicy()\n);\n\npool-1-thread-1 OK\npool-1-thread-3 OK\npool-1-thread-1 OK\npool-1-thread-2 OK\npool-1-thread-5 OK\npool-1-thread-1 OK\npool-1-thread-3 OK\npool-1-thread-4 OK\nException in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task top.doubly.threadPool.ThreadPoolDemo01$$Lambda$1&#x2F;381259350@3feba861 rejected from java.util.concurrent.ThreadPoolExecutor@5b480cf9[Running, pool size &#x3D; 5, active threads &#x3D; 0, queued tasks &#x3D; 0, completed tasks &#x3D; 8]\n\tat java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)\n\tat java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)\n\tat java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)\n\tat top.doubly.threadPool.ThreadPoolDemo01.main(ThreadPoolDemo01.java:28)\n\n\n\n\nCallerRunsPolicy\n哪来的任务回哪儿去，交给原来的线程去执行\nThreadPoolExecutor threadPool = new ThreadPoolExecutor(\n        2,\n        5,\n        10,\n        TimeUnit.SECONDS,\n        new LinkedBlockingQueue&lt;>(3),\n        Executors.defaultThreadFactory(),\n        new ThreadPoolExecutor.CallerRunsPolicy()\n);\n\npool-1-thread-3 OK\npool-1-thread-2 OK\npool-1-thread-4 OK\npool-1-thread-1 OK\n# main方法执行\nmain OK\npool-1-thread-5 OK\npool-1-thread-3 OK\npool-1-thread-2 OK\npool-1-thread-4 OK\n\n\n\nDiscardPolicy\n丢弃任务，不抛出异常\nThreadPoolExecutor threadPool = new ThreadPoolExecutor(\n        2,\n        5,\n        10,\n        TimeUnit.SECONDS,\n        new LinkedBlockingQueue&lt;>(3),\n        Executors.defaultThreadFactory(),\n        new ThreadPoolExecutor.DiscardPolicy()\n);\n\n#丢弃了一个任务，没有执行\npool-1-thread-2 OK\npool-1-thread-3 OK\npool-1-thread-1 OK\npool-1-thread-5 OK\npool-1-thread-4 OK\npool-1-thread-3 OK\npool-1-thread-1 OK\npool-1-thread-2 OK\n\n\n\nDiscardOldestPolicy\n和最老的线程竞争，竞争成功则执行，竞争失败则丢弃，不抛出异常\nThreadPoolExecutor threadPool = new ThreadPoolExecutor(\n        2,\n        5,\n        10,\n        TimeUnit.SECONDS,\n        new LinkedBlockingQueue&lt;>(3),\n        Executors.defaultThreadFactory(),\n        new ThreadPoolExecutor.DiscardOldestPolicy()\n);\n\n\n\n线程池的最大线程池如何设置（调优）两种设置方法：\n\nCPU密集型\nIO密集型\n\nCPU密集型\n根据CPU的最大核数，设置最大的线程数。保证CPU最大效率运行。\n//获取当前CPU的核心数量\nSystem.out.println(Runtime.getRuntime().availableProcessors());\n\n\n\nIO密集型\n获取当前任务中比较占用IO的任务个数，大于等于该数，保证不会阻塞\n函数式接口只有一个方法的接口叫做函数式接口\n四大原生函数接口\n\nFunction函数型接口\n\npublic static void main(String[] args) &#123;\n    /*Function&lt;String, String> function = new Function&lt;String, String>() &#123;\n        @Override\n        public String apply(String s) &#123;\n            return s;\n        &#125;\n    &#125;;*/\n    //Function&lt;String, String> function = (str) -> &#123;return str;&#125;;\n    Function&lt;String, String> function = str -> str;\n    System.out.println(function.apply(\"sdf\"));\n&#125;\n\n\n\nPredicate断定型接口\n\npublic static void main(String[] args) &#123;\n    //写一个方法判断字符串是否为空\n    /*Predicate&lt;String> predicate = new Predicate&lt;String>() &#123;\n        @Override\n        public boolean test(String s) &#123;\n            return s==null || s.isEmpty();\n        &#125;\n    &#125;;*/\n\n    //lambda简化\n    Predicate&lt;String> predicate = s -> s==null || s.isEmpty();\n\n    System.out.println(predicate.test(\"\"));\n&#125;\n\n\n\nConsumer消费型接口，只有输入，没有返回值\n\npublic static void main(String[] args) &#123;\n    /*Consumer&lt;String> consumer = new Consumer&lt;String>() &#123;\n        @Override\n        public void accept(String o) &#123;\n            System.out.println(o);\n        &#125;\n    &#125;;*/\n\n    //Consumer&lt;String> consumer = s-> System.out.println(s);\n    Consumer&lt;String> consumer = System.out::println;\n\n    consumer.accept(\"sdf\");\n&#125;\n\nSupplier供给型接口，没有参数，只有返回值\n\npublic static void main(String[] args) &#123;\n    /*Supplier&lt;String> supplier = new Supplier&lt;String>() &#123;\n        @Override\n        public String get() &#123;\n            return \"sdf\";\n        &#125;\n    &#125;;*/\n    Supplier&lt;String> supplier = ()->\"123\";\n    System.out.println(supplier.get());\n&#125;\n\n\n\nStream流式计算public static void main(String[] args) &#123;\n    User a = new User(1, \"a\", 21);\n    User b = new User(2, \"b\", 22);\n    User c = new User(3, \"c\", 23);\n    User d = new User(4, \"d\", 24);\n    User f = new User(6, \"f\", 25);\n    List&lt;User> users = Arrays.asList(a,b,c,d,f);\n\n    users.stream()\n            //取ID为偶数的用户\n            .filter(x -> x.getId() % 2 == 0)\n            //取年龄大于23的用户\n            .filter(x -> x.getAge() > 23)\n            //将对象的名字转为大写\n            .peek(x -> x.setName(x.getName().toUpperCase()))\n            //将用户按名称倒序排序\n            .sorted((u1,u2)->u2.getName().compareTo(u1.getName()))\n            //取一个用户\n            .limit(1)\n            //遍历打印\n            .forEach(System.out::println);\n\n&#125;\n\n\n\nForkJoin什么是ForkJoin？\nForkJoin在JDK1.7中出来，并行执行任务！提高效率，大数据量！亿级别。\n大数据：Map Reduce（把打任务拆分成小任务）\n特点\n工作窃取。比如A线程和B线程同时执行一堆任务，当B线程的任务执行完成后，会从A线程的任务中取出任务来执行，这个叫做工作窃取。\n举例：计算1~1000_0000_0000的和\npublic class Test &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        test1();\n        test2();\n        test3();\n    &#125;\n\n    //普通计算方法\n    public static void test1()&#123;\n        long start = System.currentTimeMillis();\n        long sum = 0;\n        for (long i = 1; i &lt;= 1000_0000_0000L; i++) &#123;\n            sum += i;\n        &#125;\n        long end = System.currentTimeMillis();\n        System.out.print(\"计算结果：\"+sum);\n        System.out.println(\" 耗时：\"+(end-start)*1.0/1000+\"s\");\n    &#125;\n\n    //使用ForkJoin计算\n    public static void test2() throws ExecutionException, InterruptedException &#123;\n        long start = System.currentTimeMillis();\n        ForkJoinPool forkJoinPool = new ForkJoinPool();\n        ForkJoinTask&lt;Long> res = forkJoinPool.submit(new ForkJoinDemo(0L,1000_0000_0000L,10000L));\n        Long sum = res.get();\n        long end = System.currentTimeMillis();\n        System.out.print(\"计算结果：\"+ sum);\n        System.out.println(\" 耗时：\"+(end-start)*1.0/1000+\"s\");\n    &#125;\n\n    //使用Stream并行流\n    public static void test3()&#123;\n        long start = System.currentTimeMillis();\n\n        long sum = LongStream.rangeClosed(0L, 1000_0000_0000L).parallel().reduce(0, Long::sum);\n\n        long end = System.currentTimeMillis();\n        System.out.print(\"计算结果：\"+ sum);\n        System.out.println(\" 耗时：\"+(end-start)*1.0/1000+\"s\");\n    &#125;\n&#125;\n\n任务类：\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class ForkJoinDemo extends RecursiveTask&lt;Long> &#123;\n    private Long start;\n    private Long end;\n\n    //临界值\n    private Long temp;\n\n\n    @Override\n    protected Long compute() &#123;\n        //如果计算量大于了临界值，就使用ForkJoin进行计算\n        if(end-start > temp)&#123;\n            //取一个中间值，将计算任务分成两部分\n            long middle = start + (end - start) / 2;\n            ForkJoinDemo task1 = new ForkJoinDemo(start, middle, 10000L);\n            //把任务压入线程队列\n            task1.fork();\n            ForkJoinDemo task2 = new ForkJoinDemo(middle+1, end, 10000L);\n            task2.fork();\n\n            return task1.join() + task2.join();\n        &#125;else&#123;\n            //否则使用普通的方法进行计算\n            long sum = 0;\n            for (long i = start; i &lt;= end ; i++) &#123;\n                sum += i;\n            &#125;\n            return sum;\n        &#125;\n    &#125;\n&#125;\n\n运行结果\n计算结果：932356074711512064 耗时：54.723s\n计算结果：932356074711512064 耗时：18.843s\n计算结果：932356074711512064 耗时：12.126s\n\n\n\n\n异步回调\nFuture设计的初衷：对将来某个事件的结果进行建模\n\nFuture接口有个实现类，CompletableFuture类，可以实现异步回调。与Ajax类似，有如下功能：\n\n异步执行\n成功回调\n失败回调\n\n举两个栗子\n\n没有返回值的异步回调（runAsync()）\n\npublic class FutureDemo &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        //Void是关键字void的封装类，表示没有返回结果\n        CompletableFuture&lt;Void> voidCompletableFuture = CompletableFuture.runAsync(() -> &#123;\n            try &#123;\n                TimeUnit.SECONDS.sleep(2);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            System.out.println(Thread.currentThread().getName());\n        &#125;);\n        System.out.println(\"1111\");\n        //阻塞获取返回值\n        voidCompletableFuture.get();\n    &#125;\n&#125;\n\n\nVoid是void关键字的封装类，表示没有返回值\n\n运行结果\n1111\nForkJoinPool.commonPool-worker-1\n\n\nvoidCompletableFuture.get();起到了阻塞获取返回值的作用，虽然这里没有返回值，但主线程依然会被阻塞，直到异步程序执行完成。如果这里不阻塞，程序将直接结束，不会打印出线程名。\n\n\n有返回值的异步回调（supplyAsync()）\n\npublic class FutureDemo2 &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n\n        Integer integer = CompletableFuture.supplyAsync(() -> &#123;\n            System.out.println(Thread.currentThread().getName());\n            //int i = 1/0;\n            return 1024;\n        &#125;).whenComplete((t, u) -> &#123;\n            System.out.println(\"T:\" + t);\n            System.out.println(\"U:\" + u);\n        &#125;).exceptionally((e) -> &#123;\n            System.out.println(e.getMessage());\n            return 500;\n        &#125;).get();\n\n        System.out.println(integer);\n\n    &#125;\n&#125;\n\n运行结果\nForkJoinPool.commonPool-worker-1\nT:1024\nU:null\n1024\n\n或\nForkJoinPool.commonPool-worker-1\nT:null\nU:java.util.concurrent.CompletionException: java.lang.ArithmeticException: &#x2F; by zero\njava.lang.ArithmeticException: &#x2F; by zero\n500\n\n\n参数解释\nwhenComplete方法\nT: 成功执行的返回值\nU: 执行失败的返回值\nexceptionally方法\ne: 执行时的异常信息\n\nJMM 什么是JMM？\n是Java的内存模型，是一个概念，不存在的东西\n关于JMM的一些同步的约定\n\n线程解锁前，必须把共享变量like刷回主内存\n线程加锁前，必须读取主存中的最新值到工作内存中\n加锁和解锁是同一把锁\n\nJMM的八种操作（每种操作都是原子操作）\n\nread 从主存中读取变量\nLoad 将读取的变量加载到线程的工作内存中\nuse 线程的执行引擎使用变量\nassign 执行引擎将变量的值重新赋值到工作内存中\nstore 从工作内存中取得变量\nWrite 将工作内存中取得的变量写入到主存中\nLock 作用于主存，将变量标识为线程独占\nUnlock 作用与主存，将变量释放，释放后才可以被其他线程独占\n\n\n对八种操作的规则\n\n不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write\n不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存\n不允许一个线程将没有assign的数据从工作内存同步回主内存\n一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作\n一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁\n如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值\n如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量\n对一个变量进行unlock操作之前，必须把此变量同步回主内存\n\nVolatile请你谈谈对Volatile的理解？\nVolatile是Java虚拟机提供的轻量级的同步机制\n\n保证可见性\n\npublic class volatileDemo &#123;\n\n    //不加volatile，程序就会死循环\n    //加了volatile，程序就会自动终止\n    public volatile static int num = 0;\n\n    public static void main(String[] args) &#123;\n\n        new Thread(()->&#123;\n            while (num==0)&#123;\n                //打印也会导致程序停止\n                //System.out.println(Thread.currentThread().getName());\n            &#125;\n        &#125;).start();\n\n        try &#123;\n            TimeUnit.SECONDS.sleep(1);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        System.out.println(1);\n\n        num = 1;\n\n    &#125;\n&#125;\n\n\n不加volatile，程序就会死循环，因为main线程改变num时，循环线程感知不到。\n加了volatile，程序就会正常退出，可以保证可见性\n\n\n不保证原子性\n\n禁止指令重排\n\n\n","categories":["Java"],"tags":["JUC"]},{"title":"Lambda表达式","url":"/post/Java/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F.html","content":"在jdk8中，为了简化代码，减少不必要的代码，推出了Lambda表达式\n变化过程演示\n定义函数式接口\n\n\n函数式接口：只有一个方法的接口，成为函数式接口。\n只有函数式接口，才可以用Lambda实现\n\ninterface ILike&#123;\n    public void print();\n&#125;\n\n\n\n\n实现类\n\n首先按照最原始的写法，实现接口\nclass Like implements ILike&#123;\n    @Override\n    public void print() &#123;\n        System.out.println(\"I Like lambda.\");\n    &#125;\n&#125;\n\n在Main方法中运行\npublic static void main(String[] args)&#123;\n    ILike like = new Like();\n    like.print();\n&#125;\n\n\n\n\n静态内部类\n\n有时候定义的类只会在一个类中使用，新建一个类会显得比较麻烦。于是可以将类放在类内部，便可以定义成静态内部类。\nstatic class Like2 implements ILike&#123;\n    @Override\n    public void print() &#123;\n        System.out.println(\"I Like lambda2.\");\n    &#125;\n&#125;\n\n在Main方法中运行\npublic static void main(String[] args)&#123;\n    ILike like = new Like2();\n    like.print();\n&#125;\n\n\n\n\n局部内部类\n\n有时候定义的类只会被使用一次，若全部都写成静态内部类，则会看起来比较凌乱、臃肿，代码不够优雅。于是便可以将类定义成局部内部类，卸载main方法或其他方法中\npublic static void main(String[] args) &#123;\n    //4. 局部内部类\n    class Like3 implements ILike&#123;\n        @Override\n        public void print() &#123;\n            System.out.println(\"I Like lambda3\");\n        &#125;\n    &#125;\n    ILike like = new Like3();\n    like.print();\n&#125;\n\n\n\n\n匿名内部类\n\n相对与局部内部类可以做进一步的简化，写成匿名内部类。省略了class与类名，直接new 接口\npublic static void main(String[] args) &#123;\n    //5. 匿名内部类\n    ILike like = new ILike() &#123;\n            @Override\n            public void print() &#123;\n                System.out.println(\"I like lambda4,\");\n            &#125;\n        &#125;;\n    like.print();\n&#125;\n\n\n\n\nLambda表达式\n\n在JDK8中，为了进一步简化，提供了lambda表达式进行简化。去掉了重复的内容，只保留了参数和方法体。\npublic static void main(String[] args) &#123;\n    //6. Lambda表达式\n    ILike like = () -> &#123;\n        System.out.println(\"I like lambda5.\");\n    &#125;;\n    like.print();\n&#125;\n\n\n注意：Lambda表达式只保留了参数和方法体，而为了简化，方法体并未指明实现的是哪一个方法，所以Lambda表达式只能实现函数式接口。\n\n带参数写法定义函数式接口\ninterface ILove&#123;\n    void love(int a);\n&#125;\n\n\n\n\n用Lambda简化\n\npublic static void main(String[] args)&#123;\n    ILove love = (int a) -> &#123;\n        System.out.println(a);\n        //love = System.out::println;\n    &#125;\n    love.love(3);\n&#125;\n\n\n\n\n简化参数类型\n\npublic static void main(String[] args)&#123;\n    ILove love = (a) -> &#123;\n        System.out.println(a);\n    &#125;\n    love.love(4);\n&#125;\n\n\n注意：多个参数也可以去掉参数类型，要去掉的话必须都去掉\n\n\n简化括号\n\npublic static void main(String[] args)&#123;\n    ILove love = a -> &#123;\n        System.out.println(a);\n    &#125;\n    love.love(5);\n&#125;\n\n\n注意：多个参数不可以去掉\n\n\n简化花括号\n\npublic static void main(String[] args)&#123;\n    ILove love = a -> System.out.println(a);\n    love.love(6);\n&#125;\n\n\n注意：花括号只有在方法体只有一条语句（比如这里的System.out.println(a);）时才可以被简化，当方法体中有多个语句时不可以被简化。\n\n","categories":["Java"],"tags":["Lambda"]},{"title":"GreedySnake","url":"/post/Java/GreedySnake.html","content":"项目地址https://gitee.com/doubly/Study.git\n在地址中的JavaGUI项目中\n","categories":[],"tags":[]},{"title":"SWing","url":"/post/Java/SWing.html","content":"常见控件JFrame窗体public class JFrameTest &#123;\n\n    public void init()&#123;\n        JFrame jFrame = new JFrame(\"这是一个标题\");\n        jFrame.setVisible(true);\n        jFrame.setBounds(200,200,200,200);\n        //JFrame中这样设置颜色无效，需要获取容器并设置容器的颜色\n        jFrame.setBackground(Color.green);\n\n        //获取容器，并设置颜色\n        Container container = jFrame.getContentPane();\n        container.setBackground(Color.yellow);\n\n        //设置关闭事件\n        jFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        JLabel jLabel = new JLabel(\"这是一个Label标签\");\n        jFrame.add(jLabel);\n        //设置标签居中对齐\n        jLabel.setHorizontalAlignment(SwingConstants.CENTER);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new JFrameTest().init();\n    &#125;\n&#125;\n\n\n注意一：\nJFrame中直接设置颜色是无效的，需要获取容器并设置容器的颜色\n\nJDialog弹窗public class JDialogTest &#123;\n    public static void main(String[] args) &#123;\n        DialogDemo dialogDemo = new DialogDemo();\n    &#125;\n&#125;\n\n//主窗口\nclass DialogDemo extends JFrame&#123;\n    public DialogDemo() throws HeadlessException &#123;\n        this.setVisible(true);\n        this.setBounds(200,200,200,200);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        //JFrame放东西，容器\n        Container container = getContentPane();\n        //设置绝对定位\n        container.setLayout(null);\n\n        JButton button = new JButton(\"点击打开弹窗\");\n        button.setSize(150,50);\n\n        button.addActionListener(new ActionListener() &#123;\n            private MyDialog dialog = new MyDialog();\n            @Override\n            public void actionPerformed(ActionEvent e) &#123;\n                if(dialog.isVisible())&#123;\n                    dialog.setVisible(false);\n                &#125;else&#123;\n                    dialog.setVisible(true);\n                &#125;\n                System.out.println(dialog.hashCode());\n            &#125;\n        &#125;);\n\n        container.add(button);\n    &#125;\n&#125;\n\n//弹窗的窗口\nclass MyDialog extends JDialog&#123;\n    public MyDialog() &#123;\n        setVisible(true);\n        setBounds(300,300,300,300);\n        //setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n        JLabel label = new JLabel(\"lalalalala\");\n        Container container = getContentPane();\n        container.add(label);\n    &#125;\n&#125;\n\n\n在弹窗中如果设置setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);，即设置了弹窗的关闭方式为退出时，程序会抛出如下异常。\nException in thread \"AWT-EventQueue-0\" java.lang.IllegalArgumentException: defaultCloseOperation must be one of: DO_NOTHING_ON_CLOSE, HIDE_ON_CLOSE, or DISPOSE_ON_CLOSE\n\tat javax.swing.JDialog.setDefaultCloseOperation(JDialog.java:755)\n\tat gui.MyDialog.&lt;init>(JDialogTest.java:45)\n\tat gui.DialogDemo$1.actionPerformed(JDialogTest.java:32)\n\tat javax.swing.AbstractButton.fireActionPerformed(AbstractButton.java:2022)\n\tat javax.swing.AbstractButton$Handler.actionPerformed(AbstractButton.java:2348)\n\tat javax.swing.DefaultButtonModel.fireActionPerformed(DefaultButtonModel.java:402)\n\tat javax.swing.DefaultButtonModel.setPressed(DefaultButtonModel.java:259)\n\n\n几种关闭窗口方式比较：\n\nDO_NOTHING_ON_CLOSE：不响应关闭操作\nHIDE_ON_CLOSE：点击关闭按钮隐藏窗口（进程仍然存在）\nDISPOSE_ON_CLOSE：销毁窗口，当JVM最后一个窗口被销毁，则JVM停止\nEXIT_ON_CLOSE：停止JVM，所有窗口均被关闭\n\n\nJLabel标签\n普通标签\n\nJLabel label = new JLabel(\"lalalalala\");\n\n\n图标标签\n\npublic class JLabelTest &#123;\n    public static void main(String[] args) &#123;\n        JFrame frame = new JFrame(\"图标测试\");\n        frame.setBounds(300,300,300,300);\n        IconDemo icon = new IconDemo(10, 10);\n        JLabel label = new JLabel(\"图标Label\", icon, SwingConstants.LEFT);\n        frame.add(label);\n\n        frame.setVisible(true);\n        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    &#125;\n&#125;\n\nclass IconDemo implements Icon&#123;\n\n    private int width;\n    private int height;\n\n    public IconDemo() &#123;\n    &#125;\n\n    public IconDemo(int width, int height) throws HeadlessException &#123;\n        this.width = width;\n        this.height = height;\n    &#125;\n\n    @Override\n    public void paintIcon(Component c, Graphics g, int x, int y) &#123;\n        g.fillOval(x,y,width,height);\n    &#125;\n\n    @Override\n    public int getIconWidth() &#123;\n        return this.width;\n    &#125;\n\n    @Override\n    public int getIconHeight() &#123;\n        return this.height;\n    &#125;\n&#125;\n\n\n\n图片标签\n\npublic class JLabelTest &#123;\n    public static void main(String[] args) &#123;\n        JFrame frame = new JFrame(\"图标测试\");\n        frame.setBounds(300,300,300,300);\n\n        //IconDemo icon = new IconDemo(10, 10);\n        //URL url = JLabelTest.class.getResource(\"HeadPhoto.jpg\");\n        URL url = JLabelTest.class.getClassLoader().getResource(\"gui/HeadPhoto.jpg\");\n        //图片图标\n        ImageIcon icon = new ImageIcon(url);\n        JLabel label = new JLabel(\"图片Label\", icon, SwingConstants.LEFT);\n        frame.add(label);\n\n        frame.setVisible(true);\n        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    &#125;\n&#125;\n\n\nJPanel面板\n普通面板\n\npublic class JPanelTest &#123;\n    public static void main(String[] args) &#123;\n        JFrame frame = new JFrame(\"JPanel测试\");\n        frame.setBounds(300,300,300,300);\n        Container container = frame.getContentPane();\n        //设置间距\n        container.setLayout(new GridLayout(2,2,10,10));\n        JPanel panel = new JPanel(new GridLayout(1, 3));\n        JPanel panel2 = new JPanel(new GridLayout(1, 2));\n        JPanel panel3 = new JPanel(new GridLayout(2, 1));\n        JPanel panel4 = new JPanel(new GridLayout(2, 2));\n\n        panel.add(new JButton(\"1\"));\n        panel.add(new JButton(\"1\"));\n        panel.add(new JButton(\"1\"));\n        panel2.add(new JButton(\"1\"));\n        panel2.add(new JButton(\"1\"));\n        panel3.add(new JButton(\"1\"));\n        panel3.add(new JButton(\"1\"));\n        panel4.add(new JButton(\"1\"));\n        panel4.add(new JButton(\"1\"));\n        panel4.add(new JButton(\"1\"));\n        panel4.add(new JButton(\"1\"));\n\n        container.add(panel);\n        container.add(panel2);\n        container.add(panel3);\n        container.add(panel4);\n\n        frame.setVisible(true);\n        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    &#125;\n&#125;\n\n\n\n滚动面板\n\n当内容大小超过面板大小时，就会出现滚动条\npublic static void main(String[] args) &#123;\n    JFrame frame = new JFrame(\"JPanel测试\");\n    frame.setBounds(300,300,300,300);\n    Container container = frame.getContentPane();\n\n    JTextArea textArea = new JTextArea(20, 50);\n    textArea.setText(\"欢迎来进行GUI的学习\");\n\n    JScrollPane scrollPane = new JScrollPane(textArea);\n    container.add(scrollPane);\n\n    frame.setVisible(true);\n    frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n&#125;\n\n\n按钮JButton图片按钮class JButtonDemo1 extends MyJButtonFrame&#123;\n    public JButtonDemo1() throws HeadlessException &#123;\n        Container container = getContentPane();\n\n        URL url = this.getClass().getResource(\"HeadPhoto.jpg\");\n        ImageIcon imageIcon = new ImageIcon(url);\n\n        JButton button = new JButton();\n        button.setSize(20,10);\n        //设置按钮图标\n        button.setIcon(imageIcon);\n        //设置按钮提示文本\n        button.setToolTipText(\"这个是鼠标悬浮提示\");\n\n        container.add(button);\n    &#125;\n&#125;\n\n\nJRadioButton单选按钮//单选按钮\nclass JButtonDemo2 extends MyJButtonFrame&#123;\n    public JButtonDemo2() throws HeadlessException &#123;\n        //单选框\n        JRadioButton radioButton1 = new JRadioButton(\"男\");\n        JRadioButton radioButton2 = new JRadioButton(\"女\");\n        JRadioButton radioButton3 = new JRadioButton(\"保密\");\n        //将单选框分组，实现只能选一个\n        ButtonGroup buttonGroup = new ButtonGroup();\n        buttonGroup.add(radioButton1);\n        buttonGroup.add(radioButton2);\n        buttonGroup.add(radioButton3);\n\n        Container container = getContentPane();\n        container.add(radioButton1,BorderLayout.NORTH);\n        container.add(radioButton2,BorderLayout.CENTER);\n        container.add(radioButton3,BorderLayout.SOUTH);\n    &#125;\n&#125;\n\n\nJCheckBox多选按钮class JButtonDemo3 extends MyJButtonFrame&#123;\n    public JButtonDemo3() throws HeadlessException &#123;\n        JCheckBox checkBox1 = new JCheckBox(\"羽毛球\");\n        JCheckBox checkBox2 = new JCheckBox(\"乒乓球\");\n        JCheckBox checkBox3 = new JCheckBox(\"篮球\");\n\n        Container container = getContentPane();\n        container.add(checkBox1,BorderLayout.NORTH);\n        container.add(checkBox2,BorderLayout.CENTER);\n        container.add(checkBox3,BorderLayout.SOUTH);\n    &#125;\n&#125;\n\n\n列表JComboBox下拉框class ComboboxDemo1 extends MyJFrame&#123;\n    public ComboboxDemo1() throws HeadlessException &#123;\n        super(\"Combobox\");\n\n        JComboBox&lt;String> comboBox = new JComboBox&lt;>();\n        comboBox.addItem(null);\n        comboBox.addItem(\"正在热映\");\n        comboBox.addItem(\"已下架\");\n        comboBox.addItem(\"即将上映\");\n\n        this.getContainer().add(comboBox);\n\n    &#125;\n&#125;\n\n\nJList列表框class ComboboxDemo2 extends MyJFrame&#123;\n    public ComboboxDemo2() throws HeadlessException &#123;\n        super(\"Combobox\");\n\n        String[] arr = new String[]&#123;\"1\",\"2\",\"3\"&#125;;\n        JList&lt;String> list = new JList&lt;>(arr);\n        this.getContainer().add(list);\n\n    &#125;\n&#125;\n\n\n文本框JTextField文本框JTextField field = new JTextField(\"Hello\",20);\nJTextField field2 = new JTextField(\"World\",10);\nframe.getContainer().add(field,BorderLayout.NORTH);\nframe.getContainer().add(field2, BorderLayout.SOUTH);\n\n\nJPasswordField密码框JPasswordField passwordField = new JPasswordField();\npasswordField.setEchoChar('3');//默认替换字符为·\nframe.getContainer().add(passwordField);\n\n\nJTextArea文本域JTextArea textArea = new JTextArea();\ntextArea.setText(\"Hello 18W\");\n\nJScrollPane jScrollPane = new JScrollPane(textArea);\nframe.getContainer().add(jScrollPane)\n\n\n","categories":["Java"],"tags":["GUI","SWing"]},{"title":"AWT","url":"/post/Java/AWT.html","content":"\nGUI：图形化界面编程\n\nAWT简介Abstract Windows Tools（抽象的窗口工具）\nFrame基本代码\npublic class FrameTest &#123;\n    public static void main(String[] args) &#123;\n        Frame frame = new Frame(\"我的第一个Java图形界面窗口\");\n        //设置窗口可见性\n        frame.setVisible(true);\n        //设置窗口大小\n        frame.setSize(300,300);\n        //设置窗口背景颜色\n        frame.setBackground(new Color(85,150,69));\n        //设置窗口位置\n        frame.setLocation(300,300);\n        //设置大小固定\n        frame.setResizable(false);\n    &#125;\n&#125;\n\n\n展示多个窗口\npublic class FrameTest2 &#123;\n    public static void main(String[] args) &#123;\n        MyFrame frame1 = new MyFrame(100,100,200,200, Color.green);\n        MyFrame frame2 = new MyFrame(300,100,200,200, Color.blue);\n        MyFrame frame3 = new MyFrame(100,300,200,200, Color.yellow);\n        MyFrame frame4 = new MyFrame(300,300,200,200, Color.red);\n    &#125;\n&#125;\n\nclass MyFrame extends Frame&#123;\n    //可能存在多个窗口，我们需要一个计数器\n    static int id = 0;\n\n    public MyFrame(int x, int y, int w ,int h,Color color)&#123;\n        super(\"MyFrame\"+(++id));\n        setBounds(x, y, w, h);\n        setBackground(color);\n        setVisible(true);\n    &#125;\n&#125;\n\n\nPanelPanel可以堪称一个容器，但是不能单独存在\npublic class PanelTest &#123;\n    public static void main(String[] args) &#123;\n        Frame frame = new Frame(\"我的窗口\");\n        //存在布局的概念\n        Panel panel = new Panel();\n\n        //设置布局\n        frame.setLayout(null);\n        frame.setVisible(true);\n        frame.setBounds(300,300,500,500);\n        frame.setBackground(Color.green);\n\n        //panel设置坐标，型对于Frame\n        panel.setBounds(50,50,400,400);\n        panel.setBackground(Color.red);\n\n        //将面板放入Frame中\n        frame.add(panel);\n        \n        //监听事件，监听窗口关闭事件\n        //适配器模式\n        frame.addWindowListener(new WindowAdapter() &#123;\n            @Override\n            public void windowClosing(WindowEvent e) &#123;\n                System.exit(0);\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n\n\n布局管理器流式布局public class FlowLayoutTest &#123;\n    public static void main(String[] args) &#123;\n        Frame frame = new Frame();\n\n        //新建按钮\n        Button btn1 = new Button(\"btn1\");\n        Button btn2 = new Button(\"btn2\");\n        Button btn3 = new Button(\"btn3\");\n\n        //设置流式布局\n        //frame.setLayout(new FlowLayout());\n        frame.setLayout(new FlowLayout(FlowLayout.LEFT));\n        frame.setBounds(100,100,200,200);\n        frame.setVisible(true);\n\n        //添加按钮到Frame中\n        frame.add(btn1);\n        frame.add(btn2);\n        frame.add(btn3);\n    &#125;\n&#125;\n\n\n居中布局\n\n\n\n靠左布局\n\n\n东西南北中public class FlowLayoutTest2 &#123;\n    public static void main(String[] args) &#123;\n        Frame frame = new Frame();\n\n        //新建按钮\n        Button btn1 = new Button(\"btn1\");\n        Button btn2 = new Button(\"btn2\");\n        Button btn3 = new Button(\"btn3\");\n        Button btn4 = new Button(\"btn4\");\n        Button btn5 = new Button(\"btn5\");\n\n        frame.setBounds(100, 100, 200, 200);\n        frame.setVisible(true);\n\n        //添加按钮到Frame中\n        frame.add(btn1,BorderLayout.EAST);\n        frame.add(btn2,BorderLayout.WEST);\n        frame.add(btn3,BorderLayout.NORTH);\n        frame.add(btn4,BorderLayout.SOUTH);\n        frame.add(btn5,BorderLayout.CENTER);\n    &#125;\n&#125;\n\n\n表格布局 Gridpublic class GridLayoutTest &#123;\n    public static void main(String[] args) &#123;\n        Frame frame = new Frame();\n\n        //新建按钮\n        Button btn1 = new Button(\"btn1\");\n        Button btn2 = new Button(\"btn2\");\n        Button btn3 = new Button(\"btn3\");\n        Button btn4 = new Button(\"btn4\");\n        Button btn5 = new Button(\"btn5\");\n\n        frame.setBounds(100, 100, 200, 200);\n        frame.setVisible(true);\n\n        frame.setLayout(new GridLayout(3,2));\n\n        //添加按钮到Frame中\n        frame.add(btn1);\n        frame.add(btn2);\n        frame.add(btn3);\n        frame.add(btn4);\n        frame.add(btn5);\n\n        //根据组件的大小自动调整窗口大小\n        frame.pack();\n\n    &#125;\n&#125;\n\n\n画笔Frame在初始化时，会自动调用一次画笔的paint方法。如果需要重新绘制，则需要repaint()\npublic class PaintTest &#123;\n    public static void main(String[] args) &#123;\n        new MyPaint().init();\n    &#125;\n&#125;\n\nclass MyPaint extends Frame&#123;\n\n    public void init()&#123;\n        setVisible(true);\n        setBounds(200,200,600,400);\n    &#125;\n\n    //画笔\n    @Override\n    public void paint(Graphics g) &#123;\n        //设置颜色\n        g.setColor(Color.red);\n        //画一个圆\n        g.drawOval(100,100,100,100);\n        //实心圆\n        g.fillOval(200,100,100,100);\n        g.setColor(Color.green);\n        //圆角矩形\n        g.fillRoundRect(100,200,100,100,10,10);\n\n    &#125;\n&#125;\n\n\n事件监听解释：当某个事情发生的时候，将要干什么\n按钮事件监听public class ActionEventTest &#123;\n    public static void main(String[] args) &#123;\n        //按下按钮触发一些事情\n        Frame frame = new Frame();\n        closeWindow(frame);\n\n        Button button = new Button(\"anniu\");\n\n        frame.add(button);\n        MyTestActionListener myTestActionListener = new MyTestActionListener();\n        //按钮增加监听事件\n        button.addActionListener(myTestActionListener);\n\n        frame.setVisible(true);\n        frame.pack();\n    &#125;\n\n    //抽取方法，用于关闭窗口\n    private static void closeWindow(Frame frame)&#123;\n        frame.addWindowListener(new WindowAdapter() &#123;\n            @Override\n            public void windowClosing(WindowEvent e) &#123;\n                System.exit(0);\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n\n//创建一个监听器类继承ActionListener\nclass MyTestActionListener implements ActionListener&#123;\n    @Override\n    public void actionPerformed(ActionEvent e) &#123;\n        System.out.println(\"按下了按钮\");\n    &#125;\n&#125;\n\n\n可以多个按钮公用同一个监听事件，也可以一个按钮增加多个监听事件\npublic class ActionEventTest &#123;\n    public static void main(String[] args) &#123;\n        //按下按钮触发一些事情\n        Frame frame = new Frame();\n        closeWindow(frame);\n\n        Button button = new Button(\"Start\");\n        Button button2 = new Button(\"Stop\");\n        //手动设置ActionCommand，如果不设置，默认就是Label的值\n        button2.setActionCommand(\"btn2-stop\");\n\n        frame.add(button,BorderLayout.NORTH);\n        frame.add(button2,BorderLayout.CENTER);\n        MyTestActionListener myTestActionListener = new MyTestActionListener();\n        //两个按钮公用同一个监听事件\n        button.addActionListener(myTestActionListener);\n        button2.addActionListener(myTestActionListener);\n\n        frame.setVisible(true);\n        frame.pack();\n    &#125;\n\n    //抽取方法，用于关闭窗口\n    private static void closeWindow(Frame frame)&#123;......&#125;\n&#125;\n\nclass MyTestActionListener implements ActionListener&#123;\n    @Override\n    public void actionPerformed(ActionEvent e) &#123;\n        String actionCommand = e.getActionCommand();\n        int modifiers = e.getModifiers();\n        long when = e.getWhen();\n        int id = e.getID();\n        Object source = e.getSource();\n\n        System.out.println(actionCommand);\n        System.out.println(modifiers);\n        System.out.println(when);\n        System.out.println(id);\n        System.out.println(source);\n        System.out.println(\"按下了按钮\");\n        //可以通过判断CommandAction的值来执行不同按钮的操作\n        if(actionCommand.equals(\"btn2-stop\"))&#123;\n            System.out.println(\"按下了停止按钮\");\n        &#125;\n    &#125;\n&#125;\n\n\n输入框事件监听public class TextFieldTest &#123;\n    public static void main(String[] args) &#123;\n        new MyFrameTest();\n    &#125;\n&#125;\n\nclass MyFrameTest extends Frame&#123;\n    public MyFrameTest()&#123;\n        TextField textField = new TextField();\n\n        add(textField);\n\n        //监听这个文本框输入的内容\n        MyTextFieldListener listener = new MyTextFieldListener();\n        //当按下回车时会触发这个输入框的事件\n        textField.addActionListener(listener);\n\n        //设置替换编码，可用于密码\n        textField.setEchoChar('*');\n\n        setVisible(true);\n        pack();\n    &#125;\n&#125;\n\nclass MyTextFieldListener implements ActionListener&#123;\n\n    @Override\n    public void actionPerformed(ActionEvent e) &#123;\n        Object source = e.getSource();\n        if(source instanceof TextField)&#123;\n            TextField textField = (TextField) source;\n            String text = textField.getText();\n            System.out.println(text);\n            textField.setText(\"\");\n        &#125;\n    &#125;\n&#125;\n\n\n例子：简易计算器\npublic class TestCalc &#123;\n    public static void main(String[] args) &#123;\n        new Calculator();\n    &#125;\n&#125;\n\nclass Calculator extends Frame&#123;\n\n    public Calculator()&#123;\n        //从左至右，流式布局\n        this.setLayout(new FlowLayout());\n        this.setVisible(true);\n        this.setLocation(new Point(500,500));\n        this.addWindowListener(new WindowAdapter() &#123;\n            @Override\n            public void windowClosing(WindowEvent e) &#123;\n                System.out.println(\"计算器退出\");\n                System.exit(0);\n            &#125;\n        &#125;);\n\n        init();\n        this.pack();\n    &#125;\n\n    public void init()&#123;\n        TextField num1 = new TextField(10);\n        TextField num2 = new TextField(10);\n        TextField sum = new TextField(20);\n        //标签\n        Label opt = new Label(\"+\");\n\n        Button eq = new Button(\"=\");\n\n        this.add(num1);\n        this.add(opt);\n        this.add(num2);\n        this.add(eq);\n        this.add(sum);\n\n        eq.addActionListener(new MyActionListener(num1,num2,sum));\n    &#125;\n&#125;\n\nclass MyActionListener implements ActionListener&#123;\n\n    private TextField num1,num2,num3;\n\n    public MyActionListener(TextField num1, TextField num2, TextField num3) &#123;\n        this.num1 = num1;\n        this.num2 = num2;\n        this.num3 = num3;\n    &#125;\n\n    @Override\n    public void actionPerformed(ActionEvent e) &#123;\n        String num1 = this.num1.getText();\n        String num2 = this.num2.getText();\n\n        int a = Integer.parseInt(num1);\n        int b = Integer.parseInt(num2);\n\n        num3.setText(\"\" + (a+b));\n    &#125;\n&#125;\n\n\n鼠标监听事件示例代码\nframe.addMouseListener(new MouseAdapter() &#123;\n    //重写鼠标按下的事件\n    @Override\n    public void mousePressed(MouseEvent e) &#123;\n        System.out.println(\"点击了鼠标\");\n    &#125;\n&#125;);\n\n\n\n例子：利用鼠标模仿画图工具\npublic class MouseActionTest &#123;\n    public static void main(String[] args) &#123;\n        new MyMouseFrame(\"画图\").init();\n    &#125;\n&#125;\n\nclass MyMouseFrame extends Frame&#123;\n\n    //用来记录保存鼠标点击过的点的位置，因为鼠标窗体repaint时需要知道每一个点的位置\n    private final java.util.List&lt;Point> points = new ArrayList&lt;>();\n\n    public MyMouseFrame(String title) throws HeadlessException &#123;\n        super(title);\n    &#125;\n\n    public void init()&#123;\n        //添加鼠标监听事件\n        this.addMouseListener(new MouseAdapter() &#123;\n            //重写鼠标按下的事件\n            @Override\n            public void mousePressed(MouseEvent e) &#123;\n                //当鼠标按下时，记录按下点的位置\n                MyMouseFrame myMouseFrame = (MyMouseFrame) e.getSource();\n                points.add(e.getPoint());\n                System.out.printf(\"在%d,%d上画了一个点\\n\",e.getX(),e.getY());\n                //使窗体重新绘制点\n                myMouseFrame.repaint();\n            &#125;\n        &#125;);\n\n        setBounds(200,200,200,200);\n        setVisible(true);\n    &#125;\n\n    @Override\n    public void paint(Graphics g) &#123;\n        //设置画笔颜色\n        g.setColor(Color.green);\n        //遍历list进行绘画\n        for (Point point : points) &#123;\n            //画一个实心的小圆，表示一个点\n            g.fillOval(point.x,point.y,10,10);\n        &#125;\n    &#125;\n&#125;\n\n\n窗口监听事件public class WindowActionTest &#123;\n    public static void main(String[] args) &#123;\n        Frame frame = new Frame();\n        frame.addWindowListener(new WindowAdapter() &#123;\n\n            //窗口打开事件\n            @Override\n            public void windowOpened(WindowEvent e) &#123;\n                System.out.println(\"WindowOpened\");\n            &#125;\n\n            //窗口关闭中事件\n            @Override\n            public void windowClosing(WindowEvent e) &#123;\n                System.out.println(\"windowClosing\");\n            &#125;\n\n            //窗口关闭后事件\n            @Override\n            public void windowClosed(WindowEvent e) &#123;\n                System.out.println(\"windowClosed\");\n            &#125;\n\n            //窗口最小化\n            @Override\n            public void windowIconified(WindowEvent e) &#123;\n                System.out.println(\"windowIconified\");\n            &#125;\n\n            //窗口取消最小化\n            @Override\n            public void windowDeiconified(WindowEvent e) &#123;\n                System.out.println(\"windowDeiconified\");\n            &#125;\n\n            //窗口激活\n            @Override\n            public void windowActivated(WindowEvent e) &#123;\n                System.out.println(\"windowActivated\");\n            &#125;\n\n            //窗口失去焦点\n            @Override\n            public void windowDeactivated(WindowEvent e) &#123;\n                System.out.println(\"windowDeactivated\");\n            &#125;\n\n            @Override\n            public void windowStateChanged(WindowEvent e) &#123;\n                System.out.println(\"windowStateChanged\");\n            &#125;\n\n            @Override\n            public void windowGainedFocus(WindowEvent e) &#123;\n                System.out.println(\"windowGainedFocus\");\n            &#125;\n\n            @Override\n            public void windowLostFocus(WindowEvent e) &#123;\n                System.out.println(\"windowLostFocus\");\n            &#125;\n        &#125;);\n        frame.setBounds(200,200,200,200);\n        frame.setVisible(true);\n    &#125;\n&#125;\n\n键盘监听事件public class KeyBoardActionTest &#123;\n    public static void main(String[] args) &#123;\n        new KeyBoardFrame(\"键盘事件监听\").init();\n    &#125;\n&#125;\n\nclass KeyBoardFrame extends Frame&#123;\n    public KeyBoardFrame(String title) throws HeadlessException &#123;\n        super(title);\n    &#125;\n\n    public void init()&#123;\n        //添加键盘监听事件\n        addKeyListener(new KeyAdapter() &#123;\n            @Override\n            public void keyPressed(KeyEvent e) &#123;\n                int keyCode = e.getKeyCode();\n                char keyChar = e.getKeyChar();\n                System.out.println(\"keyCode=>\"+keyCode+\" keyChar=>\"+keyChar);\n                switch (keyCode)&#123;\n                    case KeyEvent.VK_UP:\n                        System.out.println(\"上\");\n                        break;\n                    case KeyEvent.VK_DOWN:\n                        System.out.println(\"下\");\n                        break;\n                    case KeyEvent.VK_LEFT:\n                        System.out.println(\"左\");\n                        break;\n                    case KeyEvent.VK_RIGHT:\n                        System.out.println(\"右\");\n                        break;\n                &#125;\n            &#125;\n        &#125;);\n        setBounds(200,200,200,200);\n        setVisible(true);\n    &#125;\n&#125;\n\n\n","categories":["Java"],"tags":["GUI","AWT"]},{"title":"SpringCloud Sleuth","url":"/post/SpringCloud/SpringCloud%20Sleuth.html","content":"概述为什么出现这个技术？解决什么问题？在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的服务节点调用来协同产生最后的请求结果，每一个前端请求都会形成一个复杂的分布式服务调用链路，链路中的任何一环出现高延迟或错误都会引起整个请求最后的失败。\n是什么SpringCloud Sleuth提供了一套完整的服务跟踪的解决方案，在分布式系统中提供追踪解决方案并且兼容支持了zipkin\n搭建链路监控步骤1. ZipKin下载SpringCloud从F版起已经不需要自己构建ZipKin Server了，只需要调用jar即可。可以从Maven仓库直接下载\n启动java -jar zipkin-server-2.12.9-exec.jar\n名词解释\nTrace: 类似于树结构的Span集合，表示一条调用链路，存在唯一标识Span: 表示调用链路来源，通俗的理解Span就是一次请求信息\n2. 微服务改造演示中由80consumer调用8001provider，两个微服务中都需要同样配置\n添加依赖坐标&lt;!--包含了sleuth和zipkin-->\n&lt;dependency>\n    &lt;groupId>org.springframework.cloud&lt;/groupId>\n    &lt;artifactId>spring-cloud-starter-zipkin&lt;/artifactId>\n&lt;/dependency>\n\nyml配置spring:\n  application:\n    name: cloud-order-server\n  zipkin:\n    base-url: http:&#x2F;&#x2F;localhost:9411\n  sleuth:\n    sampler:\n      #采样率值介于0到1之间，1则表示全部采集\n      probability: 1\n\n3. 结果\n\n","categories":["Java","Spring系列"],"tags":["SpringCloud","Sleuth"]},{"title":"9. Redis缓存穿透和雪崩","url":"/post/Redis/9.%20redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9.html","content":"","categories":["Redis"],"tags":["Redis"]},{"title":"8. Redis主从复制","url":"/post/Redis/8.%20Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html","content":"概念主从复制,是指将一台Redis服务器的数据,复制到其他的Redis服务器。前者称为主节点(masterleader) ,后者称为从节点(slavefolldwer) ;==数据的复制是单向的,只能由主节点到从节点==。Master以写为主, Slave以读为主\n==默认情况下,每台Redis服务器都是主节点==;且一个主节点可以有多个从节点(或没有从节点),但一个从节点只能有一个主节点。\n作用主从复制的作用主要包括:\n\n数据冗余:主从复制实现了数据的热备份,是持久化之外的一种数据冗余方式。\n故障恢复:当主节点出现问题时,可以由从节点提供服务,实现快速的故障恢复;实际上是一种服务的冗余。\n负载均衡:在主从复制的基础上,配合读写分离,可以由主节点提供写服务,由从节点提供读服务(即写Redis数据时应用连接主节点,读Redis数据时应用连接从节点) ,分担服务器负载;尤其是在写少读多的场景下,通过多个从节点分担读负载,可以大大提高Redis服务器的并发量。\n高可用基石:除了上述作用以外,主从复制还是哨兵和集群能够实施的基础,因此说主从复制是Redis高可用的基础。\n\n一般来说,要将Redis运用于工程项目中,只使用一台Redis是万万不能的(宕机) ,原因如下:\n\n从结构上,单个Redis服务器会发生单点故障,并且一台服务器需要处理所有的请求负载,压力较大;\n从容量上,单个Redis服务器内存容量有限,就算一台Redis服务器内存容量为256G,也不能将所有内存用作Redis存储内存一般来说,单台Redis最大使用内存不应该超过20G电商网站上的商品,一般都是一次上传,无数次浏览的,说专业点也就是”多读少写”。\n\n环境搭建主从信息查询\n127.0.0.1:6379> info replication #查看主从信息\n# Replication\nrole:master # 角色，是主机还是从机\nconnected_slaves:0 # 从机个数\nmaster_failover_state:no-failover\nmaster_replid:95e7380696b57cef74de81d4673e127a7619fda0\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:0\nsecond_repl_offset:-1\nrepl_backlog_active:0\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:0\nrepl_backlog_histlen:0\n\n配置文件修改项（避免重复覆盖）\n\n端口号\nPID文件\nLog文件\nrdb文件\n\n第一种方式graph LR\n主机A--&gt;从机B\n主机A--&gt;从机C\n\n配置信息配置从机\n\n命令配置\n# 配置主机IP和端口\n127.0.0.1:6380> SLAVEOF 127.0.0.1 6379\nOK\n配置文件配置\n\n\nreplicaof 127.0.0.1 6379\n\n\n从机信息\n127.0.0.1:6380> info replication\n# Replication\nrole:slave\nmaster_host:127.0.0.1\nmaster_port:6379\nmaster_link_status:up\nmaster_last_io_seconds_ago:1\nmaster_sync_in_progress:0\nslave_repl_offset:14\nslave_priority:100\nslave_read_only:1\nreplica_announced:1\nconnected_slaves:0\nmaster_failover_state:no-failover\nmaster_replid:cf02d21e7fd2d53056311c0c1550e0d08c02c789\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:14\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:14\n\n主机信息\n127.0.0.1:6379> info replication\n# Replication\nrole:master\nconnected_slaves:2\nslave0:ip=127.0.0.1,port=6380,state=online,offset=224,lag=1\nslave1:ip=127.0.0.1,port=6381,state=online,offset=224,lag=1\nmaster_failover_state:no-failover\nmaster_replid:cf02d21e7fd2d53056311c0c1550e0d08c02c789\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:224\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:224\n\n功能测试从机自动同步\n#主机设置值\n127.0.0.1:6379> set k3 v3\nOK\n#从机自动同步\n127.0.0.1:6380> keys *\n1) \"k3\"\n2) \"k1\"\n3) \"k2\"\n\n从机只读\n127.0.0.1:6381> set k4 v4\n(error) READONLY You can't write against a read only replica.\n\n主机断开\n#主机断开（宕机）\n127.0.0.1:6379> shutdown\nnot connected> \n\n#从机默认依旧作为从机连接主机\n127.0.0.1:6381> info replication\n# Replication\nrole:slave\nmaster_host:127.0.0.1\nmaster_port:6379\nmaster_link_status:down\nmaster_last_io_seconds_ago:-1\nmaster_sync_in_progress:0\nslave_repl_offset:17062\nmaster_link_down_since_seconds:7\nslave_priority:100\nslave_read_only:1\nreplica_announced:1\nconnected_slaves:0\nmaster_failover_state:no-failover\nmaster_replid:cf02d21e7fd2d53056311c0c1550e0d08c02c789\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:17062\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:183\nrepl_backlog_histlen:16880\n\n\n主机断开后，从机依旧作为从机连接主机，集群就只有读功能，没有写操作。如果主机回来，从机依旧可以直接获取到主机信息。配置哨兵模式后，可以自动选举一个作为主机。\n\n如果使用命令行配置主从，是不持久的，如果重启了，就会变回主机。配置文件中配置主从是持久生效的。\n从机成功连接到主机后，会发送一个sync同步命令。主机接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，主机将传送整个数据文件到从机，并完成一次完全同步（==这个叫全量复制，后面主机新增值，依次将修改命令传给从机执行，叫做增量复制==）。\n第二种方式graph LR\n主机A--&gt;从机B\n从机B--&gt;从机C\n\n配置信息从机A\nslaveof 127.0.0.1 6379\n从机B\nslaveof 127.0.0.1 6380\n\n功能测试 主机断开，从机手动变为主机\n slaveof no one\n 从机B当选主机，从机C连接B  127.0.0.1:6380> info replication\n# Replication\nrole:master\nconnected_slaves:1\nslave0:ip=127.0.0.1,port=6381,state=online,offset=1288,lag=0\nmaster_failover_state:no-failover\nmaster_replid:a7131f2ad29e3d74b13249f34c96851590a3c988\nmaster_replid2:7fb1815699259ae0976825b8385930bddd79837f\nmaster_repl_offset:1288\nsecond_repl_offset:99\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:43\nrepl_backlog_histlen:1246\n 主机A重启后，B依然当主机\n  127.0.0.1:6379> info replication\n# Replication\nrole:master\nconnected_slaves:0\nmaster_failover_state:no-failover\nmaster_replid:ccc698a2310cd9e474745d6943768e2c70d942c0\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:0\nsecond_repl_offset:-1\nrepl_backlog_active:0\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:0\nrepl_backlog_histlen:0\n \n\n第三种：哨兵模式（自动选举）graph LR\n哨兵--&gt;主机A\n主机A--&gt;从机B\n哨兵--&gt;从机B\n哨兵--&gt;从机C\n主机A--&gt;从机C\n\n\n配置vim sentinel.conf\n\nsentinel monitor myredis 127.0.0.1 6379 1\n\n启动doubly@xiaoyizideMacBook-Pro bin % redis-sentinel doublyConfig/sentinel.conf \n66451:X 28 Jun 2021 13:39:32.117 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\n66451:X 28 Jun 2021 13:39:32.117 # Redis version=6.2.4, bits=64, commit=00000000, modified=0, pid=66451, just started\n66451:X 28 Jun 2021 13:39:32.117 # Configuration loaded\n66451:X 28 Jun 2021 13:39:32.119 * Increased maximum number of open files to 10032 (it was originally set to 256).\n66451:X 28 Jun 2021 13:39:32.119 * monotonic clock: POSIX clock_gettime\n                _._                                                  \n           _.-``__ ''-._                                             \n      _.-``    `.  `_.  ''-._           Redis 6.2.4 (00000000/0) 64 bit\n  .-`` .-```.  ```\\/    _.,_ ''-._                                  \n (    '      ,       .-`  | `,    )     Running in sentinel mode\n |`-._`-...-` __...-.``-._|'` _.-'|     Port: 26379\n |    `-._   `._    /     _.-'    |     PID: 66451\n  `-._    `-._  `-./  _.-'    _.-'                                   \n |`-._`-._    `-.__.-'    _.-'_.-'|                                  \n |    `-._`-._        _.-'_.-'    |           https://redis.io       \n  `-._    `-._`-.__.-'_.-'    _.-'                                   \n |`-._`-._    `-.__.-'    _.-'_.-'|                                  \n |    `-._`-._        _.-'_.-'    |                                  \n  `-._    `-._`-.__.-'_.-'    _.-'                                   \n      `-._    `-.__.-'    _.-'                                       \n          `-._        _.-'                                           \n              `-.__.-'                                               \n\n66451:X 28 Jun 2021 13:39:32.124 # Sentinel ID is 8c6e1549c754881a4f65cc855dfb9569409762a1\n66451:X 28 Jun 2021 13:39:32.124 # +monitor master myredis 127.0.0.1 6379 quorum 1\n66451:X 28 Jun 2021 13:39:32.127 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:39:32.129 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379\n\n主机shutdown后的哨兵日志\n66451:X 28 Jun 2021 13:42:26.257 # +sdown master myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:26.257 # +odown master myredis 127.0.0.1 6379 #quorum 1/1\n66451:X 28 Jun 2021 13:42:26.257 # +new-epoch 1\n66451:X 28 Jun 2021 13:42:26.257 # +try-failover master myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:26.261 # +vote-for-leader 8c6e1549c754881a4f65cc855dfb9569409762a1 1\n66451:X 28 Jun 2021 13:42:26.261 # +elected-leader master myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:26.261 # +failover-state-select-slave master myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:26.330 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:26.330 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:26.414 * +failover-state-wait-promotion slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:26.820 # +promoted-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:26.820 # +failover-state-reconf-slaves master myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:26.876 * +slave-reconf-sent slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:27.881 * +slave-reconf-inprog slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:27.881 * +slave-reconf-done slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:27.961 # +failover-end master myredis 127.0.0.1 6379\n66451:X 28 Jun 2021 13:42:27.961 # +switch-master myredis 127.0.0.1 6379 127.0.0.1 6381\n66451:X 28 Jun 2021 13:42:27.962 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381\n66451:X 28 Jun 2021 13:42:27.962 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381\n66451:X 28 Jun 2021 13:42:58.037 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381\n\n6380自动指向6381\n127.0.0.1:6380> info replication\n# Replication\nrole:slave\nmaster_host:127.0.0.1\nmaster_port:6381\nmaster_link_status:up\nmaster_last_io_seconds_ago:2\nmaster_sync_in_progress:0\nslave_repl_offset:34018\nslave_priority:100\nslave_read_only:1\nreplica_announced:1\nconnected_slaves:0\nmaster_failover_state:no-failover\nmaster_replid:9eccaf8f6170f964eab0efa6e894526fc243fda3\nmaster_replid2:d25e84c3694901fea82095385a55d5f487014a28\nmaster_repl_offset:34018\nsecond_repl_offset:9600\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:34018\n\n6381被选举为主机\n127.0.0.1:6381> info replication\n# Replication\nrole:master\nconnected_slaves:1\nslave0:ip=127.0.0.1,port=6380,state=online,offset=38750,lag=1\nmaster_failover_state:no-failover\nmaster_replid:9eccaf8f6170f964eab0efa6e894526fc243fda3\nmaster_replid2:d25e84c3694901fea82095385a55d5f487014a28\nmaster_repl_offset:38750\nsecond_repl_offset:9600\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:38750\n\n==重新连回来的主机被归并到6381做从机==\n127.0.0.1:6381> info replication\n# Replication\nrole:master\nconnected_slaves:2\nslave0:ip=127.0.0.1,port=6380,state=online,offset=47931,lag=1\nslave1:ip=127.0.0.1,port=6379,state=online,offset=47931,lag=0\nmaster_failover_state:no-failover\nmaster_replid:9eccaf8f6170f964eab0efa6e894526fc243fda3\nmaster_replid2:d25e84c3694901fea82095385a55d5f487014a28\nmaster_repl_offset:48063\nsecond_repl_offset:9600\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:48063","categories":["Redis"],"tags":["Redis"]},{"title":"7. Redis消息订阅","url":"/post/Redis/7.%20redis%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85.html","content":"相关命令\npsubscribe 订阅一个或多个符合给定模式的频道\npubsub 查看订阅与发布系统状态\npublish 将信息发送到指定的频道\npunsubscribe 退订所有给定模式的频道\nsubscribe 订阅给定的一个或多个频道的信息\nunsubscribe 退订给定的频道\n\n测试订阅者\ndoubly@xiaoyizideMacBook-Pro bin % redis-cli\n127.0.0.1:6379> SUBSCRIBE doubly\nReading messages... (press Ctrl-C to quit)\n1) \"subscribe\"\n2) \"doubly\"\n3) (integer) 1\n1) \"message\"\n2) \"doubly\"\n3) \"1234\"\n1) \"message\"\n2) \"doubly\"\n3) \"666\"\n\n发布者\ndoubly@xiaoyizideMacBook-Pro bin % redis-cli\n127.0.0.1:6379> PUBLISH doubly 123\n(integer) 0\n127.0.0.1:6379> PUBLISH doubly 123\n(integer) 2\n\n使用代码编写同理\n使用场景\n实时消息系统\n实时聊天\n订阅、关注系统\n\n稍微复杂的场景我们就会使用消息中间件MQ\n","categories":["Redis"],"tags":["Redis"]},{"title":"6. Redis持久化","url":"/post/Redis/6.%20Redis%E6%8C%81%E4%B9%85%E5%8C%96.html","content":"RDBRDB（Redis Database）\nRedis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件，待持久化过程都结束了，再用这个临时文件替换上次持久化的文件。整个过程中，主进程不进行IO操作，这就确保了极高的性能。\n如果需要大规模的数据恢复，且对于数据的完整度不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能会丢失（例如Redis突然宕机）\n触发规则\nsave的规则满足情况下，会自动触发rdb持久化\n执行fulshall命令，会自动触发rdb持久化\nRedis shutdown时，也会生成一个rdb文件\n\n如何恢复RDB文件只需要将RDB文件放到reids启动目录下即可，redis会自动读取rdb文件。有时候生产环境我们还会对rdb文件进行备份。\n优点\n适合大规模的数据恢复\n对数据的完整度要求不高\n\n缺点\n需要一定的时间间隔进行操作。如果Redis意外宕机了，最后一次持久化的数据就没有了\nfork进程的时候，会占用一定的内存空间\n\nAOFAOF （Append Only File）\n以日志的形式来记录每个操作，将Redis执行过的所有命令记录下来（读操作不记录），只许追加文件但不可以改文件，redis启动之初会读取该文件重新构建数据。换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。\n如果AOF文件有错误，redis将启动失败。redis同事提供了一个aof修复工具redis-check-aof，使用命令redis-check-aof --fix appendonly.aof就可以修复错误（删除错误的一条命令）\ndoubly@xiaoyizideMacBook-Pro bin % redis-check-aof --fix appendonly.aof\n0x              6a: Expected \\r\\n, got: 7364\nAOF analyzed: size=128, ok_up_to=81, ok_up_to_line=26, diff=47\nThis will shrink the AOF from 128 bytes, with 47 bytes, to 81 bytes\nContinue? [y/N]: y\nSuccessfully truncated AOF\n\n配置#每次修改都会sync，消耗性能\nappendfsync always\n#每秒执行一次sync，可能会丢失这1s的数据\nappendfsync everysec\n#不执行sync，这个时候操作系统自己同步数据，速度最快\nappendfsync no\n\n重写规则auto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\n\n如果AOF文件大于64M，就会fork一个新的子进程将我们的文件来进行重写\n优点\n 每一次修改都同步，文件的完整会更加好。\n 每秒同步一次，可能会丢失一秒的数据\n 从不同步，效率最高\n\n缺点\n相对于数据文件来说，aof远远大于rdb，修复速度也比rdb慢\nAOF运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化\n\n","categories":["Redis"],"tags":["Redis"]},{"title":"5. Redis Conf详解","url":"/post/Redis/5.%20Redis%20Conf%E8%AF%A6%E8%A7%A3.html","content":"\n单位\n\n单位大小写不敏感\n# Note on units: when memory size is needed, it is possible to specify\n# it in the usual form of 1k 5GB 4M and so forth:\n#\n# 1k => 1000 bytes\n# 1kb => 1024 bytes\n# 1m => 1000000 bytes\n# 1mb => 1024*1024 bytes\n# 1g => 1000000000 bytes\n# 1gb => 1024*1024*1024 bytes\n#\n# units are case insensitive so 1GB 1Gb 1gB are all the same.\n\n\nINCLUDES 引入配置文件\n\n可以引入多个配置文件组成一个Redis配置文件\n# include /path/to/local.conf\n# include /path/to/other.conf\n\n\nMODULES 模块加载\n\n# loadmodule /path/to/my_module.so\n# loadmodule /path/to/other_module.so\n\n\nNETWORK 网络\n\n#可以访问的IP，若要远程访问，需要配置*或者访问者IP\n\n# bind 192.168.1.100 10.0.0.1     # listens on two specific IPv4 addresses\n# bind 127.0.0.1 ::1              # listens on loopback IPv4 and IPv6\n# bind * -::*                     # like the default, all available interfaces\nbind 127.0.0.1 -::1\n#是否开启保护模式\nprotected-mode yes\n#访问端口\nport 6379\n\n\nGENERAL 通用配置\n\n#是否以守护进程启动\ndaemonize yes\n#如果以守护进程启动，需要配置一个守护进程Pid文件\npidfile /var/run/redis_6379.pid\n\n#日志级别\n# debug (a lot of information, useful for development/testing)\n# verbose (many rarely useful info, but not a mess like the debug level)\n# notice (moderately verbose, what you want in production probably)\n# warning (only very important / critical messages are logged)\n#默认notice，生产环境使用\nloglevel notice\n#日志输出位置\nlogfile \"\"\n#数据库数量\ndatabases 16\n#是否展示logo\nalways-show-logo no\n\nset-proc-title yes\nproc-title-template \"&#123;title&#125; &#123;listen-addr&#125; &#123;server-mode&#125;\"\n\n\nSNAPSHOTTING 快照 RDB配置\n\n#每3600s修改1个数据，则更新快照\nsave 3600 1\n#每300s修改100个数据，则更新快照\nsave 300 100\n#每60s修改10000个数据，则更新快照\nsave 60 10000\n#持久化发生错误是否继续持久化\nstop-writes-on-bgsave-error yes\n#是否对rdb文件进行压缩，会消耗一定CPU资源\nrdbcompression yes\n#保存文件的时候是否进行检查校验\nrdbchecksum yes\n#持久化文件名\ndbfilename dump.rdb\n#文件存放路径\ndir ./\n\n\nREPLICATION 主从配置\n\n\nSECURITY 安全\n\n设置密码\n# requirepass foobared\n\n\nCLIENTS 客户端限制\n\n# 最大客户端连接数量\n# maxclients 10000\n\n\nAPPEND ONLY MODE AppendOnly模式 AOF配置\n\n#默认是不开启AOF模式的，默认使用的是RDB，在大部分情况下，RDB足够\nappendonly no\n#持久化的文件名\nappendfilename \"appendonly.aof\"\n#每次修改都会同步\n# appendfsync always\n#每秒执行一次同步，可能丢失1s的数据\nappendfsync everysec\n# 不进行同步\n# appendfsync no","categories":["Redis"],"tags":["Redis"]},{"title":"4. Redis整合SpringBoot.md","url":"/post/Redis/4.%20Redis%E6%95%B4%E5%90%88SpringBoot.html","content":"依赖\n&lt;dependencies>\n    &lt;dependency>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-starter-data-redis&lt;/artifactId>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n    &lt;/dependency>\n&lt;/dependencies>\n\nSpringBoot操作数据：Spring-data jpa jdbc mongodb redis\nSpringData也是和SpringBoot齐名的项目\n\n说明：SpringBoot 2.x.x以后，原来使用的jedis被替换成了lettuce\n\n\njedis:采用的直连，多个线程操作的话，是不安全的。如果要避免不安全的，使用jedis连接池。像BIO模式\n\nlettuce:采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况。可以减少线程数据。像NIO模式\n\n\n自动配置源码分析\n@Configuration(\n    proxyBeanMethods = false\n)\n@ConditionalOnClass(&#123;RedisOperations.class&#125;)\n//所有的Redis配置在RedisProperties类里面就可以看到\n@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)\n@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)\npublic class RedisAutoConfiguration &#123;\n    public RedisAutoConfiguration() &#123;\n    &#125;\n\n    @Bean\n    //如果没有则创建，我们可以自己创建一个覆盖这个Bean\n    @ConditionalOnMissingBean(\n        name = &#123;\"redisTemplate\"&#125;\n    )\n    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)\n    public RedisTemplate&lt;Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;\n        RedisTemplate&lt;Object, Object> template = new RedisTemplate();\n        template.setConnectionFactory(redisConnectionFactory);\n        return template;\n    &#125;\n\n    //单独提供了一个操作String类型的Template，redis操作String比较常用\n    @Bean\n    @ConditionalOnMissingBean\n    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)\n    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;\n        StringRedisTemplate template = new StringRedisTemplate();\n        template.setConnectionFactory(redisConnectionFactory);\n        return template;\n    &#125;\n&#125;\n配置\nspring.redis.host=127.0.0.1\nspring.redis.port=6379\n\n\n使用\n//redisTemplate提供了对每种数据类型的操作，然后操作与命令基本相同\nredisTemplate.opsForSet();\nredisTemplate.opsForHash();\nredisTemplate.opsForList();\nredisTemplate.opsForZSet();\nredisTemplate.opsForValue();\nredisTemplate.opsForGeo();\nredisTemplate.opsForHyperLogLog();\n\n示例\n@SpringBootTest\nclass SpringbootApplicationTests &#123;\n\n    @Resource\n    private RedisTemplate redisTemplate;\n\n    @Test\n    void contextLoads() &#123;\n        redisTemplate.opsForValue().set(\"name\",\"Doubly\");\n        System.out.println(redisTemplate.opsForValue().get(\"name\"));\n    &#125;\n\n&#125;\n\n\n\n自定义RestTemplate模板\n@Configuration\npublic class RedisConfig &#123;\n\n    //自己定义了一个RestTemplate\n    @Bean\n    public RedisTemplate&lt;String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;\n\n        //一般为了方便，直接使用&lt;String,Objcet>\n        RedisTemplate&lt;String, Object> template = new RedisTemplate();\n        template.setConnectionFactory(redisConnectionFactory);\n\n        //json序列化\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);\n\n        //String序列化\n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\n\n        //设置key使用String序列化\n        template.setKeySerializer(stringRedisSerializer);\n        //设置hashkey使用String序列化\n        template.setHashKeySerializer(stringRedisSerializer);\n        //设置value使用json序列化\n        template.setValueSerializer(jackson2JsonRedisSerializer);\n        //设置HashValue使用json序列化\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\n\n        template.afterPropertiesSet();\n\n        return template;\n    &#125;\n\n&#125;\n\n\nSpringBoot RedisUtil工具类\npackage cn.doubly.utils;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.CollectionUtils;\n\nimport javax.annotation.Resource;\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\n\n@Component\npublic final class RedisUtil &#123;\n\n\n    @Resource\n    private RedisTemplate&lt;String, Object> redisTemplate;\n\n    // =============================common============================\n\n    /**\n     * 26\n     * 指定缓存失效时间\n     * 27\n     *\n     * @param key  键\n     *             28\n     * @param time 时间(秒)\n     *             29\n     * @return 30\n     */\n\n    public boolean expire(String key, long time) &#123;\n\n        try &#123;\n\n            if (time > 0) &#123;\n\n                redisTemplate.expire(key, time, TimeUnit.SECONDS);\n\n            &#125;\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 44\n     * 根据key 获取过期时间\n     * 45\n     *\n     * @param key 键 不能为null\n     *            46\n     * @return 时间(秒) 返回0代表为永久有效\n     * 47\n     */\n\n    public long getExpire(String key) &#123;\n\n        return redisTemplate.getExpire(key, TimeUnit.SECONDS);\n\n    &#125;\n\n    /**\n     * 53\n     * 判断key是否存在\n     * 54\n     *\n     * @param key 键\n     *            55\n     * @return true 存在 false不存在\n     * 56\n     */\n\n    public boolean hasKey(String key) &#123;\n\n        try &#123;\n\n            return redisTemplate.hasKey(key);\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 67\n     * 删除缓存\n     * 68\n     *\n     * @param key 可以传一个值 或多个\n     *            69\n     */\n\n    @SuppressWarnings(\"unchecked\")\n\n    public void del(String... key) &#123;\n\n        if (key != null &amp;&amp; key.length > 0) &#123;\n\n            if (key.length == 1) &#123;\n\n                redisTemplate.delete(key[0]);\n\n            &#125; else &#123;\n\n\n                redisTemplate.delete((Collection&lt;String>) CollectionUtils.arrayToList(key));\n            &#125;\n\n        &#125;\n\n    &#125;\n\n    // ============================String=============================\n\n    /**\n     * 83\n     * 普通缓存获取\n     * 84\n     *\n     * @param key 键\n     *            85\n     * @return 值\n     * 86\n     */\n\n    public Object get(String key) &#123;\n\n        return key == null ? null : redisTemplate.opsForValue().get(key);\n\n    &#125;\n\n    /**\n     * 92\n     * 普通缓存放入\n     * 93\n     *\n     * @param key   键\n     *              94\n     * @param value 值\n     *              95\n     * @return true成功 false失败\n     * 96\n     */\n\n    public boolean set(String key, Object value) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForValue().set(key, value);\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 109\n     * 普通缓存放入并设置时间\n     * 110\n     *\n     * @param key   键\n     *              111\n     * @param value 值\n     *              112\n     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期\n     *              113\n     * @return true成功 false 失败\n     * 114\n     */\n\n    public boolean set(String key, Object value, long time) &#123;\n\n        try &#123;\n\n            if (time > 0) &#123;\n\n                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);\n\n            &#125; else &#123;\n\n                set(key, value);\n\n            &#125;\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 130\n     * 递增\n     * 131\n     *\n     * @param key   键\n     *              132\n     * @param delta 要增加几(大于0)\n     *              133\n     * @return 134\n     */\n\n    public long incr(String key, long delta) &#123;\n\n        if (delta &lt; 0) &#123;\n\n            throw new RuntimeException(\"递增因子必须大于0\");\n\n        &#125;\n\n        return redisTemplate.opsForValue().increment(key, delta);\n\n    &#125;\n\n    /**\n     * 143\n     * 递减\n     * 144\n     *\n     * @param key   键\n     *              145\n     * @param delta 要减少几(小于0)\n     *              146\n     * @return 147\n     */\n\n    public long decr(String key, long delta) &#123;\n\n        if (delta &lt; 0) &#123;\n\n            throw new RuntimeException(\"递减因子必须大于0\");\n\n        &#125;\n\n        return redisTemplate.opsForValue().increment(key, -delta);\n\n    &#125;\n\n    // ================================Map=================================\n\n    /**\n     * 157\n     * HashGet\n     * 158\n     *\n     * @param key  键 不能为null\n     *             159\n     * @param item 项 不能为null\n     *             160\n     * @return 值\n     * 161\n     */\n\n    public Object hget(String key, String item) &#123;\n\n        return redisTemplate.opsForHash().get(key, item);\n\n    &#125;\n\n    /**\n     * 167\n     * 获取hashKey对应的所有键值\n     * 168\n     *\n     * @param key 键\n     *            169\n     * @return 对应的多个键值\n     * 170\n     */\n\n    public Map&lt;Object, Object> hmget(String key) &#123;\n\n        return redisTemplate.opsForHash().entries(key);\n\n    &#125;\n\n    /**\n     * 176\n     * HashSet\n     * 177\n     *\n     * @param key 键\n     *            178\n     * @param map 对应多个键值\n     *            179\n     * @return true 成功 false 失败\n     * 180\n     */\n\n    public boolean hmset(String key, Map&lt;String, Object> map) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForHash().putAll(key, map);\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 192\n     * HashSet 并设置时间\n     * 193\n     *\n     * @param key  键\n     *             194\n     * @param map  对应多个键值\n     *             195\n     * @param time 时间(秒)\n     *             196\n     * @return true成功 false失败\n     * 197\n     */\n\n    public boolean hmset(String key, Map&lt;String, Object> map, long time) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForHash().putAll(key, map);\n\n            if (time > 0) &#123;\n\n                expire(key, time);\n\n            &#125;\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 212\n     * 向一张hash表中放入数据,如果不存在将创建\n     * 213\n     *\n     * @param key   键\n     *              214\n     * @param item  项\n     *              215\n     * @param value 值\n     *              216\n     * @return true 成功 false失败\n     * 217\n     */\n\n    public boolean hset(String key, String item, Object value) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForHash().put(key, item, value);\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 229\n     * 向一张hash表中放入数据,如果不存在将创建\n     * 230\n     *\n     * @param key   键\n     *              231\n     * @param item  项\n     *              232\n     * @param value 值\n     *              233\n     * @param time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间\n     *              234\n     * @return true 成功 false失败\n     * 235\n     */\n\n    public boolean hset(String key, String item, Object value, long time) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForHash().put(key, item, value);\n\n            if (time > 0) &#123;\n\n                expire(key, time);\n\n            &#125;\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 250\n     * 删除hash表中的值\n     * 251\n     *\n     * @param key  键 不能为null\n     *             252\n     * @param item 项 可以使多个 不能为null\n     *             253\n     */\n\n    public void hdel(String key, Object... item) &#123;\n\n        redisTemplate.opsForHash().delete(key, item);\n\n    &#125;\n\n    /**\n     * 259\n     * 判断hash表中是否有该项的值\n     * 260\n     *\n     * @param key  键 不能为null\n     *             261\n     * @param item 项 不能为null\n     *             262\n     * @return true 存在 false不存在\n     * 263\n     */\n\n    public boolean hHasKey(String key, String item) &#123;\n\n        return redisTemplate.opsForHash().hasKey(key, item);\n\n    &#125;\n\n    /**\n     * 269\n     * hash递增 如果不存在,就会创建一个 并把新增后的值返回\n     * 270\n     *\n     * @param key  键\n     *             271\n     * @param item 项\n     *             272\n     * @param by   要增加几(大于0)\n     *             273\n     * @return 274\n     */\n\n    public double hincr(String key, String item, double by) &#123;\n\n        return redisTemplate.opsForHash().increment(key, item, by);\n\n    &#125;\n\n    /**\n     * 280\n     * hash递减\n     * 281\n     *\n     * @param key  键\n     *             282\n     * @param item 项\n     *             283\n     * @param by   要减少记(小于0)\n     *             284\n     * @return 285\n     */\n\n    public double hdecr(String key, String item, double by) &#123;\n\n        return redisTemplate.opsForHash().increment(key, item, -by);\n\n    &#125;\n\n    // ============================set=============================\n\n    /**\n     * 292\n     * 根据key获取Set中的所有值\n     * 293\n     *\n     * @param key 键\n     *            294\n     * @return 295\n     */\n\n    public Set&lt;Object> sGet(String key) &#123;\n\n        try &#123;\n\n            return redisTemplate.opsForSet().members(key);\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return null;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 306\n     * 根据value从一个set中查询,是否存在\n     * 307\n     *\n     * @param key   键\n     *              308\n     * @param value 值\n     *              309\n     * @return true 存在 false不存在\n     * 310\n     */\n\n    public boolean sHasKey(String key, Object value) &#123;\n\n        try &#123;\n\n            return redisTemplate.opsForSet().isMember(key, value);\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 321\n     * 将数据放入set缓存\n     * 322\n     *\n     * @param key    键\n     *               323\n     * @param values 值 可以是多个\n     *               324\n     * @return 成功个数\n     * 325\n     */\n\n    public long sSet(String key, Object... values) &#123;\n\n        try &#123;\n\n            return redisTemplate.opsForSet().add(key, values);\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return 0;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 336\n     * 将set数据放入缓存\n     * 337\n     *\n     * @param key    键\n     *               338\n     * @param time   时间(秒)\n     *               339\n     * @param values 值 可以是多个\n     *               340\n     * @return 成功个数\n     * 341\n     */\n\n    public long sSetAndTime(String key, long time, Object... values) &#123;\n\n        try &#123;\n\n            Long count = redisTemplate.opsForSet().add(key, values);\n\n            if (time > 0)\n\n                expire(key, time);\n\n            return count;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return 0;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 355\n     * 获取set缓存的长度\n     * 356\n     *\n     * @param key 键\n     *            357\n     * @return 358\n     */\n\n    public long sGetSetSize(String key) &#123;\n\n        try &#123;\n\n            return redisTemplate.opsForSet().size(key);\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return 0;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 369\n     * 移除值为value的\n     * 370\n     *\n     * @param key    键\n     *               371\n     * @param values 值 可以是多个\n     *               372\n     * @return 移除的个数\n     * 373\n     */\n\n    public long setRemove(String key, Object... values) &#123;\n\n        try &#123;\n\n            Long count = redisTemplate.opsForSet().remove(key, values);\n\n            return count;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return 0;\n\n        &#125;\n\n    &#125;\n\n    // ===============================list=================================\n\n    /**\n     * 386\n     * 获取list缓存的内容\n     * 387\n     *\n     * @param key   键\n     *              388\n     * @param start 开始\n     *              389\n     * @param end   结束 0 到 -1代表所有值\n     *              390\n     * @return 391\n     */\n\n    public List&lt;Object> lGet(String key, long start, long end) &#123;\n\n        try &#123;\n\n            return redisTemplate.opsForList().range(key, start, end);\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return null;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 402\n     * 获取list缓存的长度\n     * 403\n     *\n     * @param key 键\n     *            404\n     * @return 405\n     */\n\n    public long lGetListSize(String key) &#123;\n\n        try &#123;\n\n            return redisTemplate.opsForList().size(key);\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return 0;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 416\n     * 通过索引 获取list中的值\n     * 417\n     *\n     * @param key   键\n     *              418\n     * @param index 索引 index>=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推\n     *              419\n     * @return 420\n     */\n\n    public Object lGetIndex(String key, long index) &#123;\n\n        try &#123;\n\n            return redisTemplate.opsForList().index(key, index);\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return null;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 431\n     * 将list放入缓存\n     * 432\n     *\n     * @param key   键\n     *              433\n     * @param value 值\n     *              434\n     * @paramtime  时间(秒)\n     *              435\n     * @return 436\n     */\n\n    public boolean lSet(String key, Object value) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForList().rightPush(key, value);\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 将list放入缓存\n     *\n     * @param key   键\n     * @param value 值\n     * @param time  时间(秒)\n     * @return\n     */\n\n    public boolean lSet(String key, Object value, long time) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForList().rightPush(key, value);\n\n            if (time > 0)\n\n                expire(key, time);\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 467\n     * 将list放入缓存\n     * 468\n     *\n     * @param key   键\n     *              469\n     * @param value 值\n     *              470\n     * @paramtime  时间(秒)\n     *              471\n     * @return 472\n     */\n\n    public boolean lSet(String key, List&lt;Object> value) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForList().rightPushAll(key, value);\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 484\n     * 将list放入缓存\n     * 485\n     * &lt;p>\n     * 486\n     *\n     * @param key   键\n     *              487\n     * @param value 值\n     *              488\n     * @param time  时间(秒)\n     *              489\n     * @return 490\n     */\n\n    public boolean lSet(String key, List&lt;Object> value, long time) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForList().rightPushAll(key, value);\n\n            if (time > 0)\n\n                expire(key, time);\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 504\n     * 根据索引修改list中的某条数据\n     * 505\n     *\n     * @param key   键\n     *              506\n     * @param index 索引\n     *              507\n     * @param value 值\n     *              508\n     * @return 509\n     */\n\n    public boolean lUpdateIndex(String key, long index, Object value) &#123;\n\n        try &#123;\n\n            redisTemplate.opsForList().set(key, index, value);\n\n            return true;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return false;\n\n        &#125;\n\n    &#125;\n\n    /**\n     * 521\n     * 移除N个值为value\n     * 522\n     *\n     * @param key   键\n     *              523\n     * @param count 移除多少个\n     *              524\n     * @param value 值\n     *              525\n     * @return 移除的个数\n     * 526\n     */\n\n    public long lRemove(String key, long count, Object value) &#123;\n\n        try &#123;\n\n            Long remove = redisTemplate.opsForList().remove(key, count, value);\n\n            return remove;\n\n        &#125; catch (Exception e) &#123;\n\n            e.printStackTrace();\n\n            return 0;\n\n        &#125;\n\n    &#125;\n&#125;\n","categories":["Redis"],"tags":["Redis"]},{"title":"3. Jedis","url":"/post/Redis/3.%20Jedis.html","content":"依赖\n&lt;dependency>\n    &lt;groupId>redis.clients&lt;/groupId>\n    &lt;artifactId>jedis&lt;/artifactId>\n    &lt;version>3.6.1&lt;/version>\n&lt;/dependency>\n\n连接使用\npublic class Ping &#123;\n\n    public static void main(String[] args) &#123;\n        //1. new Jedis就建立连接\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n\n        System.out.println(jedis.ping());\n    &#125;\n\n&#125;\n\n==Jedis所有API都与Redis命令一模一样==\n事务\npublic class Transaction &#123;\n    public static void main(String[] args) &#123;\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        System.out.println(jedis.flushDB());\n\n        Map&lt;String,String> user = new HashMap&lt;>();\n        user.put(\"name\",\"doubly\");\n        user.put(\"hello\",\"world\");\n        String jsonStr = JSONUtil.toJsonStr(user);\n\n        redis.clients.jedis.Transaction multi = jedis.multi();\n        try &#123;\n            multi.set(\"user1\", jsonStr);\n            multi.set(\"user2\", jsonStr);\n            //执行事务\n            multi.exec();\n        &#125;catch (Exception ex)&#123;\n            // 放弃事务\n            multi.discard();\n            ex.printStackTrace();\n        &#125;finally &#123;\n            System.out.println(jedis.get(\"user1\"));\n            System.out.println(jedis.get(\"user2\"));\n\n            //关闭连接\n            jedis.close();\n        &#125;\n    &#125;\n&#125;\n\n乐观锁\npublic class OptimisticLock &#123;\n\n    public static void main(String[] args) &#123;\n        Jedis jedis = new Jedis(\"127.0.0.1\",6379);\n\n        System.out.println(jedis.flushDB());\n\n        jedis.set(\"money\",\"100\");\n        jedis.set(\"out\",\"0\");\n\n        jedis.watch(\"money\");\n        Transaction multi = jedis.multi();\n\n        try&#123;\n            multi.incrBy(\"out\",10);\n            multi.decrBy(\"money\",10);\n\n            int i = 1/0;\n\n            multi.exec();\n            System.out.println(\"事务执行完成\");\n        &#125;catch (Exception ex)&#123;\n            System.out.println(\"放弃事务\");\n            System.out.println(multi.discard());\n            ex.printStackTrace();\n        &#125;finally &#123;\n            System.out.println(jedis.get(\"money\"));\n            System.out.println(jedis.get(\"out\"));\n            jedis.close();\n        &#125;\n\n    &#125;\n&#125;","categories":["Redis"],"tags":["Redis"]},{"title":"2. Redis事务","url":"/post/Redis/2.%20Redis%E4%BA%8B%E5%8A%A1.html","content":"\nRedis事务本质\n\n一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行\n\nRedis事务特点\n\n\n一次性\n顺序性\n排他性\n\n==Redis单条命令是保证原子性的，但是事务不保证原子性。==\n==Redis事务没有隔离级别的概念==\n事务执行命令\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379(TX)> set k1 v1\nQUEUED\n127.0.0.1:6379(TX)> set k2 v2\nQUEUED\n127.0.0.1:6379(TX)> get k2\nQUEUED\n127.0.0.1:6379(TX)> exec\n1) OK\n2) OK\n3) \"v2\"\n127.0.0.1:6379> get k2\n\"v2\"\n\n放弃事务命令\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379(TX)> set k5 v5\nQUEUED\n127.0.0.1:6379(TX)> set k6 v6\nQUEUED\n127.0.0.1:6379(TX)> DISCARD\nOK\n127.0.0.1:6379> get k5\n(nil)\n\n\n编译型异常，所有的命令都不会执行\n\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379(TX)> set k1 v1\nQUEUED\n# 命令使用错误\n127.0.0.1:6379(TX)> set k2\n(error) ERR wrong number of arguments for 'set' command\n127.0.0.1:6379(TX)> set k3 v3\nQUEUED\n127.0.0.1:6379(TX)> exec\n(error) EXECABORT Transaction discarded because of previous errors.\n# 所有命令都未执行\n127.0.0.1:6379> keys *\n(empty array)\n\n\n运行时异常，错误的命令抛出异常，其他命令继续执行（没有原子性的表现）\n\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379(TX)> set k1 v1\nQUEUED\n127.0.0.1:6379(TX)> incr k1\nQUEUED\n127.0.0.1:6379(TX)> set k2 v2\nQUEUED\n#运行时抛出错误异常，其他命令继续执行\n127.0.0.1:6379(TX)> exec\n1) OK\n2) (error) ERR value is not an integer or out of range\n3) OK\n127.0.0.1:6379> get k1\n\"v1\"\n127.0.0.1:6379> get k2\n\"v2\"\n\n\n乐观锁实现悲观锁：\n认为什么时候都会出问题，无论干什么都会加锁\n乐观锁：认为什么时候都不会出问题，所以不会上锁。更新数据的时候去判断一下，在此期间是否有人更改了数据。\n\n获取version\n更新的时候比较version\n\n正常加锁执行\n127.0.0.1:6379> set money 100\nOK\n127.0.0.1:6379> set out 0\nOK\n127.0.0.1:6379> watch money\nOK\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379(TX)> decrby money 20\nQUEUED\n127.0.0.1:6379(TX)> INCRBY out 20\nQUEUED\n127.0.0.1:6379(TX)> exec\n1) (integer) 80\n2) (integer) 20\n\n加锁后，数据被篡改\n127.0.0.1:6379> watch money\nOK\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379(TX)> decrby money 10\nQUEUED\n127.0.0.1:6379(TX)> incrby money 10\nQUEUED\n\n#另一线程此时修改了数据\n127.0.0.1:6379(TX)> exec\n(nil)\n\n# 另一线程\n127.0.0.1:6379> set money 1000\nOK\n127.0.0.1:6379> get money \n\"1000\"","categories":["Redis"],"tags":["Redis"]},{"title":"1. Redis概述","url":"/post/Redis/1.%20Redis%E7%AE%80%E4%BB%8B%E3%80%81%E5%AE%89%E8%A3%85%E3%80%81%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html","content":"Redis概述Redis是什么?\nRedis(==Re==mote ==di==ctionary ==s==erver)，即远程字典服务。是一个开元的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多重语言的API。\nRedis能干嘛？\n\n内存存储、持久化，内存中是断电即失、所以说持久化很重要（RDB、AOF）\n效率高，可以用于高速缓存\n发布订阅系统\n地图信息分析\n计时器、计数器（浏览量…）\n…\n\n特性\n\n多样的数据类型\n持久化\n集群\n事务\n…\n\n安装\n下载，直接官网下载即可\ntar -zxvf解压下载的redis-*.tar.gz\nmake 命令执行安装\nmake install将redis安装到/usr/local/bin目录下\ncp redis.conf /usr/local/bin/doublyConfig，将redis的配置文件拷贝一份，后续使用修改该配置文件。方便出问题复原\nvim redis.conf，编辑配置文件，\\daemonize搜索daemonize，将值改为yes，表示以后台的方式启动\nredis-server doublyConfig/redis.conf，使用修改的配置文件启动redis\nredis-cli -h localhost -p 6379，使用redis客户端连接server。-h表示主机，-p表示端口\n客户端连接后，使用ping，返回PONG，表示连接成功；set name doubly设置键值对；get name获取键值对；\n\n基础知识Redis是单线程的（据说6.0的已经是多线程的了？）\nRedis是基于内存操作的，性能瓶颈已经不是CPU了，而是内存和网络带宽。\n为什么Redis单线程还这么快？\n\n多线程不一定就比单线程快，因为多线程要频繁的进行上下文切换，是非常耗时的。\n高性能服务器也不一定是多线程的。\nCPU &gt; 内存 &gt; 硬盘，Redis将所有的数据放在内存中。对于内存系统没有上下文切换，在一个CPU上完成。\n\nRedis五大基础类型\nString类型\nList类型（双向链表）\nSet类型（无序不重复集合）\nHash类型（相当于Map）：适合对象的存储\nZset类型（有序集合）\n\n三大特殊类型\nGeospatial类型（地理位置），基于Zset实现\nHyperLogLog类型，基于算法的基数（不重复的元素）统计的数据结构。0.81%的错误率，允许容错的情况下可以使用，只占用12KB的内存，统计效率高。\nBitMap类型，位图\n\n基础命令set name doubly , get name：设置、获取值\nexists name：判断是否存在\nexpire name 10：设置过期时间（秒）\nttl name：查看key剩余时间\nmove name 1：移动name到数据库1\n\n数据库命令(select,dbsize)\n\nRedis默认有16个数据库\n配置文件中的位置\n# Set the number of databases. The default database is DB 0, you can select\n# a different one on a per-connection basis using SELECT &lt;dbid> where\n# dbid is a number between 0 and 'databases'-1\ndatabases 16\n\n127.0.0.1:6379> DBSIZE #查看数据大小\n(integer) 5\n127.0.0.1:6379> select 1 #切换数据库\nOK\n127.0.0.1:6379[1]> keys * #查看所有的key\n(empty array) \n\n\n清除数据库命令\n\nflushdb：清除当前数据库\nflushall：清除所有数据库\n\nString类型相关命令\n\nappend name aaa：追加字符串，如果key不存在，则创建key\nstrlen name：返回字符串长度\nincr views：自增1\ndecr views：自减1\nincrby views 10：自增步长\ndecrby views 5：自减步长\ngetrange name 3 6：截取字符串\nsetrange name 3 abcd：替换字符串\nsetex name doubly 30：set with expire，设置值并同时设置过期时间\nsetnx name doubly：set not exist，不存在则创建KV，存在则创建失败\nmset k1 v1 k2 v2 k3 v3，mget k1 k2 k3：批量设置获取\nmsetnx k1 v1 k4 v4：setnx的批量操作，原子操作，一个失败就全部失败\n设置对象，user:{id}:{field}#设置一个对象，redis允许设置user:&#123;id&#125;:&#123;field&#125;格式\nmset user:1:name doubly age 12\n#同时获取对象的name和age\nmget user:1:name age\ngetset name doubly：先获取，再设置。返回当前值，并设置新的值\n\n\nList类型相关命令\n\nlpush list v1：在list头部插入新元素，没有则创建\nrpush list v2：在list尾部（右）插入新元素\nlrange list 0 -1：获取列表一段范围的元素\nlpop list [2],rpop list：弹出list左/右侧的元素\nlindex list 2：查看list某个下标的元素\nllen list：查询list的长度\nlrem list 2 value：移除list中2个value\nltrim list 1 2：截取list[1-2]\nrpoplpush list newlist：弹出list最右侧的元素并插入到新的list中，最后返回元素\nlset list 0 newitem：更新list某个下标的元素，如果key不存在则报错，如果下标不存在也报错\nlinsert list before|after value test：在list中的value前|后插入新元素\n\n\n\n\nSet类型相关命令\n\nsadd myset doubly：向set集合中新增一个元素，可以不存在则新建\nsmembers myset：查看set集合中的所有元素\nsismember myset doubly：验证set集合中某个元素是否存在\nscard myset：返回set集合中的元素个数\nsrem myset doubly：移除set集合中的指定元素\nsrandmember myset：获取set集合中的一个随机元素\nspop myset：从set集合中随机删除一个元素\nsmove myset newset doubly：将元素从一个set集合移动到另一个set集合中\nsdiff myset newset：获取两个set集合的差集。只获取myset有而newset没有的元素\nsinter myset newset：获取两个set集合的交集\nsunion myset newset：获取两个set集合的并集\n\n\nHash类型相关命令\n\nhset，hget：设置获取hash\nhmset，hmget：批量设置，获取（hset，hget也可以批量，4.0以后官方启用hmset,hmget?）\nhgetall：获取所有的键值对\nhdel：删除某一个field\nhlen：获取hash长度\nhexists：判断field是否存在\nhkeys：获取hash所有的key\nkvals：获取hash所有的value\nhincrby，hdecrby：hash中field自增、自减\nhsetnx：当field不存在时设置值\n\n\nZset类型相关命令\n\nzadd：向zset中增加元素\nzrange,zrevrange：按照索引正序、倒序列出范围内的元素\nzrangebyscore,zrevrangebyscore：按照score正序、倒序列出范围内的元素\nzrem：移除zset中某一个元素\nzcard：统计zset长度\nzcount：统计某个score范围内的元素个数\n\n\nGeospatial类型相关命令（Zset命令全部适用）\n\ngeoadd：添加地理经纬度信息，经纬度有范围限制，超过则报错127.0.0.1:6379> geoadd city 116.40 39.90 beijing\n(integer) 1\n127.0.0.1:6379> geoadd city 121.47 31.23 shanghai\n(integer) 1\n127.0.0.1:6379> geoadd city 106.50 29.53 chongqing\n(integer) 1\n127.0.0.1:6379> geoadd city 114.05 22.53 shenzhen\n(integer) 1\n127.0.0.1:6379> geoadd city 120.16 30.24 hangzhou\n(integer) 1\n127.0.0.1:6379> geoadd city 108.96 34.26 xian\n(integer) 1\ngeopos：获取某个地方的地理位置127.0.0.1:6379> geopos city beijing\n1) 1) \"116.39999896287918091\"\n   2) \"39.90000009167092543\"\n   \n127.0.0.1:6379> geopos city beijing shenzhen\n1) 1) \"116.39999896287918091\"\n   2) \"39.90000009167092543\"\n2) 1) \"114.04999762773513794\"\n   2) \"22.52999956292396888\"\ngeodist：计算两地之间的距离127.0.0.1:6379> geodist city beijing shenzhen\n\"1944681.9952\"\n\n#设置单位\n127.0.0.1:6379> geodist city beijing shenzhen km\n\"1944.6820\"\n127.0.0.1:6379> geodist city beijing shanghai km\n\"1067.3788\"\ngeoradius：查询某地范围内的地区127.0.0.1:6379> GEORADIUS city 114.05 22.50 1000 km\n1) \"shenzhen\"\n127.0.0.1:6379> GEORADIUS city 114.05 22.50 10000 km\n1) \"chongqing\"\n2) \"xian\"\n3) \"shenzhen\"\n4) \"hangzhou\"\n5) \"shanghai\"\n6) \"beijing\"\n\n# 带上经纬度信息\n127.0.0.1:6379> GEORADIUS city 114.05 22.50 5000 km withcoord \n1) 1) \"chongqing\"\n   2) 1) \"106.49999767541885376\"\n      2) \"29.52999957900659211\"\n2) 1) \"xian\"\n   2) 1) \"108.96000176668167114\"\n      2) \"34.25999964418929977\"\n3) 1) \"shenzhen\"\n   2) 1) \"114.04999762773513794\"\n      2) \"22.52999956292396888\"\n4) 1) \"hangzhou\"\n   2) 1) \"120.1600000262260437\"\n      2) \"30.2400003229490224\"\n5) 1) \"shanghai\"\n   2) 1) \"121.47000163793563843\"\n      2) \"31.22999903975783553\"\n6) 1) \"beijing\"\n   2) 1) \"116.39999896287918091\"\n      2) \"39.90000009167092543\"\n      \n# 限定统计个数\n127.0.0.1:6379> GEORADIUS city 114.05 22.50 5000 km withcoord count 1\n1) 1) \"shenzhen\"\n   2) 1) \"114.04999762773513794\"\n      2) \"22.52999956292396888\"\n127.0.0.1:6379> GEORADIUS city 114.05 22.50 5000 km withcoord count 2\n1) 1) \"shenzhen\"\n   2) 1) \"114.04999762773513794\"\n      2) \"22.52999956292396888\"\n2) 1) \"hangzhou\"\n   2) 1) \"120.1600000262260437\"\n      2) \"30.2400003229490224\"\n      \n#带上距离\n127.0.0.1:6379> GEORADIUS city 114.05 22.50 5000 km withcoord withdist count 2\n1) 1) \"shenzhen\"\n   2) \"3.3367\"\n   3) 1) \"114.04999762773513794\"\n      2) \"22.52999956292396888\"\n2) 1) \"hangzhou\"\n   2) \"1053.9526\"\n   3) 1) \"120.1600000262260437\"\n      2) \"30.2400003229490224\"\ngeoradiusbymember：使用存入redis的地区进行范围查找127.0.0.1:6379> GEORADIUSBYMEMBER city chongqing 1000 km\n1) \"chongqing\"\n2) \"xian\"\n127.0.0.1:6379> GEORADIUSBYMEMBER city chongqing 2000 km\n1) \"chongqing\"\n2) \"xian\"\n3) \"shenzhen\"\n4) \"hangzhou\"\n5) \"shanghai\"\n6) \"beijing\"\n127.0.0.1:6379> GEORADIUSBYMEMBER city shanghai 1000 km\n1) \"hangzhou\"\n2) \"shanghai\"\ngeohash：返回地方经纬度的hash127.0.0.1:6379> geohash city shenzhen\n1) \"ws105m2wv80\"\n127.0.0.1:6379> geohash city shenzhen beijing\n1) \"ws105m2wv80\"\n2) \"wx4fbxxfke0\"\n\n\nHyperLogLog类型相关命令\n#pfadd 添加元素\n127.0.0.1:6379> pfadd k1 a b d e f g h i\n(integer) 1\n#pfcount 统计基数个数\n127.0.0.1:6379> pfcount k1\n(integer) 8\n127.0.0.1:6379> pfadd k2 h i j k\n(integer) 1\n127.0.0.1:6379> pfcount k2\n(integer) 4\n#pfmerge 合并两组元素到一个新的key中\n127.0.0.1:6379> pfmerge k3 k1 k2\nOK\n127.0.0.1:6379> pfcount k3\n(integer) 10\n#去除重复计数\n127.0.0.1:6379> pfadd k4 a a a a b\n(integer) 1\n127.0.0.1:6379> pfcount k4\n(integer) 2\nBitMap类型命令\n#添加一个元素\n127.0.0.1:6379> setbit sign 0 1\n(integer) 0\n127.0.0.1:6379> setbit sign 1 0\n(integer) 0\n127.0.0.1:6379> setbit sign 2 0\n(integer) 0\n127.0.0.1:6379> setbit sign 3 0\n(integer) 0\n#获取某一个元素\n127.0.0.1:6379> getbit sign 2\n(integer) 0\n#统计值为1的数量\n127.0.0.1:6379> bitcount sign\n(integer) 1\n\n","categories":["Redis"],"tags":["Redis"]},{"title":"0. NoSQL概述","url":"/post/Redis/0.%20NoSQL%E6%A6%82%E8%BF%B0.html","content":"NoSQL概述为什么要用NoSql？\n数据量如果太大，一个机器放不下\n数据的索引（如MySQL的B+Tree，300万一定要建立索引），一个机器内存也放不下\n访问量（读写混合），一个服务器承受不了\n\n用户的个人信息、社交网络、地理位置、用户自己产生的数据、用户日志等等爆发式增长！这个时候我们就需要使用NoSQL数据库，NoSQL数据库可以很好的处理以上问题。\nNoSQL特点\n方便扩展（数据之间没有关系，很好扩展）\n大数据量高性能（Redis 写8w/s 读11w/s），NoSQL的缓存记录级是一种细粒度的缓存，性能会比较高\n数据类型是多样型的（不需要事先设计数据库）\n传统的RDBMS和NoSQL\n传统RDBMS：\n\n结构化组织\nSQL\n数据和关系都存在单独的表中\n操作操作，数据定义语言\n严格的一致性\n基础的事物\n…\n\n\n\n\n\nNoSQL：\n\n不仅仅是数据\n没有固定的查询语言\n键值对存储，列存储，文档存储，图形数据库（社交关系）\n最终一致性\nCAP定理和BASE理论（BA、S、E)（异地多活）\n高性能、高可用、高扩展\n\n\nNoSQL四大分类KV键值对\n新浪：Redis\n美团：Redis + Tair\n阿里、百度：Redis + memecache\n\n文档型数据库（bson格式，和json一样）\nMongoDB（一般必须要掌握）\n是一个基于分布式文件存储的数据库，C++编写，主要用于处理大量的文档\nMongoDB是一个介于关系型数据库和非关系型数据中中间的产品！MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的！\n\n\nCouchDB\n\n列存储数据库\nHBase\n分布式文件系统\n\n图关系数据库\n他不是存图形，放的是关系，比如：朋友圈社交网络，广告推荐！\n\n\nNeo4j\nInfoGrid\n\n","categories":["Redis"],"tags":["Redis"]},{"title":"JVM相关理解","url":"/post/Java/JVM%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3.html","content":"Java虚拟机整体架构祥图\n类加载器\n虚拟机自带的加载器\n\n启动类（根、BootStrap）加载器\n\n扩展类加载器\n\n应用程序（系统）加载器\n\n\npublic static void main(String[] args) &#123;\n    ClassLoader classLoader = OtherTest.class.getClassLoader();\n    //AppClassLoader，应用程序加载器   实现java.lang.abstract\n    System.out.println(classLoader);\n    //ExtClassLoader，扩展加载器   jre/lib/ext目录\n    System.out.println(classLoader.getParent());\n    //null，不存在或者java无法获取   rt.jar\n    System.out.println(classLoader.getParent().getParent());\n&#125;\n\n双亲委派机制\n类加载器收到加载类的请求\n\n将这个请求向上委托父类加载器去完成，一直向上委托到根加载器\n\n根加载器检查是否能够加载此类，能加载就加载并结束；不能加载则抛出异常，通知子加载器进行加载\n\n重复步骤3\n\n\n示例代码：\npackage java.lang;\n/*\n * @Description\n * @Author Doubly\n * @Date 2021/10/8\n */\npublic class String &#123;\n    public String toString()&#123;\n        return \"Hello\";\n    &#125;\n    public static void main(String[] args) &#123;\n        String s = new String();\n        System.out.println(s.toString());\n    &#125;\n&#125;\n\n运行结果：\n错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:\n   public static void main(String[] args)\n否则 JavaFX 应用程序类必须扩展javafx.application.Application           \n\n\n为了保证程序的安全，首先在AppClassLoader中找String，虽然已经找到，但是会继续在ExtClassLoader中找，最后在BootStrapClassLoader中找，找到rt.jar下面的String。所以不会家在我们自己写的String，会报没有main方法的错误。\nAppClassLoader -&gt; ExtClassLoader -&gt; BootstrapClassLoader（最终执行）\n\nnative关键字凡是带了native关键字的，说明Java的作用范围达不到了。会进入本地方法栈，通过本地方法接口（JNI）调用本地方法库。比如Object中的hashcode()方法，就是调用的本地方法。\n方法区静态变量、常量、类信息（构造方法、接口定义）、运行时的常量池存在方法区中，但是实例变量存在堆内存，和方法区无关\n栈8大基本类型+对象引用+实例的方法\n堆一个jvm只有一个堆内存，堆内存大小是可以调节的。\n默认分配的总内存是电脑的1/4，初始化的内存是电脑的1/64.\n代码示例：\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        //返回虚拟机试图使用的最大内存\n        long maxMemory = Runtime.getRuntime().maxMemory();\n        //返回虚拟机初始化使用的总内存\n        long totalMemory = Runtime.getRuntime().totalMemory();\n\n        System.out.println(\"max:\"+maxMemory + \"字节 \" + (maxMemory/(double)1024/1024) + \"MB\");\n        System.out.println(\"max:\"+totalMemory + \"字节 \" + (totalMemory/(double)1024/1024) + \"MB\");\n    &#125;\n&#125;\n\n结果：\nmax:1908932608字节 1820.5MB \nmax:128974848字节 123.0MB  \n\n​            \n堆内存细分三个区域：\n\n新生区（伊甸园区+幸存区0区+幸存区1区）（幸存区也叫from区与to区）\n\n养老区\n\n永久区\n\n\n新生区伊甸园区所有的对象都是在伊甸园区new出来的，伊甸园区满了会出发轻gc\n幸存区（0区+1区）gc触发后，还存在引用指向对象，对象就不会被回收，会进入幸存区。伊甸园区和幸存区都满了以后会今进行重gc。\n养老区幸存区满了之后，会进入养老区。一般99%的对象都会被清除，默认当一个对象经历15次后可以进入养老区。养老区满了之后就出现了OOM（Out Of Memory）。\n\n查看JVM堆中每个区的情况，可使用如下参数\n\nJVM参数：\n-Xms1024m -Xmx2048m -XX:+PrintGCDetails   \n\n输出：\nHeap\n PSYoungGen      total 305664K, used 20971K [0x0000000795580000, 0x00000007aaa80000, 0x00000007c0000000)\n  eden space 262144K, 8% used [0x0000000795580000,0x00000007969fafb8,0x00000007a5580000)\n  from space 43520K, 0% used [0x00000007a8000000,0x00000007a8000000,0x00000007aaa80000)\n  to   space 43520K, 0% used [0x00000007a5580000,0x00000007a5580000,0x00000007a8000000)\n ParOldGen       total 699392K, used 0K [0x0000000740000000, 0x000000076ab00000, 0x0000000795580000)\n  object space 699392K, 0% used [0x0000000740000000,0x0000000740000000,0x000000076ab00000)\n Metaspace       used 3104K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 339K, capacity 388K, committed 512K, reserved 1048576K\n           \n\nOOM之后如何排查问题？\n\n尝试扩大堆内存看结果\n\n分析内存，看一下哪个地方出现了问题（专业工具）\n\n\n内存快照分析工具：MAT（Eclipse最早继承）,Jprofiler\nMAT、JProfiler作用：\n\n分析Dump内存文件，快速定位内存泄漏\n\n获得堆中的数据\n\n获得大的对象\n\n\n如何获取JVM的dump文件？\n-Xms1m -Xmx1m -XX:+HeapDumpOnOutOfMemoryError\n\npublic class Test &#123;\n    //-Xms1m -Xmx1m -XX:+HeapDumpOnOutOfMemoryError\n    public static void main(String[] args) &#123;\n        String str = \"MyString\";\n        while (true)&#123;\n            System.out.println(str);\n            str += new Random(999999999);\n        &#125;\n    &#125;\n&#125;    \n\n永久区/元空间\n逻辑上存在，物理上不存在。新生区+老年区=jvm使用的堆内存\n\n这个区域常驻内存的，用来存放jdk自身携带的Class对象、Interface元数据，存储的是Java运行的一些环境或类信息。这个区域不存在垃圾回收。关闭虚拟机就会释放这个区域的内存。\n历史：\n\nJdk1.6之前：永久代，常量池在方法区重\n\nJDK1.7：永久代，但是慢慢的退化了。去永久代，常量池在堆中\n\nJDK1.8以后：无永久代，常量池在元空间\n\n\n垃圾回收垃圾回收主要是在伊甸园区和养老区\n垃圾回收可分为两种：\n\n轻量级垃圾回收（轻gc）\n​    回收新生区和偶尔幸存区\n\n重量级垃圾回收（重gc、full gc）\n​    养老区满了，回收养老区\n\n\nJVM如何判断对象需要回收？\n\n引用计数法：每个对象引用次数做计数，每次被引用则计数+1，失去引用则-1。当计数为0的就清除。\n可达性算法：从GC Roots开始查找引用，能够被找到的说明被引用可达，其余的则引用不可达，需要清除。\n\n什么是GC Roots？\n\n虚拟机栈（栈帧中的本地变量表）中引用的对象\n方法区中类静态属性引用的对象\n方法区中常量引用的对象\n本地方法栈中JNI（即一般说的native方法）中引用的对象\n\ngc算法标记清除法：扫描对象，对活着的对象进行标记；对没有标记的对象进行清除\n​        优点：不需要额外空间\n​        缺点：标记和清除两次扫描，严重浪费时间；会产生内存碎片\n标记压缩：再对标记清除算法进行压缩整理\n​        再次扫描，向一段移动存活对对象，防止内存碎片的产生\n复制算法：新生区以及from区的存活对象复制到to区，to区永远是空的\n​        优点：没有内存碎片\n​        缺点：浪费空间，to区永远是空的\n​        最佳使用场景：对象存活度较低，新生区\n总结内存效率：复制算法&gt;标记清除&gt;标记压缩（时间复杂度）\n内存整齐度：复制算法=标记压缩&gt;标记清除\n内存利用率：标记压缩=标记清除&gt;复制算法\n\n没有最优的算法，只有最合适的算法。\n\n所以GC使用分代收集算法\n新生区：存活率较低，使用复制算法\n老年区：存活率较高，使用标记清除+标记压缩算法\n","categories":["Java"],"tags":["JVM"]},{"title":"（已解决）IDEA Tomcat控制台中文乱码","url":"/post/Java/%EF%BC%88%E5%B7%B2%E8%A7%A3%E5%86%B3%EF%BC%89IDEA-Tomcat%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81.html","content":"@TOC\n前言此篇博客记录自己解决win系统idea配置tomcat控制台输出乱码问题，所有的尝试我都会列举出来。有同样问题的朋友可以借鉴，我本人的解决方法为方法6，推荐优先尝试\n环境系统：windows 7IDEA：2020.1Tomcat：7.0.96\n问题描述：IDEA配置Tomcat后，启动在IDEA控制台的输出，中文为乱码\n尝试办法1.配置启动参数（未解决）-Dfile.encoding&#x3D;UTF-8\n\n\n2.修改IDEA配置，idea64.exe.vmoptions（未解决）安装目录\\JetBrains\\IntelliJ IDEA 2019.2.2\\bin\\idea64.exe.vmoptions与安装目录\\JetBrains\\IntelliJ IDEA 2019.2.2\\bin\\idea.exe.vmoptions增加一行\n-Dfile.encoding&#x3D;UTF-8\n\n\n同时也配置方法1\n3.修改Tomcat配置（未解决）Tomcat安装目录...\\apache-tomcat-8.5.57\\conf\\logging.properties，将所有的UTF-8修改为GBK，保存重启\n4.配置IDEA FileEncoding（未解决）从File-&gt;Setting ,设置File Encodings ,检查Default Encodings 是否是UTF-8\n5.配置JAVA_TOOL_OPTION（未解决）Name：JAVA_TOOL_OPTIONValue：-Dfile.encoding=UTF-8同时配置了方法1,2,4\n6.通过设置修改VmOption（解决）这个不同于方法2，这个是通过程序提供的方法修改参数，最终测试有效Help-&gt;Edit Custom VM Options...，添加一行-Dfile.encoding=UTF-8\n\n我这里同时配置了方法4，因为我认为统一编码格式挺好的，所以没有还原该配置，如果单独配置方法6不生效，可以尝试配置方法4\n\n\n总结先附上解决效果图（喜极而泣）\n通过最后成功的方法分析，修改的配置文件其实是在AppData目录下的配置文件\n","categories":["Java","工具软件"],"tags":["IDEA"]},{"title":"SpringCloud Nacos","url":"/post/SpringCloud/SpringCloud-Nacos.html","content":"简介为什么叫Nacos\nNacos:Dynamic Naming and Configuration Service前四个字母分别为naming和Configuration的前两个字母，最后的s为service\n是什么？\n一个更易于构建云原生应用的动态服务发现，配置管理和服务管理平台。Nacos就是注册中心+配置中心的组合\n下载&amp;安装&amp;运行\n环境：Java8 + Maven环境\n\n下载：https://github.com/alibaba/nacos\n安装：直接解压缩\n运行：运行startup.cmd\n运行成功后访问 http://localhost:8848/nacos，帐号密码默认都是nacos\n服务注册中心服务提供者坐标：\n&lt;!--SpringCloud alibaba Nacos-->\n&lt;dependency>\n    &lt;groupId>com.alibaba.cloud&lt;/groupId>\n    &lt;artifactId>spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId>\n&lt;/dependency>\n\n配置：\nserver:\n  port: 9001\n\nspring:\n  application:\n    name: nacos-payment-provider\n  cloud:\n    nacos:\n      discovery:\n        server-addr: 127.0.0.1:8848\n\n启动类：\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class Payment9001 &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Payment9001.class,args);\n    &#125;\n&#125;\n\n服务：\n@RestController\n@RequestMapping(\"/payment\")\npublic class PaymentController &#123;\n\n    @Value(\"$&#123;server.port&#125;\")\n    private String port;\n\n    @GetMapping(\"/nacos/&#123;id&#125;\")\n    public String getPayment(@PathVariable(\"id\") Integer id)&#123;\n        return \"nacos port:\"+port+\" id:\"+id;\n    &#125;\n&#125;\n\n服务消费者坐标：\n&lt;!--SpringCloud alibaba Nacos-->\n&lt;dependency>\n    &lt;groupId>com.alibaba.cloud&lt;/groupId>\n    &lt;artifactId>spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId>\n&lt;/dependency>\n\n配置：\nserver:\n  port: 83\nspring:\n  application:\n    name: nacos-consumer-order\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848\n\n#消费者将要去访问的微服务名称（注册成功进nacos的微服务提供者）\nservice-url:\n  nacos-user-service: http://nacos-payment-provider\n\n启动类：\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class Payment9001 &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Payment9001.class,args);\n    &#125;\n&#125;\n\n配置：\n@Configuration\npublic class Config &#123;\n\n    @Bean\n    @LoadBalanced       //负载均衡根据服务名查找报错，需要添加此注解\n    public RestTemplate getRestTemplate()&#123;\n        return new RestTemplate();\n    &#125;\n\n&#125;\n\n服务：\n@Slf4j@RestController@RequestMapping(\"/consumer\")public class OrderNacosController &#123;    @Resource    private RestTemplate restTemplate;    @Value(\"$&#123;service-url.nacos-user-service&#125;\")    private String serviceUrl;    @GetMapping(\"/get/&#123;id&#125;\")    public String get(@PathVariable(\"id\") String id)&#123;        return restTemplate.getForObject(serviceUrl+\"/payment/nacos/\"+id,String.class);    &#125;&#125;\n\nCAP切换CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）\nC是所有借点在同一时间看到的数据是一致的；而A的定义是所有的请求都会收到响应。\n如何选择模式\n一般来说，如果不需要存储服务级别的信息且服务实例都是通过nacos-client注册，并且能够保持心跳上报，那么就可以选择AP模式。当前主流的服务如Spring Cloud和Dubbo服务，都是用于AP模式，AP模式为了服务的可用性而减弱了一致性，因此AP模式下只支持注册临时实例。\n如果需要在服务级别编辑或者存储配置信息，那么CP是必须，K8S服务和DNS服务则适用于CP模式。CP模式下则支持注册持久化实力，此时则是Raft协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。\n服务配置中心基础配置坐标：\n&lt;!--SpringCloud alibaba Nacos-->&lt;dependency>    &lt;groupId>com.alibaba.cloud&lt;/groupId>    &lt;artifactId>spring-cloud-starter-alibaba-nacos-config&lt;/artifactId>&lt;/dependency>&lt;dependency>    &lt;groupId>com.alibaba.cloud&lt;/groupId>    &lt;artifactId>spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId>&lt;/dependency>\n\n配置：\nbootstrap:\nserver:  port: 3377spring:  application:    name: nacos-config-client  cloud:    nacos:      discovery:        server-addr: 192.168.31.66:8848      config:        server-addr: 192.168.31.66:8848        file-extension: yaml #指定配置文件格式\n\napplication:\nspring:  profiles:    active: dev\n\n\n为什么两个配置？\nNacos同SpringCloud-config一样，在项目初始化时，要保证先从配置中心进行配置拉取。拉取配置之后，才能保证项目的正常启动。\nSpringBoot中配置文件的加载时存在有线级顺序的，bootstrap优先级高于application\n\n在 Nacos Spring Cloud 中，dataId 的完整格式如下：\n$&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;\n\nprefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix来配置。\nspring.profiles.active 即为当前环境对应的 profile，详情可以参考 Spring Boot文档。 注意：当 spring.profiles.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 $&#123;prefix&#125;.$&#123;file-extension&#125;\nfile-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。\n\n","categories":["Java","Spring系列"],"tags":["SpringCloud","Nacos"]},{"title":"如何申请免费顶级域名","url":"/post/%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E9%A1%B6%E7%BA%A7%E5%9F%9F%E5%90%8D.html","content":"前言freenom.com是一个提供免费域名申请的网站。目前提供了TK，ML，CF，GA，GQ免费的顶级域名。需要注意的是如果长时间不用，域名会被自动回收。\n步骤\n注册账号（尽量完善个人信息，不完善可能导致下单失败），可以参考一下信息填写\n\n查询域名的可用性，选择要注册的域名，点击完成进入购物车\n\n更改购买时长，最长可以选到12个月免费时长（快到期自动续费即可）\n\n\n\n在购物车中进行付款\n\n在阿里云（其他DNS解析同理）提供的免费DNS解析中进行配置。首先添加域名提示未使用阿里云解析\n\n进行解析设置，添加如下设置。记录类型为NS，记录值为上图中的DNS服务器\n\n在freenom中配置nameserver。首先进入域名管理界面\n\n点击管理选项\n\n选择NameServer\n\n选择Use custom nameservers，填入阿里云的DNS服务器，点击Change Nameservers\n\n返回阿里云域名管理，可以看到DNS服务器状态为正常\n\n在解析管理中添加解析，如图添加了云服务器的配置\n\n由于服务器中还未搭建网站等，直接通过ping命令访问。可以看到成功ping通，并且IP地址为我们服务器的地址。\n\n\n","categories":["互联网"],"tags":["免费域名"]},{"title":"Hello World","url":"/post/hello-world.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start创建一个新文章#以下命令功能相同，都在post下面创建了新文章\n$ hexo new \"My New Post\"\n$ hexo n \"My New Post\"\n$ hexo new post \"My New Post\"\n\nMore info: Writing\n启动服务#以下命令等价\n$ hexo server\n$ hexo s\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\n发布网站到远程$ hexo deploy\n$ hexo d\n\nMore info: Deployment\n","categories":["博客搭建"],"tags":["Hexo"]}]